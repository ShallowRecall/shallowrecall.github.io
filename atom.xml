<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shallow Memory&#39;s Blog</title>
  
  <subtitle>生活明朗，万物可爱</subtitle>
  <link href="https://www.shallowrecall.top/atom.xml" rel="self"/>
  
  <link href="https://www.shallowrecall.top/"/>
  <updated>2024-12-01T10:47:28.110Z</updated>
  <id>https://www.shallowrecall.top/</id>
  
  <author>
    <name>Recall</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.shallowrecall.top/posts/4a17b156.html"/>
    <id>https://www.shallowrecall.top/posts/4a17b156.html</id>
    <published>2024-12-01T10:47:28.109Z</published>
    <updated>2024-12-01T10:47:28.110Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MyBatis-Plus</title>
    <link href="https://www.shallowrecall.top/posts/1276cc28.html"/>
    <id>https://www.shallowrecall.top/posts/1276cc28.html</id>
    <published>2024-05-02T14:41:52.000Z</published>
    <updated>2024-12-01T10:54:07.220Z</updated>
    
    <content type="html"><![CDATA[<p>大家在日常开发中应该能发现，单表的CRUD功能代码重复度很高，也没有什么难度。而这部分代码量往往比较大，开发起来比较费时。</p><p>因此，目前企业中都会使用一些组件来简化或省略单表的CRUD开发工作。目前在国内使用较多的一个组件就是MybatisPlus.</p><p>当然，MybatisPlus不仅仅可以简化单表操作，而且还对Mybatis的功能有很多的增强。可以让我们的开发更加的简单，高效。</p><p>通过今天的学习，我们要达成下面的目标：</p><ul><li>能利用MybatisPlus实现基本的CRUD</li><li>会使用条件构建造器构建查询和更新语句</li><li>会使用MybatisPlus中的常用注解</li><li>会使用MybatisPlus处理枚举、JSON类型字段</li><li>会使用MybatisPlus实现分页</li></ul><h1 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a><strong>1.快速入门</strong></h1><p>为了方便测试，我们先创建一个新的项目，并准备一些基础数据。</p><h2 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1.环境准备"></a><strong>1.1.环境准备</strong></h2><p>复制课前资料提供好的一个项目到你的工作空间（不要包含空格和特殊字符）：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502225914784.png" alt="image-20240502225914784"></p><p>然后用你的IDEA工具打开，项目结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502225922637.png" alt="image-20240502225922637"></p><p>注意配置一下项目的JDK版本为JDK11。首先点击项目结构设置：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502225929704.png" alt="image-20240502225929704"></p><p>在弹窗中配置JDK：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502225936311.png" alt="image-20240502225936311"></p><p>接下来，要导入两张表，在课前资料中已经提供了SQL文件：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502225941808.png" alt="image-20240502225941808"></p><p>对应的数据库表结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502225946414.png" alt="image-20240502225946414"></p><p>最后，在<code>application.yaml</code>中修改jdbc参数为你自己的数据库参数：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">MySQL123</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.itheima:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss</span></span><br></pre></td></tr></table></figure><h2 id="1-2-快速开始"><a href="#1-2-快速开始" class="headerlink" title="1.2.快速开始"></a><strong>1.2.快速开始</strong></h2><p>比如我们要实现User表的CRUD，只需要下面几步：</p><ul><li>引入MybatisPlus依赖</li><li>定义Mapper</li></ul><h3 id="1-2-1引入依赖"><a href="#1-2-1引入依赖" class="headerlink" title="1.2.1引入依赖"></a><strong>1.2.1引入依赖</strong></h3><p>MybatisPlus提供了starter，实现了自动Mybatis以及MybatisPlus的自动装配功能，坐标如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于这个starter包含对mybatis的自动装配，因此完全可以替换掉Mybatis的starter。 最终，项目的依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-定义Mapper"><a href="#1-2-2-定义Mapper" class="headerlink" title="1.2.2.定义Mapper"></a><strong>1.2.2.定义Mapper</strong></h3><p>为了简化单表CRUD，MybatisPlus提供了一个基础的<code>BaseMapper</code>接口，其中已经实现了单表的CRUD：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502225958501.png" alt="image-20240502225958501"></p><p>因此我们自定义的Mapper只要实现了这个<code>BaseMapper</code>，就无需自己实现单表CRUD了。 修改mp-demo中的<code>com.itheima.mp.mapper</code>包下的<code>UserMapper</code>接口，让其继承<code>BaseMapper</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230003985.png" alt="image-20240502230003985"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-测试"><a href="#1-2-3-测试" class="headerlink" title="1.2.3.测试"></a><strong>1.2.3.测试</strong></h3><p>新建一个测试类，编写几个单元测试，测试基本的CRUD功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserMapperTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">5L</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;Lucy&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;18688990011&quot;</span>);</span><br><span class="line">        user.setBalance(<span class="number">200</span>);</span><br><span class="line">        user.setInfo(<span class="string">&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;</span>);</span><br><span class="line">        user.setCreateTime(LocalDateTime.now());</span><br><span class="line">        user.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">5L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSelectByIds</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectBatchIds(List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>, <span class="number">4L</span>, <span class="number">5L</span>));</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdateById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">5L</span>);</span><br><span class="line">        user.setBalance(<span class="number">20000</span>);</span><br><span class="line">        userMapper.updateById(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">        userMapper.deleteById(<span class="number">5L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在运行过程中打印出的SQL日志，非常标准：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">05</span>:<span class="number">01</span>  INFO <span class="number">15524</span> <span class="comment">--- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span></span><br><span class="line"><span class="number">11</span>:<span class="number">05</span>:<span class="number">02</span>  INFO <span class="number">15524</span> <span class="comment">--- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span></span><br><span class="line"><span class="number">11</span>:<span class="number">05</span>:<span class="number">02</span> DEBUG <span class="number">15524</span> <span class="comment">--- [           main] c.i.mp.mapper.UserMapper.selectById      : ==&gt;  Preparing: SELECT id,username,password,phone,info,status,balance,create_time,update_time FROM user WHERE id=?</span></span><br><span class="line"><span class="number">11</span>:<span class="number">05</span>:<span class="number">02</span> DEBUG <span class="number">15524</span> <span class="comment">--- [           main] c.i.mp.mapper.UserMapper.selectById      : ==&gt; Parameters: 5(Long)</span></span><br><span class="line"><span class="number">11</span>:<span class="number">05</span>:<span class="number">02</span> DEBUG <span class="number">15524</span> <span class="comment">--- [           main] c.i.mp.mapper.UserMapper.selectById      : &lt;==      Total: 1</span></span><br><span class="line"><span class="keyword">user</span> <span class="operator">=</span> <span class="keyword">User</span>(id<span class="operator">=</span><span class="number">5</span>, username<span class="operator">=</span>Lucy, password<span class="operator">=</span><span class="number">123</span>, phone<span class="operator">=</span><span class="number">18688990011</span>, info<span class="operator">=</span>&#123;&quot;age&quot;: <span class="number">21</span>&#125;, status<span class="operator">=</span><span class="number">1</span>, balance<span class="operator">=</span><span class="number">20000</span>, createTime<span class="operator">=</span>Fri Jun <span class="number">30</span> <span class="number">11</span>:<span class="number">02</span>:<span class="number">30</span> CST <span class="number">2023</span>, updateTime<span class="operator">=</span>Fri Jun <span class="number">30</span> <span class="number">11</span>:<span class="number">02</span>:<span class="number">30</span> CST <span class="number">2023</span>)</span><br></pre></td></tr></table></figure><p>只需要继承BaseMapper就能省去所有的单表CRUD，是不是非常简单！</p><h2 id="1-3-常见注解"><a href="#1-3-常见注解" class="headerlink" title="1.3.常见注解"></a><strong>1.3.常见注解</strong></h2><p>在刚刚的入门案例中，我们仅仅引入了依赖，继承了BaseMapper就能使用MybatisPlus，非常简单。但是问题来了： MybatisPlus如何知道我们要查询的是哪张表？表中有哪些字段呢？</p><p>大家回忆一下，UserMapper在继承BaseMapper的时候指定了一个泛型：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230020175.png" alt="image-20240502230020175"></p><p>泛型中的User就是与数据库对应的PO.</p><p>MybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：</p><ul><li>MybatisPlus会把PO实体的类名驼峰转下划线作为表名</li><li>MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型</li><li>MybatisPlus会把名为id的字段作为主键</li></ul><p>但很多情况下，默认的实现与实际场景不符，因此MybatisPlus提供了一些注解便于我们声明表信息。</p><h3 id="1-3-1-TableName"><a href="#1-3-1-TableName" class="headerlink" title="1.3.1.@TableName"></a><strong>1.3.1.@TableName</strong></h3><p>说明：</p><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TableName注解除了指定表名以外，还可以指定很多其它属性：</p><div class="table-container"><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必须指定</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>表名</td></tr><tr><td>schema</td><td>String</td><td>否</td><td>“”</td><td>schema</td></tr><tr><td>keepGlobalPrefix</td><td>boolean</td><td>否</td><td>false</td><td>是否保持使用全局的 tablePrefix 的值（当全局 tablePrefix 生效时）</td></tr><tr><td>resultMap</td><td>String</td><td>否</td><td>“”</td><td>xml 中 resultMap 的 id（用于满足特定类型的实体类对象绑定）</td></tr><tr><td>autoResultMap</td><td>boolean</td><td>否</td><td>false</td><td>是否自动构建 resultMap 并使用（如果设置 resultMap 则不会进行 resultMap 的自动构建与注入）</td></tr><tr><td>excludeProperty</td><td>String[]</td><td>否</td><td>{}</td><td>需要排除的属性名 @since 3.3.1</td></tr></tbody></table></div><h3 id="1-3-2-TableId"><a href="#1-3-2-TableId" class="headerlink" title="1.3.2.@TableId"></a><strong>1.3.2.@TableId</strong></h3><p>说明：</p><ul><li>描述：主键注解，标识实体类中的主键字段</li><li>使用位置：实体类的主键字段</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TableId</code>注解支持两个属性：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>属性</strong></th><th style="text-align:left"><strong>类型</strong></th><th style="text-align:left"><strong>必须指定</strong></th><th style="text-align:left"><strong>默认值</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">value</td><td style="text-align:left">String</td><td style="text-align:left">否</td><td style="text-align:left">“”</td><td style="text-align:left">表名</td></tr><tr><td style="text-align:left">type</td><td style="text-align:left">Enum</td><td style="text-align:left">否</td><td style="text-align:left">IdType.NONE</td><td style="text-align:left">指定主键类型</td></tr></tbody></table></div><p><code>IdType</code>支持的类型有：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>值</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">AUTO</td><td style="text-align:left">数据库 ID 自增</td></tr><tr><td style="text-align:left">NONE</td><td style="text-align:left">无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td style="text-align:left">INPUT</td><td style="text-align:left">insert 前自行 set 主键值</td></tr><tr><td style="text-align:left">ASSIGN_ID</td><td style="text-align:left">分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td></tr><tr><td style="text-align:left">ASSIGN_UUID</td><td style="text-align:left">分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td></tr><tr><td style="text-align:left">ID_WORKER</td><td style="text-align:left">分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)</td></tr><tr><td style="text-align:left">UUID</td><td style="text-align:left">32 位 UUID 字符串(please use ASSIGN_UUID)</td></tr><tr><td style="text-align:left">ID_WORKER_STR</td><td style="text-align:left">分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)</td></tr></tbody></table></div><p>这里比较常见的有三种：</p><ul><li><code>AUTO</code>：利用数据库的id自增长</li><li><code>INPUT</code>：手动生成id</li><li><code>ASSIGN_ID</code>：雪花算法生成<code>Long</code>类型的全局唯一id，这是默认的ID策略</li></ul><h3 id="1-3-3-TableField"><a href="#1-3-3-TableField" class="headerlink" title="1.3.3.@TableField"></a><strong>1.3.3.@TableField</strong></h3><p>说明：</p><blockquote><p>描述：普通字段注解</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@TableField(&quot;isMarried&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isMarried;</span><br><span class="line">    <span class="meta">@TableField(&quot;concat&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String concat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下我们并不需要给字段添加<code>@TableField</code>注解，一些特殊情况除外：</p><ul><li>成员变量名与数据库字段名不一致</li><li>成员变量是以<code>isXXX</code>命名，按照<code>JavaBean</code>的规范，<code>MybatisPlus</code>识别字段时会把<code>is</code>去除，这就导致与数据库不符。</li><li>成员变量名与数据库一致，但是与数据库的关键字冲突。使用<code>@TableField</code>注解给字段名添加转义字符：````</li></ul><p>支持的其它属性如下：<br><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502233148508.png" alt="image-20240502233148508"></p><h2 id="1-4-常见配置"><a href="#1-4-常见配置" class="headerlink" title="1.4.常见配置"></a><strong>1.4.常见配置</strong></h2><p>MybatisPlus也支持基于yaml文件的自定义配置，详见官方文档：</p><p><a href="https://www.baomidou.com/pages/56bac0/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">https://www.baomidou.com/pages/56bac0/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE</a></p><p>大多数的配置都有默认值，因此我们都无需配置。但还有一些是没有默认值的，例如:</p><ul><li>实体类的别名扫描包</li><li>全局id类型</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.domain.po</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment"># 全局id类型为自增长</span></span><br></pre></td></tr></table></figure><p>需要注意的是，MyBatisPlus也支持手写SQL的，而mapper文件的读取地址可以自己配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="comment"># Mapper.xml文件地址，当前这个是默认值。</span></span><br></pre></td></tr></table></figure><p>可以看到默认值是<code>classpath*:/mapper/**/*.xml</code>，也就是说我们只要把mapper.xml文件放置这个目录下就一定会被加载。</p><p>例如，我们新建一个<code>UserMapper.xml</code>文件：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230050365.png" alt="image-20240502230050365"></p><p>然后在其中定义一个方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mp.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在测试类<code>UserMapperTest</code>中测试该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.queryById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-核心功能"><a href="#2-核心功能" class="headerlink" title="2.核心功能"></a><strong>2.核心功能</strong></h1><p>刚才的案例中都是以id为条件的简单CRUD，一些复杂条件的SQL语句就要用到一些更高级的功能了。</p><h2 id="2-1-条件构造器"><a href="#2-1-条件构造器" class="headerlink" title="2.1.条件构造器"></a><strong>2.1.条件构造器</strong></h2><p>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以<code>id</code>作为<code>where</code>条件以外，还支持更加复杂的<code>where</code>条件。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230058272.png" alt="image-20240502230058272"></p><p>参数中的<code>Wrapper</code>就是条件构造的抽象类，其下有很多默认实现，继承关系如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230103049.png" alt="image-20240502230103049"></p><p><code>Wrapper</code>的子类<code>AbstractWrapper</code>提供了where中包含的所有条件构造方法：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230108002.png" alt="image-20240502230108002"></p><p>而QueryWrapper在AbstractWrapper的基础上拓展了一个select方法，允许指定查询字段：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230114564.png" alt="image-20240502230114564"></p><p>而UpdateWrapper在AbstractWrapper的基础上拓展了一个set方法，允许指定SQL中的SET部分：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230120130.png" alt="image-20240502230120130"></p><p>接下来，我们就来看看如何利用<code>Wrapper</code>实现复杂查询。</p><h3 id="2-1-1-QueryWrapper"><a href="#2-1-1-QueryWrapper" class="headerlink" title="2.1.1.QueryWrapper"></a><strong>2.1.1.QueryWrapper</strong></h3><p>无论是修改、删除、查询，都可以使用QueryWrapper来构建查询条件。接下来看一些例子： <strong>查询</strong>：查询出名字中带<code>o</code>的，存款大于等于1000元的人。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">            .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 2.查询数据</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>更新</strong>：更新用户名为jack的用户的余额为2000，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateByQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建查询条件 where name = &quot;Jack&quot;</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().eq(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.更新数据，user中非null字段都会作为set语句</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setBalance(<span class="number">2000</span>);</span><br><span class="line">    userMapper.update(user, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-UpdateWrapper"><a href="#2-1-2-UpdateWrapper" class="headerlink" title="2.1.2.UpdateWrapper"></a><strong>2.1.2.UpdateWrapper</strong></h3><p>基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现。 例如：更新id为<code>1,2,4</code>的用户的余额，扣200，对应的SQL应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE user <span class="type">SET</span> <span class="variable">balance</span> <span class="operator">=</span> balance - <span class="number">200</span> WHERE id <span class="title function_">in</span> <span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span></span><br></pre></td></tr></table></figure><p>SET的赋值结果是基于字段现有值的，这个时候就要利用UpdateWrapper中的setSql功能了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    <span class="comment">// 1.生成SQL</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;User&gt;()</span><br><span class="line">            .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>) <span class="comment">// SET balance = balance - 200</span></span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids); <span class="comment">// WHERE id in (1, 2, 4)</span></span><br><span class="line">        <span class="comment">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span></span><br><span class="line">    <span class="comment">// 而是基于UpdateWrapper中的setSQL来更新</span></span><br><span class="line">    userMapper.update(<span class="literal">null</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-LambdaQueryWrapper"><a href="#2-1-3-LambdaQueryWrapper" class="headerlink" title="2.1.3.LambdaQueryWrapper"></a><strong>2.1.3.LambdaQueryWrapper</strong></h3><p>无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串<code>魔法值</code>。这在编程规范中显然是不推荐的。 那怎么样才能不写字段名，又能知道字段名呢？</p><p>其中一种办法是基于变量的<code>gettter</code>方法结合反射技术。因此我们只要将条件对应的字段的<code>getter</code>方法传递给MybatisPlus，它就能计算出对应的变量名了。而传递方法可以使用JDK8中的<code>方法引用</code>和<code>Lambda</code>表达式。 因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：</p><ul><li>LambdaQueryWrapper</li><li>LambdaUpdateWrapper</li></ul><p>分别对应QueryWrapper和UpdateWrapper</p><p>其使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.lambda()</span><br><span class="line">            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(User::getBalance, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-自定义-SQL"><a href="#2-2-自定义-SQL" class="headerlink" title="2.2.自定义**SQL**"></a><strong>2.2.自定义**</strong>SQL**</h2><p>在演示UpdateWrapper的案例中，我们在代码中编写了更新的SQL语句：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230138511.png" alt="image-20240502230138511"></p><p>这种写法在某些企业也是不允许的，因为SQL语句最好都维护在持久层，而不是业务层。就当前案例来说，由于条件是in语句，只能将SQL写在Mapper.xml文件，利用foreach来生成动态SQL。 这实在是太麻烦了。假如查询条件更复杂，动态SQL的编写也会更加复杂。</p><p>所以，MybatisPlus提供了自定义SQL功能，可以让我们利用Wrapper生成查询条件，再结合Mapper.xml编写SQL</p><h3 id="2-2-1-基本用法"><a href="#2-2-1-基本用法" class="headerlink" title="2.2.1.基本用法"></a><strong>2.2.1.基本用法</strong></h3><p>以当前案例来说，我们可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().in(<span class="string">&quot;id&quot;</span>, ids);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法，直接传递Wrapper</span></span><br><span class="line">    userMapper.deductBalanceByIds(<span class="number">200</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在UserMapper中自定义SQL：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalanceByIds</span><span class="params">(<span class="meta">@Param(&quot;money&quot;)</span> <span class="type">int</span> money, <span class="meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就省去了编写复杂查询条件的烦恼了。</p><h3 id="2-2-2-多表关联"><a href="#2-2-2-多表关联" class="headerlink" title="2.2.2.多表关联"></a><strong>2.2.2.多表关联</strong></h3><p>理论上来讲MyBatisPlus是不支持多表查询的，不过我们可以利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。 例如，我们要查询出所有收货地址在北京的并且用户id在1、2、4之中的用户 要是自己基于mybatis实现SQL，大概是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">      SELECT *</span><br><span class="line">      FROM user u</span><br><span class="line">      INNER JOIN address a ON u.id = a.user_id</span><br><span class="line">      WHERE u.id</span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;IN (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">          #&#123;id&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">      AND a.city = #&#123;city&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出其中最复杂的就是WHERE条件的编写，如果业务复杂一些，这里的SQL会更变态。</p><p>但是基于自定义SQL结合Wrapper的玩法，我们就可以利用Wrapper来构建查询条件，然后手写SELECT及FROM部分，实现多表查询。</p><p>查询条件这样来构建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomJoinWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .in(<span class="string">&quot;u.id&quot;</span>, List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>))</span><br><span class="line">            .eq(<span class="string">&quot;a.city&quot;</span>, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.queryUserByWrapper(wrapper);</span><br><span class="line"></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在UserMapper中自定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">queryUserByWrapper</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span>QueryWrapper&lt;User&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure><p>当然，也可以在<code>UserMapper.xml</code>中写SQL：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-Service接口"><a href="#2-3-Service接口" class="headerlink" title="2.3.Service接口"></a><strong>2.3.Service接口</strong></h2><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。 通用接口为<code>IService</code>，默认实现为<code>ServiceImpl</code>，其中封装的方法可以分为以下几类：</p><ul><li><code>save</code>：新增</li><li><code>remove</code>：删除</li><li><code>update</code>：更新</li><li><code>get</code>：查询单个结果</li><li><code>list</code>：查询集合结果</li><li><code>count</code>：计数</li><li><code>page</code>：分页查询</li></ul><h3 id="2-3-1-CRUD"><a href="#2-3-1-CRUD" class="headerlink" title="2.3.1.CRUD"></a><strong>2.3.1.CRUD</strong></h3><p>我们先俩看下基本的CRUD接口。 <strong>新增</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230205447.png" alt="image-20240502230205447"></p><ul><li><code>save</code>是新增单个元素</li><li><code>saveBatch</code>是批量新增</li><li><code>saveOrUpdate</code>是根据id判断，如果数据存在就更新，不存在则新增</li><li><code>saveOrUpdateBatch</code>是批量的新增或修改</li></ul><p><strong>删除：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230210680.png" alt="image-20240502230210680"></p><ul><li><code>removeById</code>：根据id删除</li><li><code>removeByIds</code>：根据id批量删除</li><li><code>removeByMap</code>：根据Map中的键值对为条件删除</li><li><code>remove(Wrapper&lt;T&gt;)</code>：根据Wrapper条件删除</li><li><code>~~removeBatchByIds~~</code>：暂不支持</li></ul><p><strong>修改：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230215814.png" alt="image-20240502230215814"></p><ul><li><code>updateById</code>：根据id修改</li><li><code>update(Wrapper&lt;T&gt;)</code>：根据<code>UpdateWrapper</code>修改，<code>Wrapper</code>中包含<code>set</code>和<code>where</code>部分</li><li><code>update(T，Wrapper&lt;T&gt;)</code>：按照<code>T</code>内的数据修改与<code>Wrapper</code>匹配到的数据</li><li><code>updateBatchById</code>：根据id批量修改</li></ul><p><strong>Get：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230221154.png" alt="image-20240502230221154"></p><ul><li><code>getById</code>：根据id查询1条数据</li><li><code>getOne(Wrapper&lt;T&gt;)</code>：根据<code>Wrapper</code>查询1条数据</li><li><code>getBaseMapper</code>：获取<code>Service</code>内的<code>BaseMapper</code>实现，某些时候需要直接调用<code>Mapper</code>内的自定义<code>SQL</code>时可以用这个方法获取到<code>Mapper</code></li></ul><p><strong>List：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230227351.png" alt="image-20240502230227351"></p><ul><li><code>listByIds</code>：根据id批量查询</li><li><code>list(Wrapper&lt;T&gt;)</code>：根据Wrapper条件查询多条数据</li><li><code>list()</code>：查询所有</li></ul><p><strong>Count</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230232781.png" alt="image-20240502230232781"></p><ul><li><code>count()</code>：统计所有数量</li><li><code>count(Wrapper&lt;T&gt;)</code>：统计符合<code>Wrapper</code>条件的数据数量</li></ul><p><strong>getBaseMapper</strong>： 当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230237701.png" alt="image-20240502230237701"></p><h3 id="2-3-2-基本用法"><a href="#2-3-2-基本用法" class="headerlink" title="2.3.2.基本用法"></a><strong>2.3.2.基本用法</strong></h3><p>由于<code>Service</code>中经常需要定义与业务有关的自定义方法，因此我们不能直接使用<code>IService</code>，而是自定义<code>Service</code>接口，然后继承<code>IService</code>以拓展方法。同时，让自定义的<code>Service实现类</code>继承<code>ServiceImpl</code>，这样就不用自己实现<code>IService</code>中的接口了。</p><p>首先，定义<code>IUserService</code>，继承<code>IService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 拓展自定义方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，编写<code>UserServiceImpl</code>类，继承<code>ServiceImpl</code>，实现<code>UserService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;</span><br><span class="line">                                                                                                        <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230256993.png" alt="image-20240502230256993"></p><p>接下来，我们快速实现下面4个接口：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>编号</strong></th><th style="text-align:left"><strong>接口</strong></th><th style="text-align:left"><strong>请求方式</strong></th><th style="text-align:left"><strong>请求路径</strong></th><th style="text-align:left"><strong>请求参数</strong></th><th style="text-align:left"><strong>返回值</strong></th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">新增用户</td><td style="text-align:left">POST</td><td style="text-align:left">/users</td><td style="text-align:left">用户表单实体</td><td style="text-align:left">无</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">删除用户</td><td style="text-align:left">DELETE</td><td style="text-align:left">/users/{id}</td><td style="text-align:left">用户id</td><td style="text-align:left">无</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">根据id查询用户</td><td style="text-align:left">GET</td><td style="text-align:left">/users/{id}</td><td style="text-align:left">用户id</td><td style="text-align:left">用户VO</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">根据id批量查询</td><td style="text-align:left">GET</td><td style="text-align:left">/users</td><td style="text-align:left">用户id集合</td><td style="text-align:left">用户VO集合</td></tr></tbody></table></div><p>首先，我们在项目中引入几个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi2-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--web--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后需要配置swagger信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">用户管理接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;用户管理接口文档&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">zhanghuyi@itcast.cn</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">虎哥</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://www.itcast.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.itheima.mp.controller</span></span><br></pre></td></tr></table></figure><p>然后，接口需要两个实体：</p><ul><li>UserFormDTO：代表新增时的用户表单</li><li>UserVO：代表查询的返回结果</li></ul><p>首先是UserFormDTO：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;用户表单实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFormDTO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;密码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;注册手机号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;详细信息，JSON风格&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;账户余额&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是UserVO：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;用户VO实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVO</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;详细信息&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;使用状态（1正常 2冻结）&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;账户余额&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，按照Restful风格编写Controller接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.dto.UserFormDTO;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.vo.UserVO;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Api(tags = &quot;用户管理接口&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;新增用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> UserFormDTO userFormDTO)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.转换DTO为PO</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtil.copyProperties(userFormDTO, User.class);</span><br><span class="line">        <span class="comment">// 2.新增</span></span><br><span class="line">        userService.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;删除用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">        userService.removeById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;根据id查询用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserVO <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(userId);</span><br><span class="line">        <span class="comment">// 2.处理vo</span></span><br><span class="line">        <span class="keyword">return</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUserByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        List&lt;User&gt; users = userService.listByIds(ids);</span><br><span class="line">        <span class="comment">// 2.处理vo</span></span><br><span class="line">        <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上述接口都直接在controller即可实现，无需编写任何service代码，非常方便。</p><p>不过，一些带有业务逻辑的接口则需要在service中自定义实现了。例如下面的需求：</p><ul><li>根据id扣减用户余额</li></ul><p>这看起来是个简单修改功能，只要修改用户余额即可。但这个业务包含一些业务逻辑处理：</p><ul><li>判断用户状态是否正常</li><li>判断用户余额是否充足</li></ul><p>这些业务逻辑都要在service层来做，另外更新余额需要自定义SQL，要在mapper中来实现。因此，我们除了要编写controller以外，具体的业务还要在service和mapper中编写。</p><p>首先在UserController中定义一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;扣减用户余额&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id, <span class="meta">@PathVariable(&quot;money&quot;)</span>Integer money)</span>&#123;</span><br><span class="line">    userService.deductBalance(id, money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是UserService接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是UserServiceImpl实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 2.判断用户状态</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断用户余额</span></span><br><span class="line">        <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.扣减余额</span></span><br><span class="line">        baseMapper.deductMoneyById(id, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是mapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;UPDATE user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deductMoneyById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;money&quot;)</span> Integer money)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-Lambda"><a href="#2-3-3-Lambda" class="headerlink" title="2.3.3.Lambda"></a><strong>2.3.3.Lambda</strong></h3><p>IService中还提供了Lambda功能来简化我们的复杂查询及更新功能。我们通过两个案例来学习一下。</p><p>案例一：实现一个根据复杂条件查询用户的接口，查询条件如下：</p><ul><li>name：用户名关键字，可以为空</li><li>status：用户状态，可以为空</li><li>minBalance：最小余额，可以为空</li><li>maxBalance：最大余额，可以为空</li></ul><p>可以理解成一个用户的后台管理界面，管理员可以自己选择条件来筛选用户，因此上述条件不一定存在，需要做判断。</p><p>我们首先需要定义一个查询条件实体，UserQuery实体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;用户查询条件实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名关键字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最小值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer minBalance;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最大值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们在UserController中定义一个controller方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().lambda()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance);</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.list(wrapper);</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组织查询条件的时候，我们加入了 <code>username != null</code> 这样的参数，意思就是当条件成立时才会添加这个查询条件，类似Mybatis的mapper.xml文件中的<code>&lt;if&gt;</code>标签。这样就实现了动态查询条件效果了。</p><p>不过，上述条件构建的代码太麻烦了。 因此Service中对<code>LambdaQueryWrapper</code>和<code>LambdaUpdateWrapper</code>的用法进一步做了简化。我们无需自己通过<code>new</code>的方式来创建<code>Wrapper</code>，而是直接调用<code>lambdaQuery</code>和<code>lambdaUpdate</code>方法：</p><p>基于Lambda查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现lambdaQuery方法中除了可以构建条件，还需要在链式编程的最后添加一个<code>list()</code>，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用<code>list()</code>，可选的方法有：</p><ul><li><code>.one()</code>：最多1个结果</li><li><code>.list()</code>：返回集合结果</li><li><code>.count()</code>：返回计数结果</li></ul><p>MybatisPlus会根据链式编程的最后一个方法来判断最终的返回结果。</p><p>与lambdaQuery方法类似，IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务。</p><p>例如下面的需求：</p><blockquote><p>需求：改造根据id修改用户余额的接口，要求如下</p><ul><li>如果扣减后余额为0，则将用户status修改为冻结状态（2）</li></ul></blockquote><p>也就是说我们在扣减用户余额时，需要对用户剩余余额做出判断，如果发现剩余余额为0，则应该将status修改为2，这就是说update语句的set部分是动态的。</p><p>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 2.校验用户状态</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验余额是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.扣减余额 update tb_user set balance = balance - ?</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainBalance</span> <span class="operator">=</span> user.getBalance() - money;</span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(User::getBalance, remainBalance) <span class="comment">// 更新余额</span></span><br><span class="line">            .set(remainBalance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>) <span class="comment">// 动态判断，是否更新status</span></span><br><span class="line">            .eq(User::getId, id)</span><br><span class="line">            .eq(User::getBalance, user.getBalance()) <span class="comment">// 乐观锁</span></span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-批量新增"><a href="#2-3-4-批量新增" class="headerlink" title="2.3.4.批量新增"></a><strong>2.3.4.批量新增</strong></h3><p>IService中的批量新增功能使用起来非常方便，但有一点注意事项，我们先来测试一下。 首先我们测试逐条插入数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveOneByOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        userService.save(buildUser(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗时：&quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> User <span class="title function_">buildUser</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;user_&quot;</span> + i);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    user.setPhone(<span class="string">&quot;&quot;</span> + (<span class="number">18688190000L</span> + i));</span><br><span class="line">    user.setBalance(<span class="number">2000</span>);</span><br><span class="line">    user.setInfo(<span class="string">&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;</span>);</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(user.getCreateTime());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230334303.png" alt="image-20240502230334303"></p><p>可以看到速度非常慢。</p><p>然后再试试MybatisPlus的批处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveBatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 准备10万条数据</span></span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        list.add(buildUser(i));</span><br><span class="line">        <span class="comment">// 每1000条批量插入一次</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            userService.saveBatch(list);</span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗时：&quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行最终耗时如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230340751.png" alt="image-20240502230340751"></p><p>可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。</p><p>不过，我们简单查看一下<code>MybatisPlus</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">    <span class="keyword">return</span> executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...SqlHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="type">boolean</span> <span class="title function_">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="type">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;</span><br><span class="line">    Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">&quot;batchSize must not be less than one&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxLimit</span> <span class="operator">=</span> Math.min(batchSize, size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : list) &#123;</span><br><span class="line">            consumer.accept(sqlSession, element);</span><br><span class="line">            <span class="keyword">if</span> (i == idxLimit) &#123;</span><br><span class="line">                sqlSession.flushStatements();</span><br><span class="line">                idxLimit = Math.min(idxLimit + batchSize, size);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Preparing: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time ) <span class="keyword">VALUES</span> ( ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br></pre></td></tr></table></figure><p>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time )</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_4, <span class="number">123</span>, <span class="number">18688190004</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>);</span><br></pre></td></tr></table></figure><p>该怎么做呢？</p><p>MySQL的客户端连接参数中有这样的一个参数：<code>rewriteBatchedStatements</code>。顾名思义，就是重写批处理的<code>statement</code>语句。参考文档：</p><p><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements</a></p><p>这个参数的默认值是false，我们需要修改连接参数，将其配置为true</p><p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">MySQL123</span></span><br></pre></td></tr></table></figure><p>再次测试插入10万条数据，可以发现速度有非常明显的提升：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230352648.png" alt="image-20240502230352648"></p><p>在<code>ClientPreparedStatement</code>的<code>executeBatchInternal</code>中，有判断<code>rewriteBatchedStatements</code>值是否为true并重写SQL的功能：</p><p>最终，SQL被重写了：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230401230.png" alt="image-20240502230401230"></p><h1 id="3-扩展功能"><a href="#3-扩展功能" class="headerlink" title="3.扩展功能"></a><strong>3.扩展功能</strong></h1><h2 id="3-1-代码生成"><a href="#3-1-代码生成" class="headerlink" title="3.1.代码生成"></a><strong>3.1.代码生成</strong></h2><p>在使用MybatisPlus以后，基础的<code>Mapper</code>、<code>Service</code>、<code>PO</code>代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成<code>PO</code>、<code>Mapper</code>、<code>Service</code>等相关代码。只不过代码生成器同样要编码使用，也很麻烦。</p><p>这里推荐大家使用一款<code>MybatisPlus</code>的插件，它可以基于图形化界面完成<code>MybatisPlus</code>的代码生成，非常简单。</p><h3 id="3-1-1-安装插件"><a href="#3-1-1-安装插件" class="headerlink" title="3.1.1.安装插件"></a><strong>3.1.1.安装插件</strong></h3><p>在<code>Idea</code>的plugins市场中搜索并安装<code>MyBatisPlus</code>插件：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230410676.png" alt="image-20240502230410676"></p><p>然后重启你的Idea即可使用。</p><h3 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2.使用"></a><strong>3.1.2.使用</strong></h3><p>刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。 首先需要配置数据库地址，在Idea顶部菜单中，找到<code>other</code>，选择<code>Config Database</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230415932.png" alt="image-20240502230415932"></p><p>在弹出的窗口中填写数据库连接的基本信息：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230427648.png" alt="image-20240502230427648"></p><p>点击OK保存。</p><p>然后再次点击Idea顶部菜单中的other，然后选择<code>Code Generator</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230438133.png" alt="image-20240502230438133"></p><p>在弹出的表单中填写信息：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230442273.png" alt="image-20240502230442273"></p><p>最终，代码自动生成到指定的位置了：</p><h2 id="3-2-静态工具"><a href="#3-2-静态工具" class="headerlink" title="3.2.静态工具"></a><strong>3.2.静态工具</strong></h2><p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230448099.png" alt="image-20240502230448099"></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> Db.getById(<span class="number">1L</span>, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 利用Db实现复杂条件查询</span></span><br><span class="line">    List&lt;User&gt; list = Db.lambdaQuery(User.class)</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(User::getBalance, <span class="number">1000</span>)</span><br><span class="line">            .list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    Db.lambdaUpdate(User.class)</span><br><span class="line">            .set(User::getBalance, <span class="number">2000</span>)</span><br><span class="line">            .eq(User::getUsername, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求：改造根据id用户查询的接口，查询用户的同时返回用户收货地址列表</p><p>首先，我们要添加一个收货地址的VO对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;收货地址VO&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddressVO</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;省&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;市&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;县/区&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String town;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;手机&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;详细地址&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;联系人&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String contact;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;是否是默认 1默认 0否&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isDefault;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;备注&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String notes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，改造原来的UserVO，添加一个地址属性：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230500887.png" alt="image-20240502230500887"></p><p>接下来，修改UserController中根据id查询用户的业务接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserVO <span class="title function_">queryUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span>&#123;</span><br><span class="line">    <span class="comment">// 基于自定义service方法查询</span></span><br><span class="line">    <span class="keyword">return</span> userService.queryUserAndAddressById(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于查询业务复杂，所以要在service层来实现。首先在IUserService中定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.po.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.vo.UserVO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deduct</span><span class="params">(Long id, Integer money)</span>;</span><br><span class="line"></span><br><span class="line">    UserVO <span class="title function_">queryUserAndAddressById</span><span class="params">(Long userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在UserServiceImpl中实现该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserVO <span class="title function_">queryUserAndAddressById</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(userId);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询收货地址</span></span><br><span class="line">    List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)</span><br><span class="line">            .eq(Address::getUserId, userId)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="type">UserVO</span> <span class="variable">userVO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">    userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));</span><br><span class="line">    <span class="keyword">return</span> userVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。</p><p>再来实现一个功能：</p><ul><li>根据id批量查询用户，并查询出用户对应的所有地址</li></ul><h2 id="3-3-逻辑删除"><a href="#3-3-逻辑删除" class="headerlink" title="3.3.逻辑删除"></a><strong>3.3.逻辑删除</strong></h2><p>对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：</p><ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li><li>查询时过滤掉标记为true的数据</li></ul><p>一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。</p><p>为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。</p><p><strong>注意</strong>，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。</p><p>例如，我们给<code>address</code>表添加一个逻辑删除字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> address <span class="keyword">add</span> deleted bit <span class="keyword">default</span> b<span class="string">&#x27;0&#x27;</span> <span class="keyword">null</span> comment <span class="string">&#x27;逻辑删除&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后给<code>Address</code>实体添加<code>deleted</code>字段：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230519804.png" alt="image-20240502230519804"></p><p>接下来，我们要在<code>application.yml</code>中配置逻辑删除字段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><p>测试： 首先，我们执行一个删除操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteByLogic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 删除方法与以前没有区别</span></span><br><span class="line">    addressService.removeById(<span class="number">59L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与普通删除一模一样，但是底层的SQL逻辑变了：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230528718.png" alt="image-20240502230528718"></p><p>查询一下试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Address&gt; list = addressService.list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现id为59的确实没有查询出来，而且SQL中也对逻辑删除字段做了判断：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230534044.png" alt="image-20240502230534044"></p><p>综上， 开启了逻辑删除功能以后，我们就可以像普通删除一样做CRUD，基本不用考虑代码逻辑问题。还是非常方便的。</p><p><strong>注意</strong>： 逻辑删除本身也有自己的问题，比如：</p><ul><li>会导致数据库表垃圾数据越来越多，从而影响查询效率</li><li>SQL中全都需要对逻辑删除字段做判断，影响查询效率</li></ul><p>因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。</p><h2 id="3-3-通用枚举"><a href="#3-3-通用枚举" class="headerlink" title="3.3.通用枚举"></a><strong>3.3.通用枚举</strong></h2><p>User类中有一个用户状态字段：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230540216.png" alt="image-20240502230540216"></p><p>像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是<code>int</code>类型，对应的PO也是<code>Integer</code>。因此业务操作时必须手动把<code>枚举</code>与<code>Integer</code>转换，非常麻烦。</p><p>因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们<strong>把枚举类型与数据库类型自动转换</strong>。</p><h3 id="3-3-1-定义枚举"><a href="#3-3-1-定义枚举" class="headerlink" title="3.3.1.定义枚举"></a><strong>3.3.1.定义枚举</strong></h3><p>我们定义一个用户状态的枚举：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230546733.png" alt="image-20240502230546733"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.enums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123;</span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;正常&quot;</span>),</span><br><span class="line">    FREEZE(<span class="number">2</span>, <span class="string">&quot;冻结&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    UserStatus(<span class="type">int</span> value, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把<code>User</code>类中的<code>status</code>字段改为<code>UserStatus</code> 类型：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230555899.png" alt="image-20240502230555899"></p><p>要让<code>MybatisPlus</code>处理枚举与数据库类型自动转换，我们必须告诉<code>MybatisPlus</code>，枚举中的哪个字段的值作为数据库值。 <code>MybatisPlus</code>提供了<code>@EnumValue</code>注解来标记枚举属性：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230600710.png" alt="image-20240502230600710"></p><h3 id="3-3-2-配置枚举处理器"><a href="#3-3-2-配置枚举处理器" class="headerlink" title="3.3.2.**配置枚举处理器**"></a><strong>3.3.2.**</strong>配置枚举处理器**</h3><p>在application.yaml文件中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br></pre></td></tr></table></figure><h3 id="3-3-3-测试"><a href="#3-3-3-测试" class="headerlink" title="3.3.3.测试"></a><strong>3.3.3.测试</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testService</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; list = userService.list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，查询出的<code>User</code>类的<code>status</code>字段会是枚举类型：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230609616.png" alt="image-20240502230609616"></p><p>同时，为了使页面查询结果也是枚举格式，我们需要修改UserVO中的status属性：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230614246.png" alt="image-20240502230614246"></p><p>并且，在UserStatus枚举中通过<code>@JsonValue</code>注解标记JSON序列化时展示的字段：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230619039.png" alt="image-20240502230619039"></p><p>最后，在页面查询，结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230623618.png" alt="image-20240502230623618"></p><h2 id="3-4-JSON-类型处理器"><a href="#3-4-JSON-类型处理器" class="headerlink" title="3.4.**JSON**类型处理器"></a><strong>3.4.**</strong>JSON<strong>**类型处理器</strong></h2><p>数据库的user表中有一个<code>info</code>字段，是JSON类型：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230629114.png" alt="image-20240502230629114"></p><p>格式像这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;佛系青年&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>而目前<code>User</code>实体类中却是<code>String</code>类型：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230634184.png" alt="image-20240502230634184"></p><p>这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类。</p><p>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库时手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦。</p><p>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器。</p><p>接下来，我们就来看看这个处理器该如何使用。</p><h3 id="3-4-1-定义实体"><a href="#3-4-1-定义实体" class="headerlink" title="3.4.1.定义实体"></a><strong>3.4.1.定义实体</strong></h3><p>首先，我们定义一个单独实体类来与info字段的属性匹配：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230642139.png" alt="image-20240502230642139"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-2-使用类型处理器"><a href="#3-4-2-使用类型处理器" class="headerlink" title="3.4.2.使用类型处理器"></a><strong>3.4.2.使用类型处理器</strong></h3><p>接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230649052.png" alt="image-20240502230649052"></p><p>测试可以发现，所有数据都正确封装到UserInfo当中了：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230654102.png" alt="image-20240502230654102"></p><p>同时，为了让页面返回的结果也以对象格式返回，我们要修改UserVO中的info字段：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230658889.png" alt="image-20240502230658889"></p><p>此时，在页面查询结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230703687.png" alt="image-20240502230703687"></p><h2 id="3-5-配置加密（选学）"><a href="#3-5-配置加密（选学）" class="headerlink" title="3.5.配置加密（选学）"></a><strong>3.5.配置加密（选学）</strong></h2><p>目前我们配置文件中的很多参数都是明文，如果开发人员发生流动，很容易导致敏感信息的泄露。所以MybatisPlus支持配置文件的加密和解密功能。</p><p>我们以数据库的用户名和密码为例。</p><h3 id="3-5-1-生成-秘钥"><a href="#3-5-1-生成-秘钥" class="headerlink" title="3.5.1.生成**秘钥**"></a><strong>3.5.1.生成**</strong>秘钥**</h3><p>首先，我们利用AES工具生成一个随机秘钥，然后对用户名、密码加密：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.AES;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MpDemoApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生成 16 位随机 AES 密钥</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">randomKey</span> <span class="operator">=</span> AES.generateRandomKey();</span><br><span class="line">        System.out.println(<span class="string">&quot;randomKey = &quot;</span> + randomKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用密钥对用户名加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> AES.encrypt(<span class="string">&quot;root&quot;</span>, randomKey);</span><br><span class="line">        System.out.println(<span class="string">&quot;username = &quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用密钥对用户名加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> AES.encrypt(<span class="string">&quot;MySQL123&quot;</span>, randomKey);</span><br><span class="line">        System.out.println(<span class="string">&quot;password = &quot;</span> + password);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">randomKey <span class="operator">=</span> <span class="number">6234633</span>a66fb399f</span><br><span class="line">username <span class="operator">=</span> px2bAbnUfiY8K<span class="operator">/</span>IgsKvscg<span class="operator">=</span><span class="operator">=</span></span><br><span class="line">password <span class="operator">=</span> FGvCSEaOuga3ulDAsxw68Q<span class="operator">=</span><span class="operator">=</span></span><br></pre></td></tr></table></figure><h3 id="3-5-2-修改配置"><a href="#3-5-2-修改配置" class="headerlink" title="3.5.2.修改配置"></a><strong>3.5.2.修改配置</strong></h3><p>修改application.yaml文件，把jdbc的用户名、密码修改为刚刚加密生成的密文：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">mpw:QWWVnk1Oal3258x5rVhaeQ==</span> <span class="comment"># 密文要以 mpw:开头</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">mpw:EUFmeH3cNAzdRGdOQcabWg==</span> <span class="comment"># 密文要以 mpw:开头</span></span><br></pre></td></tr></table></figure><h3 id="3-5-3-测试"><a href="#3-5-3-测试" class="headerlink" title="3.5.3.测试"></a><strong>3.5.3.测试</strong></h3><p>在启动项目的时候，需要把刚才生成的秘钥添加到启动参数中，像这样：</p><p>—mpw.key=6234633a66fb399f</p><p>单元测试的时候不能添加启动参数，所以要在测试类的注解上配置：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230714664.png" alt="image-20240502230714664"></p><p>然后随意运行一个单元测试，可以发现数据库查询正常。</p><h1 id="4-插件功能"><a href="#4-插件功能" class="headerlink" title="4.插件功能"></a><strong>4.插件功能</strong></h1><p>MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：</p><ul><li><code>PaginationInnerInterceptor</code>：自动分页</li><li><code>TenantLineInnerInterceptor</code>：多租户</li><li><code>DynamicTableNameInnerInterceptor</code>：动态表名</li><li><code>OptimisticLockerInnerInterceptor</code>：乐观锁</li><li><code>IllegalSQLInnerInterceptor</code>：sql 性能规范</li><li><code>BlockAttackInnerInterceptor</code>：防止全表更新与删除</li></ul><p><strong>注意：</strong> 使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：</p><ul><li>多租户,动态表名</li><li>分页,乐观锁</li><li>sql 性能规范,防止全表更新与删除</li></ul><p>这里我们以分页插件为里来学习插件的用法。</p><h2 id="4-1-分页插件"><a href="#4-1-分页插件" class="headerlink" title="4.1.分页插件"></a><strong>4.1.分页插件</strong></h2><p>在未引入分页插件的情况下，<code>MybatisPlus</code>是不支持分页功能的，<code>IService</code>和<code>BaseMapper</code>中的分页方法都无法正常起效。 所以，我们必须配置分页插件。</p><h3 id="4-1-1-配置分页插件"><a href="#4-1-1-配置分页插件" class="headerlink" title="4.1.1.配置分页插件"></a><strong>4.1.1.配置分页插件</strong></h3><p>在项目中新建一个配置类：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230727420.png" alt="image-20240502230727420"></p><p>其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化核心插件</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-2-分页-API"><a href="#4-1-2-分页-API" class="headerlink" title="4.1.2.分页**API**"></a><strong>4.1.2.分页**</strong>API**</h3><p>编写一个分页查询的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.分页查询，new Page()的两个参数分别是：页码、每页大小</span></span><br><span class="line">    Page&lt;User&gt; p = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 2.总条数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + p.getTotal());</span><br><span class="line">    <span class="comment">// 3.总页数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + p.getPages());</span><br><span class="line">    <span class="comment">// 4.数据</span></span><br><span class="line">    List&lt;User&gt; records = p.getRecords();</span><br><span class="line">    records.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的SQL如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230738953.png" alt="image-20240502230738953"></p><p>这里用到了分页参数，Page，即可以支持分页参数，也可以支持排序参数。常见的API如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 分页参数</span></span><br><span class="line">Page&lt;User&gt; page = Page.of(pageNo, pageSize);</span><br><span class="line"><span class="comment">// 排序参数, 通过OrderItem来指定</span></span><br><span class="line">page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;balance&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">userService.page(page);</span><br></pre></td></tr></table></figure><h2 id="4-2-通用分页实体"><a href="#4-2-通用分页实体" class="headerlink" title="4.2.通用分页实体"></a><strong>4.2.通用分页实体</strong></h2><p>现在要实现一个用户分页查询的接口，接口规范如下：</p><div class="table-container"><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>请求路径</td><td>/users/page</td></tr><tr><td>请求参数</td><td><code>&#123;    &quot;pageNo&quot;: 1,    &quot;pageSize&quot;: 5,    &quot;sortBy&quot;: &quot;balance&quot;,    &quot;isAsc&quot;: false,    &quot;name&quot;: &quot;o&quot;,    &quot;status&quot;: 1 &#125;</code></td></tr><tr><td>返回值</td><td><code>&#123;    &quot;total&quot;: 100006,    &quot;pages&quot;: 50003,    &quot;list&quot;: [        &#123;            &quot;id&quot;: 1685100878975279298,            &quot;username&quot;: &quot;user_9****&quot;,            &quot;info&quot;: &#123;                &quot;age&quot;: 24,                &quot;intro&quot;: &quot;英文老师&quot;,                &quot;gender&quot;: &quot;female&quot;            &#125;,            &quot;status&quot;: &quot;正常&quot;,            &quot;balance&quot;: 2000        &#125;    ] &#125;</code></td></tr><tr><td>特殊说明</td><td>如果排序字段为空，默认按照更新时间排序排序字段不为空，则按照排序字段排序</td></tr></tbody></table></div><p>这里需要定义3个实体：</p><ul><li><code>UserQuery</code>：分页查询条件的实体，包含分页、排序参数、过滤条件</li><li><code>PageDTO</code>：分页结果实体，包含总条数、总页数、当前页数据</li><li><code>UserVO</code>：用户页面视图实体</li></ul><h3 id="4-2-1-实体"><a href="#4-2-1-实体" class="headerlink" title="4.2.1.实体"></a><strong>4.2.1.实体</strong></h3><p>由于UserQuery之前已经定义过了，并且其中已经包含了过滤条件，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;用户查询条件实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名关键字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最小值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer minBalance;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最大值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中缺少的仅仅是分页条件，而分页条件不仅仅用户分页查询需要，以后其它业务也都有分页查询的需求。因此建议将分页查询条件单独定义为一个<code>PageQuery</code>实体：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230758930.png" alt="image-20240502230758930"></p><p><code>PageQuery</code>是前端提交的查询参数，一般包含四个属性：</p><ul><li><code>pageNo</code>：页码</li><li><code>pageSize</code>：每页数据条数</li><li><code>sortBy</code>：排序字段</li><li><code>isAsc</code>：是否升序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;分页查询实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pageNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pageSize;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;排序字段&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;是否升序&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，让我们的UserQuery继承这个实体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;用户查询条件实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserQuery</span> <span class="keyword">extends</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名关键字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最小值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer minBalance;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最大值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值的用户实体沿用之前定一个<code>UserVO</code>实体：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230810948.png" alt="image-20240502230810948"></p><p>最后，则是分页实体PageDTO:</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230825299.png" alt="image-20240502230825299"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;分页结果&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;总条数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;总页数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;集合&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-开发接口"><a href="#4-2-2-开发接口" class="headerlink" title="4.2.2.开发接口"></a><strong>4.2.2.开发接口</strong></h3><p>我们在<code>UserController</code>中定义分页查询用户的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.dto.PageDTO;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.query.PageQuery;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.domain.vo.UserVO;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mp.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;users&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUsersPage</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.queryUsersPage(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 。。。 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>IUserService</code>中创建<code>queryUsersPage</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PageDTO&lt;UserVO&gt; <span class="title function_">queryUsersPage</span><span class="params">(PageQuery query)</span>;</span><br></pre></td></tr></table></figure><p>接下来，在UserServiceImpl中实现该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUsersPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    <span class="comment">// 1.1.分页条件</span></span><br><span class="line">    Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());</span><br><span class="line">    <span class="comment">// 1.2.排序条件</span></span><br><span class="line">    <span class="keyword">if</span> (query.getSortBy() != <span class="literal">null</span>) &#123;</span><br><span class="line">        page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(query.getSortBy(), query.getIsAsc()));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 默认按照更新时间排序</span></span><br><span class="line">        page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;update_time&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.数据非空校验</span></span><br><span class="line">    List&lt;User&gt; records = page.getRecords();</span><br><span class="line">    <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(page.getTotal(), page.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.有数据，转换</span></span><br><span class="line">    List&lt;UserVO&gt; list = BeanUtil.copyToList(records, UserVO.class);</span><br><span class="line">    <span class="comment">// 5.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;UserVO&gt;(page.getTotal(), page.getPages(), list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目，在页面查看：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230839447.png" alt="image-20240502230839447"></p><h3 id="4-2-3-改造PageQuery实体"><a href="#4-2-3-改造PageQuery实体" class="headerlink" title="4.2.3.改造PageQuery实体"></a><strong>4.2.3.改造PageQuery实体</strong></h3><p>在刚才的代码中，从<code>PageQuery</code>到<code>MybatisPlus</code>的<code>Page</code>之间转换的过程还是比较麻烦的。</p><p>我们完全可以在<code>PageQuery</code>这个实体中定义一个工具方法，简化开发。 像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.metadata.OrderItem;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer pageNo;</span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt;  Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(OrderItem ... orders)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.分页条件</span></span><br><span class="line">        Page&lt;T&gt; p = Page.of(pageNo, pageSize);</span><br><span class="line">        <span class="comment">// 2.排序条件</span></span><br><span class="line">        <span class="comment">// 2.1.先看前端有没有传排序字段</span></span><br><span class="line">        <span class="keyword">if</span> (sortBy != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(sortBy, isAsc));</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.再看有没有手动指定排序字段</span></span><br><span class="line">        <span class="keyword">if</span>(orders != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.addOrder(orders);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(String defaultSortBy, <span class="type">boolean</span> isAsc)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toMpPage(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(defaultSortBy, isAsc));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPageDefaultSortByCreateTimeDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toMpPage(<span class="string">&quot;create_time&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPageDefaultSortByUpdateTimeDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toMpPage(<span class="string">&quot;update_time&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在开发也时就可以省去对从<code>PageQuery</code>到<code>Page</code>的的转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构建条件</span></span><br><span class="line">Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br></pre></td></tr></table></figure><h3 id="4-2-4-改造PageDTO实体"><a href="#4-2-4-改造PageDTO实体" class="headerlink" title="4.2.4.改造PageDTO实体"></a><strong>4.2.4.改造PageDTO实体</strong></h3><p>在查询出分页结果后，数据的非空校验，数据的vo转换都是模板代码，编写起来很麻烦。</p><p>我们完全可以将其封装到PageDTO的工具方法中，简化整个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="keyword">private</span> List&lt;V&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回空分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">empty</span><span class="params">(Page&lt;P&gt; p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voClass 目标VO类型的字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Class&lt;V&gt; voClass)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> convertor PO到VO的转换函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，业务层的代码可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> PageDTO.of(page, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是希望自定义PO到VO的转换过程，可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUserByPage</span><span class="params">(PageQuery query)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件</span></span><br><span class="line">    Page&lt;User&gt; page = query.toMpPageDefaultSortByCreateTimeDesc();</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    page(page);</span><br><span class="line">    <span class="comment">// 3.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> PageDTO.of(page, user -&gt; &#123;</span><br><span class="line">        <span class="comment">// 拷贝属性到VO</span></span><br><span class="line">        <span class="type">UserVO</span> <span class="variable">vo</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserVO.class);</span><br><span class="line">        <span class="comment">// 用户名脱敏</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> vo.getUsername();</span><br><span class="line">        vo.setUsername(username.substring(<span class="number">0</span>, username.length() - <span class="number">2</span>) + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> vo;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终查询的结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20240502230906331.png" alt="image-20240502230906331"></p><h1 id="5-作业"><a href="#5-作业" class="headerlink" title="5.作业"></a><strong>5.作业</strong></h1><p>尝试改造项目一中的<code>Service</code>层和<code>Mapper</code>层实现，用<code>MybatisPlus</code>代替单表的CRUD</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家在日常开发中应该能发现，单表的CRUD功能代码重复度很高，也没有什么难度。而这部分代码量往往比较大，开发起来比较费时。&lt;/p&gt;
&lt;p&gt;因此，目前企业中都会使用一些组件来简化或省略单表的CRUD开发工作。目前在国内使用较多的一个组件就是MybatisPlus.&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/"/>
    
    <category term="MyBatis" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/MyBatis/"/>
    
    
    <category term="MyBatis-Plus" scheme="https://www.shallowrecall.top/tags/MyBatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="https://www.shallowrecall.top/posts/b543ced0.html"/>
    <id>https://www.shallowrecall.top/posts/b543ced0.html</id>
    <published>2024-04-26T15:57:05.000Z</published>
    <updated>2024-12-01T10:54:07.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：</p><p>同步通讯：就像打电话，需要实时响应。</p><p>异步通讯：就像发邮件，不需要马上回复。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717161939695.png" alt="image-20210717161939695"></p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p>我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717162004285.png" alt="image-20210717162004285"></p><p>总结：</p><p>同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210422095356088.png" alt="image-20210422095356088"></p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>好处：</p><ul><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li>调用间没有阻塞，不会造成无效的资源占用</li><li>耦合度极低，每个服务都可以灵活插拔，可替换</li><li>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p><h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><div class="table-container"><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table></div><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-安装RabbitMQ"><a href="#2-1-安装RabbitMQ" class="headerlink" title="2.1.安装RabbitMQ"></a>2.1.安装RabbitMQ</h2><p>安装RabbitMQ，参考课前资料：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717162628635.png" alt="image-20210717162628635"></p><p>MQ的基本结构：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717162752376.png" alt="image-20210717162752376"></p><p>RabbitMQ中的一些角色：</p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange个：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717163332646.png" alt="image-20210717163332646"></p><h2 id="2-3-导入Demo工程"><a href="#2-3-导入Demo工程" class="headerlink" title="2.3.导入Demo工程"></a>2.3.导入Demo工程</h2><p>课前资料提供了一个Demo工程，mq-demo:</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717163253264.png" alt="image-20210717163253264"></p><p>导入后可以看到结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717163604330.png" alt="image-20210717163604330"></p><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>简单队列模式的模型图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717163434647.png" alt="image-20210717163434647"></p><p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p><ul><li>publisher：消息发布者，将消息发送到队列queue</li><li>queue：消息队列，负责接受并缓存消息</li><li>consumer：订阅队列，处理队列中的消息</li></ul><h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>发送消息</li><li>关闭连接和channel</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>利用channel向队列发送消息</p></li></ol><p>基本消息队列的消息接收流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>定义consumer的消费行为handleDelivery()</p></li><li><p>利用channel将消费者与队列绑定</p></li></ol><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717164024967.png" alt="image-20210717164024967"></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717164038678.png" alt="image-20210717164038678"></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717164238910.png" alt="image-20210717164238910"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个消费者sleep了1000秒，模拟任务耗时。</p><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p><h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="3-3-发布-订阅"><a href="#3-3-发布-订阅" class="headerlink" title="3.3.发布/订阅"></a>3.3.发布/订阅</h2><p>发布订阅的模型如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717165309625.png" alt="image-20210717165309625"></p><p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717165438225.png" alt="image-20210717165438225"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 itcast.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717165509466.png" alt="image-20210717165509466"></p><h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717165552676.png" alt="image-20210717165552676"></p><p>在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;itcast.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange</li><li>Binding</li></ul><h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5.Direct"></a>3.5.Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717170041447.png" alt="image-20210717170041447"></p><p>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如下</strong>：</p><ol><li><p>利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. direct发送消息</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717170223317.png" alt="image-20210717170223317"></p><h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@Queue</li><li>@Exchange</li></ul><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p>通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><p>​</p><p>图示：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717170705380.png" alt="image-20210717170705380"></p><p>解释：</p><ul><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li></ul><p>案例需求：</p><p>实现思路如下：</p><ol><li><p>并利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. topic发送消息</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210717170829229.png" alt="image-20210717170829229"></p><h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * topicExchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendTopicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;itcast.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20200525170410401.png" alt="image-20200525170410401"></p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="3-7-1-测试默认转换器"><a href="#3-7-1-测试默认转换器" class="headerlink" title="3.7.1.测试默认转换器"></a>3.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>,<span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停止consumer服务</p><p>发送消息后查看控制台：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210422232835363.png" alt="image-20210422232835363"></p><h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置消息转换器。</p><p>在启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h1&gt;&lt;h1 id=&quot;1-初识MQ&quot;&gt;&lt;a href=&quot;#1-初识MQ&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/"/>
    
    <category term="SpringCloud" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/"/>
    
    <category term="RabbitMQ" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/RabbitMQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://www.shallowrecall.top/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ部署指南</title>
    <link href="https://www.shallowrecall.top/posts/ddc45bf.html"/>
    <id>https://www.shallowrecall.top/posts/ddc45bf.html</id>
    <published>2024-04-26T15:53:16.000Z</published>
    <updated>2024-12-01T10:54:07.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ部署指南"><a href="#RabbitMQ部署指南" class="headerlink" title="RabbitMQ部署指南"></a>RabbitMQ部署指南</h1><h1 id="1-单机部署"><a href="#1-单机部署" class="headerlink" title="1.单机部署"></a>1.单机部署</h1><p>我们在Centos7虚拟机中使用Docker来安装。</p><h2 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1.下载镜像"></a>1.1.下载镜像</h2><p>方式一：在线拉取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure><p>方式二：从本地加载</p><p>在课前资料已经提供了镜像包：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210423191210349.png" alt="image-20210423191210349"></p><p>上传到虚拟机中后，使用命令加载镜像即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mq.tar</span><br></pre></td></tr></table></figure><h2 id="1-2-安装MQ"><a href="#1-2-安装MQ" class="headerlink" title="1.2.安装MQ"></a>1.2.安装MQ</h2><p>执行下面的命令来运行MQ容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq1 \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3-management</span><br></pre></td></tr></table></figure><h1 id="2-集群部署"><a href="#2-集群部署" class="headerlink" title="2.集群部署"></a>2.集群部署</h1><p>接下来，我们看看如何安装RabbitMQ的集群。</p><h2 id="2-1-集群分类"><a href="#2-1-集群分类" class="headerlink" title="2.1.集群分类"></a>2.1.集群分类</h2><p>在RabbitMQ的官方文档中，讲述了两种集群的配置方式：</p><ul><li>普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。</li><li>镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。</li></ul><p>我们先来看普通模式集群。</p><h2 id="2-2-设置网络"><a href="#2-2-设置网络" class="headerlink" title="2.2.设置网络"></a>2.2.设置网络</h2><p>首先，我们需要让3台MQ互相知道对方的存在。</p><p>分别在3台机器中，设置 /etc/hosts文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.150.101 mq1</span><br><span class="line">192.168.150.102 mq2</span><br><span class="line">192.168.150.103 mq3</span><br></pre></td></tr></table></figure><p>并在每台机器上测试，是否可以ping通对方：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RabbitMQ部署指南&quot;&gt;&lt;a href=&quot;#RabbitMQ部署指南&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ部署指南&quot;&gt;&lt;/a&gt;RabbitMQ部署指南&lt;/h1&gt;&lt;h1 id=&quot;1-单机部署&quot;&gt;&lt;a href=&quot;#1-单机部署&quot;</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/"/>
    
    <category term="SpringCloud" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/"/>
    
    <category term="RabbitMQ" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/RabbitMQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://www.shallowrecall.top/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Docker实用篇</title>
    <link href="https://www.shallowrecall.top/posts/55bce094.html"/>
    <id>https://www.shallowrecall.top/posts/55bce094.html</id>
    <published>2024-04-24T04:40:39.000Z</published>
    <updated>2024-12-01T10:47:28.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker实用篇"><a href="#Docker实用篇" class="headerlink" title="Docker实用篇"></a>Docker实用篇</h1><h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li></ul><h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li><p>依赖关系复杂，容易出现兼容性问题</p></li><li><p>开发、测试、生产环境有差异</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731141907366.png" alt="image-20210731141907366"></p><p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p><h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p><p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p><ul><li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731142219735.png" alt="image-20210731142219735"></p><p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p><p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p><h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731143401460.png" alt="image-20210731143401460"></p><p>结构包括：</p><ul><li>计算机硬件：例如CPU、内存、磁盘等</li><li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li><li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li></ul><p>应用于计算机交互的流程如下：</p><p>1）应用调用操作系统应用（函数库），实现各种功能</p><p>2）系统函数库是对内核指令集的封装，会调用内核指令</p><p>3）内核指令操作计算机硬件</p><p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731144304990.png" alt="image-20210731144304990"></p><p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731144458680.png" alt="image-20210731144458680"></p><p>Docker如何解决不同系统环境的问题？</p><ul><li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li><li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li></ul><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731144820638.png" alt="image-20210731144820638"></p><h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p><p>两者有什么差异呢？</p><p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p><p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731145914960.png" alt="image-20210731145914960"></p><p>对比来看：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731152243765.png" alt="image-20210731152243765"></p><p>小结：</p><p>Docker和虚拟机的差异：</p><ul><li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p></li><li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p><p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p><p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p><p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731153059464.png" alt="image-20210731153059464"></p><p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p><h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p><ul><li><p>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</p></li><li><p>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</p></li></ul><p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731153743354.png" alt="image-20210731153743354"></p><h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p><p>Docker是一个CS架构的程序，由两部分组成：</p><ul><li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p></li><li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p></li></ul><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731154257653.png" alt="image-20210731154257653"></p><h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p><ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul><p>容器：</p><ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul><p>Docker结构：</p><ul><li><p>服务端：接收命令或远程请求，操作镜像或容器</p></li><li><p>客户端：发送命令或者请求到Docker服务端</p></li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li></ul><h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。参考课前资料中的文档：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731155002425.png" alt="image-20210731155002425"></p><h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731155141362.png" alt="image-20210731155141362"></p><p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p><h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731155649535.png" alt="image-20210731155649535"></p><h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p><p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731155844368.png" alt="image-20210731155844368"></p><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731155856199.png" alt="image-20210731155856199"></p><p>3）通过命令：docker images 查看拉取到的镜像</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731155903037.png" alt="image-20210731155903037"></p><h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>1）利用docker xx —help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731161104732.png" alt="image-20210731161104732"></p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></table></figure><p>2）使用docker save导出镜像到磁盘</p><p>运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731161354344.png" alt="image-20210731161354344"></p><p>3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure><p>然后运行命令，加载本地文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731161746245.png" alt="image-20210731161746245"></p><h3 id="2-1-5-练习"><a href="#2-1-5-练习" class="headerlink" title="2.1.5.练习"></a>2.1.5.练习</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p><p>目标：</p><p>1）去DockerHub搜索Redis镜像</p><p>2）查看Redis镜像的名称和版本</p><p>3）利用docker pull命令拉取镜像</p><p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p><p>5）利用docker rmi 删除本地的redis:latest</p><p>6）利用docker load 重新加载 redis.tar文件</p><h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731161950495.png" alt="image-20210731161950495"></p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>其中：</p><ul><li>docker run：创建并运行一个容器，处于运行状态</li><li>docker pause：让一个运行的容器暂停</li><li>docker unpause：让一个容器从暂停状态恢复运行</li><li>docker stop：停止一个运行的容器</li><li><p>docker start：让一个停止的容器再次运行</p></li><li><p>docker rm：删除一个容器</p></li></ul><h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>—name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731163255863.png" alt="image-20210731163255863"></p><h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p></li></ul><p>2）进入nginx的HTML所在目录 /usr/share/nginx/html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731164159811.png" alt="image-20210731164159811"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure><p>查看目录下文件：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731164455818.png" alt="image-20210731164455818"></p><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27;</span> -e <span class="string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure><p>在浏览器访问自己的虚拟机地址，例如我的是：<a href="http://192.168.150.101，即可看到结果：">http://192.168.150.101，即可看到结果：</a></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731164717604.png" alt="image-20210731164717604"></p><h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p><ul><li>—name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731172440275.png" alt="image-20210731172440275"></p><p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p><h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731173541846.png" alt="image-20210731173541846"></p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了</p><h3 id="2-3-2-数据集操作命令"><a href="#2-3-2-数据集操作命令" class="headerlink" title="2.3.2.数据集操作命令"></a>2.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>① 创建数据卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create html</span><br></pre></td></tr></table></figure><p>② 查看所有数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731173746910.png" alt="image-20210731173746910"></p><p>③ 查看数据卷详细信息卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731173809877.png" alt="image-20210731173809877"></p><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><p><strong>小结</strong>：</p><p>数据卷的作用：</p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p>数据卷操作：</p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul><h3 id="2-3-4-挂载数据卷"><a href="#2-3-4-挂载数据卷" class="headerlink" title="2.3.4.挂载数据卷"></a>2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \</span><br><span class="line">  -p 8080:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li></ul><h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>① 创建容器并挂载数据卷到容器内的HTML目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>② 进入html数据卷所在位置，并修改HTML内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看html数据卷的位置</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure><h3 id="2-3-6-案例-给MySQL挂载本地目录"><a href="#2-3-6-案例-给MySQL挂载本地目录" class="headerlink" title="2.3.6.案例-给MySQL挂载本地目录"></a>2.3.6.案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 —&gt; 数据卷 —-&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 —-&gt; 容器内目录</li></ul><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731175155453.png" alt="image-20210731175155453"></p><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p><p>2）创建目录/tmp/mysql/data</p><p>3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf</p><p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><p>① 挂载/tmp/mysql/data到mysql容器内数据存储目录</p><p>② 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件</p><p>③ 设置MySQL密码</p><h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul><h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>我们以MySQL为例，来看看镜像的组成结构：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731175806273.png" alt="image-20210731175806273"></p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><p>而描述上述信息的文件就是Dockerfile文件。</p><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的<strong>指令(Instruction)</strong>，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731180321133.png" alt="image-20210731180321133"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="3-3-构建Java项目"><a href="#3-3-构建Java项目" class="headerlink" title="3.3.构建Java项目"></a>3.3.构建Java项目</h2><h3 id="3-3-1-基于Ubuntu构建Java项目"><a href="#3-3-1-基于Ubuntu构建Java项目" class="headerlink" title="3.3.1.基于Ubuntu构建Java项目"></a>3.3.1.基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p>步骤1：新建一个空文件夹docker-demo</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210801101207444.png" alt="image-20210801101207444"></p></li><li><p>步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210801101314816.png" alt="image-20210801101314816"></p></li><li><p>步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210801101410200.png" alt="image-20210801101410200"></p></li><li><p>步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210801101455590.png" alt="image-20210801101455590"></p><p>其中的内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure></li></ul><p>最后访问 <a href="http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p><h3 id="3-3-2-基于java8构建Java项目"><a href="#3-3-2-基于java8构建Java项目" class="headerlink" title="3.3.2.基于java8构建Java项目"></a>3.3.2.基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><ul><li><p>a ）基于java:8-alpine作为基础镜像</p></li><li><p>b ）将app.jar拷贝到镜像中</p></li><li><p>c ）暴露端口</p></li><li><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>④ 使用docker build命令构建镜像</p></li><li><p>⑤ 使用docker run创建容器并运行</p></li></ul><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>小结：</p><ol><li><p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p></li><li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p></li><li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p></li></ol><h1 id="4-Docker-Compose"><a href="#4-Docker-Compose" class="headerlink" title="4.Docker-Compose"></a>4.Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731180921742.png" alt="image-20210731180921742"></p><h2 id="4-1-初识DockerCompose"><a href="#4-1-初识DockerCompose" class="headerlink" title="4.1.初识DockerCompose"></a>4.1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version<span class="punctuation">:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"> services<span class="punctuation">:</span></span><br><span class="line">  mysql<span class="punctuation">:</span></span><br><span class="line">    image<span class="punctuation">:</span> mysql<span class="punctuation">:</span><span class="number">5.7</span><span class="number">.25</span></span><br><span class="line">    environment<span class="punctuation">:</span></span><br><span class="line">     MYSQL_ROOT_PASSWORD<span class="punctuation">:</span> <span class="number">123</span> </span><br><span class="line">    volumes<span class="punctuation">:</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span></span><br><span class="line">  web<span class="punctuation">:</span></span><br><span class="line">    build<span class="punctuation">:</span> .</span><br><span class="line">    ports<span class="punctuation">:</span></span><br><span class="line">     - <span class="string">&quot;8090:8090&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p><h2 id="4-2-安装DockerCompose"><a href="#4-2-安装DockerCompose" class="headerlink" title="4.2.安装DockerCompose"></a>4.2.安装DockerCompose</h2><p>参考课前资料</p><h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h3 id="4-3-1-compose文件"><a href="#4-3-1-compose文件" class="headerlink" title="4.3.1.compose文件"></a>4.3.1.compose文件</h3><p>查看课前资料提供的cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210731181341330.png" alt="image-20210731181341330"></p><p>内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MODE:</span> <span class="string">standalone</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.25</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span></span><br><span class="line">  <span class="attr">userservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./user-service</span></span><br><span class="line">  <span class="attr">orderservice:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./order-service</span></span><br><span class="line">  <span class="attr">gateway:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./gateway</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10010:10010&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，其中包含5个service服务：</p><ul><li><code>nacos</code>：作为注册中心和配置中心<ul><li><code>image: nacos/nacos-server</code>： 基于nacos/nacos-server镜像构建</li><li><code>environment</code>：环境变量<ul><li><code>MODE: standalone</code>：单点模式启动</li></ul></li><li><code>ports</code>：端口映射，这里暴露了8848端口</li></ul></li><li><code>mysql</code>：数据库<ul><li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li><li><code>environment</code>：环境变量<ul><li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li></ul></li><li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li></ul></li><li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li></ul><p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210801095205034.png" alt="image-20210801095205034"></p><p>查看微服务目录，可以看到都包含Dockerfile文件：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210801095320586.png" alt="image-20210801095320586"></p><p>内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure><h3 id="4-3-2-修改微服务配置"><a href="#4-3-2-修改微服务配置" class="headerlink" title="4.3.2.修改微服务配置"></a>4.3.2.修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p><p>如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">nacos:8848</span> <span class="comment"># nacos服务地址</span></span><br></pre></td></tr></table></figure><h3 id="4-3-3-打包"><a href="#4-3-3-打包" class="headerlink" title="4.3.3.打包"></a>4.3.3.打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p><p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 服务打包的最终名称 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打包后：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210801095951030.png" alt="image-20210801095951030"></p><h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p><p>user-service：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210801100201253.png" alt="image-20210801100201253"></p><p>order-service：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210801100231495.png" alt="image-20210801100231495"></p><p>gateway：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210801100308102.png" alt="image-20210801100308102"></p><h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p><p>上传到任意目录：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210801100955653.png" alt="image-20210801100955653"></p><p>部署：</p><p>进入cloud-demo目录，然后运行下面的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><h2 id="5-1-搭建私有镜像仓库"><a href="#5-1-搭建私有镜像仓库" class="headerlink" title="5.1.搭建私有镜像仓库"></a>5.1.搭建私有镜像仓库</h2><p>参考课前资料《CentOS7安装Docker.md》</p><h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker实用篇&quot;&gt;&lt;a href=&quot;#Docker实用篇&quot; class=&quot;headerlink&quot; title=&quot;Docker实用篇&quot;&gt;&lt;/a&gt;Docker实用篇&lt;/h1&gt;&lt;h1 id=&quot;1-初识Docker&quot;&gt;&lt;a href=&quot;#1-初识Docker&quot; cla</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/"/>
    
    <category term="SpringCloud" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/"/>
    
    <category term="Docker" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/Docker/"/>
    
    
    <category term="Docker" scheme="https://www.shallowrecall.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Centos7安装Docker</title>
    <link href="https://www.shallowrecall.top/posts/a6573b44.html"/>
    <id>https://www.shallowrecall.top/posts/a6573b44.html</id>
    <published>2024-04-24T04:39:48.000Z</published>
    <updated>2024-12-01T10:47:28.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-安装Docker"><a href="#0-安装Docker" class="headerlink" title="0.安装Docker"></a>0.安装Docker</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h1 id="1-CentOS安装Docker"><a href="#1-CentOS安装Docker" class="headerlink" title="1.CentOS安装Docker"></a>1.CentOS安装Docker</h1><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h2 id="1-1-卸载（可选）"><a href="#1-1-卸载（可选）" class="headerlink" title="1.1.卸载（可选）"></a>1.1.卸载（可选）</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure><h2 id="1-2-安装docker"><a href="#1-2-安装docker" class="headerlink" title="1.2.安装docker"></a>1.2.安装docker</h2><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h2 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3.启动docker"></a>1.3.启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>通过命令启动docker：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure><p>然后输入命令，可以查看docker版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210418154704436.png" alt="image-20210418154704436"></p><h2 id="1-4-配置镜像加速"><a href="#1-4-配置镜像加速" class="headerlink" title="1.4.配置镜像加速"></a>1.4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><h1 id="2-CentOS7安装DockerCompose"><a href="#2-CentOS7安装DockerCompose" class="headerlink" title="2.CentOS7安装DockerCompose"></a>2.CentOS7安装DockerCompose</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1.下载"></a>2.1.下载</h2><p>Linux下需要通过命令下载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210417133020614.png" alt="image-20210417133020614"></p><p>上传到<code>/usr/local/bin/</code>目录也可以。</p><h2 id="2-2-修改文件权限"><a href="#2-2-修改文件权限" class="headerlink" title="2.2.修改文件权限"></a>2.2.修改文件权限</h2><p>修改文件权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="2-3-Base自动补全命令："><a href="#2-3-Base自动补全命令：" class="headerlink" title="2.3.Base自动补全命令："></a>2.3.Base自动补全命令：</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补全命令</span></span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h1 id="3-Docker镜像仓库"><a href="#3-Docker镜像仓库" class="headerlink" title="3.Docker镜像仓库"></a>3.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p><h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1.简化版镜像仓库"></a>3.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://YourIp:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="3-2-带有图形化界面版本"><a href="#3-2-带有图形化界面版本" class="headerlink" title="3.2.带有图形化界面版本"></a>3.2.带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-data:/var/lib/registry</span></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">joxit/docker-registry-ui:static</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_TITLE=传智教育私有仓库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_URL=http://registry:5000</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry</span></span><br></pre></td></tr></table></figure><h2 id="3-3-配置Docker信任地址"><a href="#3-3-配置Docker信任地址" class="headerlink" title="3.3.配置Docker信任地址"></a>3.3.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://192.168.150.101:8080&quot;</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-安装Docker&quot;&gt;&lt;a href=&quot;#0-安装Docker&quot; class=&quot;headerlink&quot; title=&quot;0.安装Docker&quot;&gt;&lt;/a&gt;0.安装Docker&lt;/h1&gt;&lt;p&gt;Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/"/>
    
    <category term="SpringCloud" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/"/>
    
    <category term="Docker" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/Docker/"/>
    
    
    <category term="docker" scheme="https://www.shallowrecall.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Nacos集群搭建</title>
    <link href="https://www.shallowrecall.top/posts/bf8bcde.html"/>
    <id>https://www.shallowrecall.top/posts/bf8bcde.html</id>
    <published>2024-04-22T04:57:42.000Z</published>
    <updated>2024-12-01T10:47:28.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos集群搭建"><a href="#Nacos集群搭建" class="headerlink" title="Nacos集群搭建"></a>Nacos集群搭建</h1><h1 id="1-集群结构图"><a href="#1-集群结构图" class="headerlink" title="1.集群结构图"></a>1.集群结构图</h1><p>官方给出的Nacos集群图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210409210621117.png" alt="image-20210409210621117"></p><p>其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。</p><p>我们计划的集群结构：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210409211355037.png" alt="image-20210409211355037"></p><p>三个nacos节点的地址：</p><div class="table-container"><table><thead><tr><th>节点</th><th>ip</th><th>port</th></tr></thead><tbody><tr><td>nacos1</td><td>192.168.150.1</td><td>8845</td></tr><tr><td>nacos2</td><td>192.168.150.1</td><td>8846</td></tr><tr><td>nacos3</td><td>192.168.150.1</td><td>8847</td></tr></tbody></table></div><h1 id="2-搭建集群"><a href="#2-搭建集群" class="headerlink" title="2.搭建集群"></a>2.搭建集群</h1><p>搭建集群的基本步骤：</p><ul><li>搭建数据库，初始化数据库表结构</li><li>下载nacos安装包</li><li>配置nacos</li><li>启动nacos集群</li><li>nginx反向代理</li></ul><h2 id="2-1-初始化数据库"><a href="#2-1-初始化数据库" class="headerlink" title="2.1.初始化数据库"></a>2.1.初始化数据库</h2><p>Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。</p><p>官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库可以参考<strong>传智教育</strong>的后续高手课程。</p><p>这里我们以单点的数据库为例来讲解。</p><p>首先新建一个数据库，命名为nacos，而后导入下面的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_schema` text,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_aggr   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;datum_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;增加租户字段&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_beta   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;betaIps&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_beta&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_tag   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_tag&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_tags_relation   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_name&#x27;</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_type&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_tag_relation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = group_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;集群、各Group容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = his_config_info   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">64</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `src_user` text,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;多租户改造&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = tenant_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Tenant ID&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;租户容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;kp&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_name&#x27;</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant_desc&#x27;</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create_source&#x27;</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;tenant_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">`password` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`enabled` <span class="type">boolean</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `roles` (</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> INDEX `idx_user_role` (`username` <span class="keyword">ASC</span>, `role` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `permissions` (</span><br><span class="line">    `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `resource` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `action` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX `uk_role_permission` (`role`,`resource`,`action`) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, password, enabled) <span class="keyword">VALUES</span> (<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="literal">TRUE</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> roles (username, role) <span class="keyword">VALUES</span> (<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;ROLE_ADMIN&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="2-2-下载nacos"><a href="#2-2-下载nacos" class="headerlink" title="2.2.下载nacos"></a>2.2.下载nacos</h2><p>nacos在GitHub上有下载地址：<a href="https://github.com/alibaba/nacos/tags，可以选择任意版本下载。">https://github.com/alibaba/nacos/tags，可以选择任意版本下载。</a></p><p>本例中才用1.4.1版本：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210409212119411.png" alt="image-20210409212119411"></p><h2 id="2-3-配置Nacos"><a href="#2-3-配置Nacos" class="headerlink" title="2.3.配置Nacos"></a>2.3.配置Nacos</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210409212459292.png" alt="image-20210409212459292"></p><p>然后添加内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:8845</span><br><span class="line">127.0.0.1.8846</span><br><span class="line">127.0.0.1.8847</span><br></pre></td></tr></table></figure><p>然后修改application.properties文件，添加数据库配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">db.user.0</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">db.password.0</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><h2 id="2-4-启动"><a href="#2-4-启动" class="headerlink" title="2.4.启动"></a>2.4.启动</h2><p>将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210409213335538.png" alt="image-20210409213335538"></p><p>然后分别修改三个文件夹中的application.properties，</p><p>nacos1:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8845</span></span><br></pre></td></tr></table></figure><p>nacos2:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8846</span></span><br></pre></td></tr></table></figure><p>nacos3:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8847</span></span><br></pre></td></tr></table></figure><p>然后分别启动三个nacos节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd</span><br></pre></td></tr></table></figure><h2 id="2-5-nginx反向代理"><a href="#2-5-nginx反向代理" class="headerlink" title="2.5.nginx反向代理"></a>2.5.nginx反向代理</h2><p>找到课前资料提供的nginx安装包：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210410103253355.png" alt="image-20210410103253355"></p><p>解压到任意非中文目录下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210410103322874.png" alt="image-20210410103322874"></p><p>修改conf/nginx.conf文件，配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> nacos-cluster &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8845</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">127.0.0.1:8846</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">127.0.0.1:8847</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /nacos &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://nacos-cluster;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后在浏览器访问：<a href="http://localhost/nacos即可。">http://localhost/nacos即可。</a></p><p>代码中application.yml文件配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:80</span> <span class="comment"># Nacos地址</span></span><br></pre></td></tr></table></figure><h2 id="2-6-优化"><a href="#2-6-优化" class="headerlink" title="2.6.优化"></a>2.6.优化</h2><ul><li><p>实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置.</p></li><li><p>Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nacos集群搭建&quot;&gt;&lt;a href=&quot;#Nacos集群搭建&quot; class=&quot;headerlink&quot; title=&quot;Nacos集群搭建&quot;&gt;&lt;/a&gt;Nacos集群搭建&lt;/h1&gt;&lt;h1 id=&quot;1-集群结构图&quot;&gt;&lt;a href=&quot;#1-集群结构图&quot; class=&quot;he</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/"/>
    
    <category term="SpringCloud" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/"/>
    
    <category term="Nacos" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/Nacos/"/>
    
    
    <category term="Nacos" scheme="https://www.shallowrecall.top/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>Nacos安装指南</title>
    <link href="https://www.shallowrecall.top/posts/51556c56.html"/>
    <id>https://www.shallowrecall.top/posts/51556c56.html</id>
    <published>2024-04-22T04:54:40.000Z</published>
    <updated>2024-12-01T10:47:28.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><h1 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h1><p>开发阶段采用单机安装即可。</p><h2 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h2><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402161102887.png" alt="image-20210402161102887"></p><p>本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402161130261.png" alt="image-20210402161130261"></p><p>windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402162008280.png" alt="image-20210402162008280"></p><p>修改其中的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402162251093.png" alt="image-20210402162251093"></p><h2 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402162350977.png" alt="image-20210402162350977"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure></li></ul><p>执行后的效果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402162526774.png" alt="image-20210402162526774"></p><h2 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos即可：">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402162630427.png" alt="image-20210402162630427"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402162709515.png" alt="image-20210402162709515"></p><h1 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h1><p>Linux或者Mac安装方式与Windows类似。</p><h2 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h2><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402172334810.png" alt="image-20210402172334810"></p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf jdk-8u144-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>然后重命名为java</p><p>配置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/java</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h2><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402161102887.png" alt="image-20210402161102887"></p><p>也可以直接使用课前资料中的tar.gz：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402161130261.png" alt="image-20210402161130261"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402163715580.png" alt="image-20210402163715580"></p><h2 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h2><p>命令解压缩安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>然后删除安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>目录中最终样式：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402163858429.png" alt="image-20210402163858429"></p><p>目录内部：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210402164414827.png" alt="image-20210402164414827"></p><h2 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h2><p>与windows中类似</p><h2 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h2><p>在nacos/bin目录中，输入命令启动Nacos：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><h1 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h1><p>父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nacos安装指南&quot;&gt;&lt;a href=&quot;#Nacos安装指南&quot; class=&quot;headerlink&quot; title=&quot;Nacos安装指南&quot;&gt;&lt;/a&gt;Nacos安装指南&lt;/h1&gt;&lt;h1 id=&quot;1-Windows安装&quot;&gt;&lt;a href=&quot;#1-Windows安装&quot; c</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/"/>
    
    <category term="SpringCloud" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/"/>
    
    <category term="Nacos" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/Nacos/"/>
    
    
    <category term="Nacos" scheme="https://www.shallowrecall.top/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud02</title>
    <link href="https://www.shallowrecall.top/posts/4f54bfad.html"/>
    <id>https://www.shallowrecall.top/posts/4f54bfad.html</id>
    <published>2024-04-22T04:40:07.000Z</published>
    <updated>2024-12-01T10:47:28.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud02"><a href="#SpringCloud02" class="headerlink" title="SpringCloud02"></a>SpringCloud02</h1><h1 id="1-Nacos配置管理"><a href="#1-Nacos配置管理" class="headerlink" title="1.Nacos配置管理"></a>1.Nacos配置管理</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><h2 id="1-1-统一配置管理"><a href="#1-1-统一配置管理" class="headerlink" title="1.1.统一配置管理"></a>1.1.统一配置管理</h2><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714164426792.png" alt="image-20210714164426792"></p><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p><h3 id="1-1-1-在nacos中添加配置文件"><a href="#1-1-1-在nacos中添加配置文件" class="headerlink" title="1.1.1.在nacos中添加配置文件"></a>1.1.1.在nacos中添加配置文件</h3><p>如何在nacos中管理配置呢？</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714164742924.png" alt="image-20210714164742924"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714164856664.png" alt="image-20210714164856664"></p><blockquote><p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h3 id="1-1-2-从微服务拉取配置"><a href="#1-1-2-从微服务拉取配置" class="headerlink" title="1.1.2.从微服务拉取配置"></a>1.1.2.从微服务拉取配置</h3><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/L0iFYNF.png" alt="img"></p><p>1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714170845901.png" alt="image-20210714170845901"></p><p>3）读取nacos配置</p><p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714170337448.png" alt="image-20210714170337448"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在页面访问，可以看到效果：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714170449612.png" alt="image-20210714170449612"></p><h2 id="1-2-配置热更新"><a href="#1-2-配置热更新" class="headerlink" title="1.2.配置热更新"></a>1.2.配置热更新</h2><p>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>要实现配置热更新，可以使用两种方式：</p><h3 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h3><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714171036335.png" alt="image-20210714171036335"></p><h3 id="1-2-2-方式二"><a href="#1-2-2-方式二" class="headerlink" title="1.2.2.方式二"></a>1.2.2.方式二</h3><p>使用@ConfigurationProperties注解代替@Value注解。</p><p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UserController中使用这个类代替@Value：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714171316124.png" alt="image-20210714171316124"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.config.PatternProperties;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PatternProperties patternProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-配置共享"><a href="#1-3-配置共享" class="headerlink" title="1.3.配置共享"></a>1.3.配置共享</h2><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><p>下面我们通过案例来测试配置共享</p><h3 id="1）添加一个环境共享配置"><a href="#1）添加一个环境共享配置" class="headerlink" title="1）添加一个环境共享配置"></a>1）添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714173233650.png" alt="image-20210714173233650"></p><h3 id="2）在user-service中读取共享配置"><a href="#2）在user-service中读取共享配置" class="headerlink" title="2）在user-service中读取共享配置"></a>2）在user-service中读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714173324231.png" alt="image-20210714173324231"></p><p>在user-service服务中，修改UserController，添加一个方法：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714173721309.png" alt="image-20210714173721309"></p><h3 id="3）运行两个UserApplication，使用不同的profile"><a href="#3）运行两个UserApplication，使用不同的profile" class="headerlink" title="3）运行两个UserApplication，使用不同的profile"></a>3）运行两个UserApplication，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714173538538.png" alt="image-20210714173538538"></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714173519963.png" alt="image-20210714173519963"></p><p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p><p>启动UserApplication和UserApplication2</p><p>访问<a href="http://localhost:8081/user/prop，结果：">http://localhost:8081/user/prop，结果：</a></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714174313344.png" alt="image-20210714174313344"></p><p>访问<a href="http://localhost:8082/user/prop，结果：">http://localhost:8082/user/prop，结果：</a></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714174424818.png" alt="image-20210714174424818"></p><p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p><h3 id="4）配置共享的优先级"><a href="#4）配置共享的优先级" class="headerlink" title="4）配置共享的优先级"></a>4）配置共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714174623557.png" alt="image-20210714174623557"></p><h2 id="1-4-搭建Nacos集群"><a href="#1-4-搭建Nacos集群" class="headerlink" title="1.4.搭建Nacos集群"></a>1.4.搭建Nacos集群</h2><p>Nacos生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714174728042.png" alt="image-20210714174728042"></p><h1 id="2-Feign远程调用"><a href="#2-Feign远程调用" class="headerlink" title="2.Feign远程调用"></a>2.Feign远程调用</h1><p>先来看我们以前利用RestTemplate发起远程调用的代码：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714174814204.png" alt="image-20210714174814204"></p><p>存在下面的问题：</p><p>•代码可读性差，编程体验不统一</p><p>•参数复杂URL难以维护</p><p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714174918088.png" alt="image-20210714174918088"></p><h2 id="2-1-Feign替代RestTemplate"><a href="#2-1-Feign替代RestTemplate" class="headerlink" title="2.1.Feign替代RestTemplate"></a>2.1.Feign替代RestTemplate</h2><p>Fegin的使用步骤如下：</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>我们在order-service服务的pom文件中引入feign的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）添加注解"><a href="#2）添加注解" class="headerlink" title="2）添加注解"></a>2）添加注解</h3><p>在order-service的启动类添加注解开启Feign的功能：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714175102524.png" alt="image-20210714175102524"></p><h3 id="3）编写Feign的客户端"><a href="#3）编写Feign的客户端" class="headerlink" title="3）编写Feign的客户端"></a>3）编写Feign的客户端</h3><p>在order-service中新建一个接口，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.order.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：/user/{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h3 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h3><p>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714175415087.png" alt="image-20210714175415087"></p><p>是不是看起来优雅多了。</p><h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><p>使用Feign的步骤：</p><p>① 引入依赖</p><p>② 添加@EnableFeignClients注解</p><p>③ 编写FeignClient接口</p><p>④ 使用FeignClient中定义的方法代替RestTemplate</p><h2 id="2-2-自定义配置"><a href="#2-2-自定义配置" class="headerlink" title="2.2.自定义配置"></a>2.2.自定义配置</h2><p>Feign可以支持很多的自定义配置，如下表所示：</p><div class="table-container"><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table></div><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><p>下面以日志为例来演示如何自定义配置。</p><h3 id="2-2-1-配置文件方式"><a href="#2-2-1-配置文件方式" class="headerlink" title="2.2.1.配置文件方式"></a>2.2.1.配置文件方式</h3><p>基于配置文件修改feign的日志级别可以针对单个服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">userservice:</span> <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>也可以针对所有服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><h3 id="2-2-2-Java代码方式"><a href="#2-2-2-Java代码方式" class="headerlink" title="2.2.2.Java代码方式"></a>2.2.2.Java代码方式</h3><p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfiguration</span>  &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC; <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><h2 id="2-3-Feign使用优化"><a href="#2-3-Feign使用优化" class="headerlink" title="2.3.Feign使用优化"></a>2.3.Feign使用优化</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p><p>这里我们用Apache的HttpClient来演示。</p><p>1）引入依赖</p><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置连接池</p><p>在order-service的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure><p>接下来，在FeignClientFactoryBean中的loadBalance方法中打断点：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714185925910.png" alt="image-20210714185925910"></p><p>Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714190041542.png" alt="image-20210714190041542"></p><p>总结，Feign的优化：</p><p>1.日志级别尽量用basic</p><p>2.使用HttpClient或OKHttp代替URLConnection</p><p>①  引入feign-httpClient依赖</p><p>②  配置文件开启httpClient功能，设置连接池参数</p><h2 id="2-4-最佳实践"><a href="#2-4-最佳实践" class="headerlink" title="2.4.最佳实践"></a>2.4.最佳实践</h2><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p><p>自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：</p><p>feign客户端：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714190542730.png" alt="image-20210714190542730"></p><p>UserController：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714190528450.png" alt="image-20210714190528450"></p><p>有没有一种办法简化这种重复的代码编写呢？</p><h3 id="2-4-1-继承方式"><a href="#2-4-1-继承方式" class="headerlink" title="2.4.1.继承方式"></a>2.4.1.继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p><p>2）Feign客户端和Controller都集成改接口</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714190640857.png" alt="image-20210714190640857"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li><p>服务提供方、服务消费方紧耦合</p></li><li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p></li></ul><h3 id="2-4-2-抽取方式"><a href="#2-4-2-抽取方式" class="headerlink" title="2.4.2.抽取方式"></a>2.4.2.抽取方式</h3><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714214041796.png" alt="image-20210714214041796"></p><h3 id="2-4-3-实现基于抽取的最佳实践"><a href="#2-4-3-实现基于抽取的最佳实践" class="headerlink" title="2.4.3.实现基于抽取的最佳实践"></a>2.4.3.实现基于抽取的最佳实践</h3><h4 id="1）抽取"><a href="#1）抽取" class="headerlink" title="1）抽取"></a>1）抽取</h4><p>首先创建一个module，命名为feign-api：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714204557771.png" alt="image-20210714204557771"></p><p>项目结构：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714204656214.png" alt="image-20210714204656214"></p><p>在feign-api中然后引入feign的starter依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714205221970.png" alt="image-20210714205221970"></p><h4 id="2）在order-service中使用feign-api"><a href="#2）在order-service中使用feign-api" class="headerlink" title="2）在order-service中使用feign-api"></a>2）在order-service中使用feign-api</h4><p>首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。</p><p>在order-service的pom文件中中引入feign-api的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p><h4 id="3）重启测试"><a href="#3）重启测试" class="headerlink" title="3）重启测试"></a>3）重启测试</h4><p>重启后，发现服务报错了：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714205623048.png" alt="image-20210714205623048"></p><p>这是因为UserClient现在在cn.itcast.feign.clients包下，</p><p>而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。</p><h4 id="4）解决扫描包问题"><a href="#4）解决扫描包问题" class="headerlink" title="4）解决扫描包问题"></a>4）解决扫描包问题</h4><p>方式一：</p><p>指定Feign应该扫描的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span></span><br></pre></td></tr></table></figure><p>方式二：</p><p>指定需要加载的Client接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure><h1 id="3-Gateway服务网关"><a href="#3-Gateway服务网关" class="headerlink" title="3.Gateway服务网关"></a>3.Gateway服务网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h2 id="3-1-为什么需要网关"><a href="#3-1-为什么需要网关" class="headerlink" title="3.1.为什么需要网关"></a>3.1.为什么需要网关</h2><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714210131152.png" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="3-2-gateway快速入门"><a href="#3-2-gateway快速入门" class="headerlink" title="3.2.gateway快速入门"></a>3.2.gateway快速入门</h2><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h3 id="1）创建gateway服务，引入依赖"><a href="#1）创建gateway服务，引入依赖" class="headerlink" title="1）创建gateway服务，引入依赖"></a>1）创建gateway服务，引入依赖</h3><p>创建服务：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714210919458.png" alt="image-20210714210919458"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）编写启动类"><a href="#2）编写启动类" class="headerlink" title="2）编写启动类"></a>2）编写启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）编写基础配置和路由规则"><a href="#3）编写基础配置和路由规则" class="headerlink" title="3）编写基础配置和路由规则"></a>3）编写基础配置和路由规则</h3><p>创建application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><h3 id="4）重启测试"><a href="#4）重启测试" class="headerlink" title="4）重启测试"></a>4）重启测试</h3><p>重启网关，访问<a href="http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714211908341.png" alt="image-20210714211908341"></p><h3 id="5）网关路由的流程图"><a href="#5）网关路由的流程图" class="headerlink" title="5）网关路由的流程图"></a>5）网关路由的流程图</h3><p>整个访问的流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714211742956.png" alt="image-20210714211742956"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li><p>创建项目，引入nacos服务发现和gateway依赖</p></li><li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><p>接下来，就重点来学习路由断言和路由过滤器的详细知识</p><h2 id="3-3-断言工厂"><a href="#3-3-断言工厂" class="headerlink" title="3.3.断言工厂"></a>3.3.断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path=/user/**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p><p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><div class="table-container"><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=name, Jack或者-  Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td></tr></tbody></table></div><p>我们只需要掌握Path这种路由工程就可以了。</p><h2 id="3-4-过滤器工厂"><a href="#3-4-过滤器工厂" class="headerlink" title="3.4.过滤器工厂"></a>3.4.过滤器工厂</h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714212312871.png" alt="image-20210714212312871"></p><h3 id="3-4-1-路由过滤器的种类"><a href="#3-4-1-路由过滤器的种类" class="headerlink" title="3.4.1.路由过滤器的种类"></a>3.4.1.路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><div class="table-container"><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table></div><h3 id="3-4-2-请求头过滤器"><a href="#3-4-2-请求头过滤器" class="headerlink" title="3.4.2.请求头过滤器"></a>3.4.2.请求头过滤器</h3><p>下面我们以AddRequestHeader 为例来讲解。</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!</p></blockquote><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">        <span class="attr">filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><h3 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> </span><br></pre></td></tr></table></figure><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头</p><p>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？</p><p>① 对所有路由都生效的过滤器</p><h2 id="3-5-全局过滤器"><a href="#3-5-全局过滤器" class="headerlink" title="3.5.全局过滤器"></a>3.5.全局过滤器</h2><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h3 id="3-5-1-全局过滤器作用"><a href="#3-5-1-全局过滤器作用" class="headerlink" title="3.5.1.全局过滤器作用"></a>3.5.1.全局过滤器作用</h3><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理当前请求，有必要的话通过&#123;<span class="doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h3 id="3-5-2-自定义全局过滤器"><a href="#3-5-2-自定义全局过滤器" class="headerlink" title="3.5.2.自定义全局过滤器"></a>3.5.2.自定义全局过滤器</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有authorization，</p></li><li><p>authorization参数值是否为admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求参数</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        <span class="comment">// 2.获取authorization参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.拦截</span></span><br><span class="line">        <span class="comment">// 4.1.禁止访问，设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        <span class="comment">// 4.2.结束处理</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-过滤器执行顺序"><a href="#3-5-3-过滤器执行顺序" class="headerlink" title="3.5.3.过滤器执行顺序"></a>3.5.3.过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714214228409.png" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p><h2 id="3-6-跨域问题"><a href="#3-6-跨域问题" class="headerlink" title="3.6.跨域问题"></a>3.6.跨域问题</h2><h3 id="3-6-1-什么是跨域问题"><a href="#3-6-1-什么是跨域问题" class="headerlink" title="3.6.1.什么是跨域问题"></a>3.6.1.什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com</p></li><li><p>域名相同，端口不同：localhost:8080和localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h3 id="3-6-2-模拟跨域问题"><a href="#3-6-2-模拟跨域问题" class="headerlink" title="3.6.2.模拟跨域问题"></a>3.6.2.模拟跨域问题</h3><p>找到课前资料的页面文件：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714215713563.png" alt="image-20210714215713563"></p><p>放入tomcat或者nginx这样的web服务器中，启动并访问。</p><p>可以在浏览器控制台看到下面的错误：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2024/4/image-20210714215832675.png" alt="image-20210714215832675"></p><p>从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。</p><h3 id="3-6-3-解决跨域问题"><a href="#3-6-3-解决跨域问题" class="headerlink" title="3.6.3.解决跨域问题"></a>3.6.3.解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 。。。</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud02&quot;&gt;&lt;a href=&quot;#SpringCloud02&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud02&quot;&gt;&lt;/a&gt;SpringCloud02&lt;/h1&gt;&lt;h1 id=&quot;1-Nacos配置管理&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/"/>
    
    <category term="SpringCloud" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/"/>
    
    
    <category term="微服务" scheme="https://www.shallowrecall.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud01</title>
    <link href="https://www.shallowrecall.top/posts/d65dee17.html"/>
    <id>https://www.shallowrecall.top/posts/d65dee17.html</id>
    <published>2024-04-22T04:20:06.000Z</published>
    <updated>2024-12-01T10:47:28.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud01"><a href="#SpringCloud01" class="headerlink" title="SpringCloud01"></a>SpringCloud01</h1><h1 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h1><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p><h2 id="1-0-学习目标"><a href="#1-0-学习目标" class="headerlink" title="1.0.学习目标"></a>1.0.学习目标</h2><p>了解微服务架构的优缺点</p><h2 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1.单体架构"></a>1.1.单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713202807818.png" alt="image-20210713202807818"></p><p>单体架构的优缺点如下：</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="1-2-分布式架构"><a href="#1-2-分布式架构" class="headerlink" title="1.2.分布式架构"></a>1.2.分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713203124797.png" alt="image-20210713203124797"></p><p>分布式架构的优缺点：</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="1-3-微服务"><a href="#1-3-微服务" class="headerlink" title="1.3.微服务"></a>1.3.微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713203753373.png" alt="image-20210713203753373"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</p><h2 id="1-4-SpringCloud"><a href="#1-4-SpringCloud" class="headerlink" title="1.4.SpringCloud"></a>1.4.SpringCloud</h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud。">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713204155887.png" alt="image-20210713204155887"></p><p>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713205003790.png" alt="image-20210713205003790"></p><p>我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。</p><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5.总结"></a>1.5.总结</h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><p>①优点：拆分粒度更小、服务更独立、耦合度更低</p><p>②缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h1 id="2-服务拆分和远程调用"><a href="#2-服务拆分和远程调用" class="headerlink" title="2.服务拆分和远程调用"></a>2.服务拆分和远程调用</h1><p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p><h2 id="2-1-服务拆分原则"><a href="#2-1-服务拆分原则" class="headerlink" title="2.1.服务拆分原则"></a>2.1.服务拆分原则</h2><p>这里我总结了微服务拆分时的几个原则：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713210800950.png" alt="image-20210713210800950"></p><h2 id="2-2-服务拆分示例"><a href="#2-2-服务拆分示例" class="headerlink" title="2.2.服务拆分示例"></a>2.2.服务拆分示例</h2><p>以课前资料中的微服务cloud-demo为例，其结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713211009593.png" alt="image-20210713211009593"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li><li>订单服务和用户服务都对外暴露Restful的接口</li><li>订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库</li></ul><h3 id="2-2-1-导入Sql语句"><a href="#2-2-1-导入Sql语句" class="headerlink" title="2.2.1.导入Sql语句"></a>2.2.1.导入Sql语句</h3><p>首先，将课前资料提供的<code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到mysql中：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713211417049.png" alt="image-20210713211417049"></p><p>cloud-user表中初始数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713211550169.png" alt="image-20210713211550169"></p><p>cloud-order表中初始数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713211657319.png" alt="image-20210713211657319"></p><p>cloud-order表中持有cloud-user表中的id字段。</p><h3 id="2-2-2-导入demo工程"><a href="#2-2-2-导入demo工程" class="headerlink" title="2.2.2.导入demo工程"></a>2.2.2.导入demo工程</h3><p>用IDEA导入课前资料提供的Demo：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713211814094.png" alt="image-20210713211814094"></p><p>项目结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713212656887.png" alt="image-20210713212656887"></p><p>导入后，会在IDEA右下角出现弹窗：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713212349272.png" alt="image-20210713212349272"></p><p>点击弹窗，然后按下图选择：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713212336185.png" alt="image-20210713212336185"></p><p>会出现这样的菜单：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713212513324.png" alt="image-20210713212513324"></p><p>配置下项目使用的JDK：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713220736408.png" alt="image-20210713220736408"></p><h2 id="2-3-实现远程调用案例"><a href="#2-3-实现远程调用案例" class="headerlink" title="2.3.实现远程调用案例"></a>2.3.实现远程调用案例</h2><p>在order-service服务中，有一个根据id查询订单的接口：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713212749575.png" alt="image-20210713212749575"></p><p>根据id查询订单，返回值是Order对象，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713212901725.png" alt="image-20210713212901725"></p><p>其中的user为null</p><p>在user-service中有一个根据id查询用户的接口：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713213146089.png" alt="image-20210713213146089"></p><p>查询的结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713213213075.png" alt="image-20210713213213075"></p><h3 id="2-3-1-案例需求："><a href="#2-3-1-案例需求：" class="headerlink" title="2.3.1.案例需求："></a>2.3.1.案例需求：</h3><p>修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713213312278.png" alt="image-20210713213312278"></p><p>因此，我们需要在order-service中 向user-service发起一个http的请求，调用<a href="http://localhost:8081/user/{userId}这个接口。">http://localhost:8081/user/{userId}这个接口。</a></p><p>大概的步骤是这样的：</p><ul><li>注册一个RestTemplate的实例到Spring容器</li><li>修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User</li><li>将查询的User填充到Order对象，一起返回</li></ul><h3 id="2-3-2-注册RestTemplate"><a href="#2-3-2-注册RestTemplate" class="headerlink" title="2.3.2.注册RestTemplate"></a>2.3.2.注册RestTemplate</h3><p>首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-实现远程调用"><a href="#2-3-3-实现远程调用" class="headerlink" title="2.3.3.实现远程调用"></a>2.3.3.实现远程调用</h3><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713213959569.png" alt="image-20210713213959569"></p><h2 id="2-4-提供者与消费者"><a href="#2-4-提供者与消费者" class="headerlink" title="2.4.提供者与消费者"></a>2.4.提供者与消费者</h2><p>在服务调用关系中，会有两个不同的角色：</p><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p><p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713214404481.png" alt="image-20210713214404481"></p><p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p><p>如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？</p><ul><li>对于A调用B的业务而言：A是服务消费者，B是服务提供者</li><li>对于B调用C的业务而言：B是服务消费者，C是服务提供者</li></ul><p>因此，服务B既可以是服务提供者，也可以是服务消费者。</p><h1 id="3-Eureka注册中心"><a href="#3-Eureka注册中心" class="headerlink" title="3.Eureka注册中心"></a>3.Eureka注册中心</h1><p>假如我们的服务提供者user-service部署了多个实例，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713214925388.png" alt="image-20210713214925388"></p><p>大家思考几个问题：</p><ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时该如何选择？</li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li></ul><h2 id="3-1-Eureka的结构和作用"><a href="#3-1-Eureka的结构和作用" class="headerlink" title="3.1.Eureka的结构和作用"></a>3.1.Eureka的结构和作用</h2><p>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713220104956.png" alt="image-20210713220104956"></p><p>回答之前的各个问题。</p><p>问题1：order-service如何得知user-service实例地址？</p><p>获取地址信息的流程如下：</p><ul><li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li><li>eureka-server保存服务名称到服务实例地址列表的映射关系</li><li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>问题2：order-service如何从多个user-service实例中选择具体的实例？</p><ul><li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p><ul><li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service拉取服务时，就能将故障实例排除了</li></ul><blockquote><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p></blockquote><p>因此，接下来我们动手实践的步骤包括：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713220509769.png" alt="image-20210713220509769"></p><h2 id="3-2-搭建eureka-server"><a href="#3-2-搭建eureka-server" class="headerlink" title="3.2.搭建eureka-server"></a>3.2.搭建eureka-server</h2><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p><h3 id="3-2-1-创建eureka-server服务"><a href="#3-2-1-创建eureka-server服务" class="headerlink" title="3.2.1.创建eureka-server服务"></a>3.2.1.创建eureka-server服务</h3><p>在cloud-demo父工程下，创建一个子模块：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713220605881.png" alt="image-20210713220605881"></p><p>填写模块信息：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713220857396.png" alt="image-20210713220857396"></p><p>然后填写服务信息：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713221339022.png" alt="image-20210713221339022"></p><h3 id="3-2-2-引入eureka依赖"><a href="#3-2-2-引入eureka依赖" class="headerlink" title="3.2.2.引入eureka依赖"></a>3.2.2.引入eureka依赖</h3><p>引入SpringCloud为eureka提供的starter依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-编写启动类"><a href="#3-2-3-编写启动类" class="headerlink" title="3.2.3.编写启动类"></a>3.2.3.编写启动类</h3><p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-编写配置文件"><a href="#3-2-4-编写配置文件" class="headerlink" title="3.2.4.编写配置文件"></a>3.2.4.编写配置文件</h3><p>编写一个application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3-2-5-启动服务"><a href="#3-2-5-启动服务" class="headerlink" title="3.2.5.启动服务"></a>3.2.5.启动服务</h3><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086">http://127.0.0.1:10086</a></p><p>看到下面结果应该是成功了：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713222157190.png" alt="image-20210713222157190"></p><h2 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3.服务注册"></a>3.3.服务注册</h2><p>下面，我们将user-service注册到eureka-server中去。</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在user-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>在user-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3）启动多个user-service实例"><a href="#3）启动多个user-service实例" class="headerlink" title="3）启动多个user-service实例"></a>3）启动多个user-service实例</h3><p>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</p><p>首先，复制原来的user-service启动配置：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713222656562.png" alt="image-20210713222656562"></p><p>然后，在弹出的窗口中，填写信息：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713222757702.png" alt="image-20210713222757702"></p><p>现在，SpringBoot窗口会出现两个user-service启动配置：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713222841951.png" alt="image-20210713222841951"></p><p>不过，第一个是8081端口，第二个是8082端口。</p><p>启动两个user-service实例：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713223041491.png" alt="image-20210713223041491"></p><p>查看eureka-server管理页面：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713223150650.png" alt="image-20210713223150650"></p><h2 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4.服务发现"></a>3.4.服务发现</h2><p>下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</p><h3 id="1）引入依赖-1"><a href="#1）引入依赖-1" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p><p>在order-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）配置文件-1"><a href="#2）配置文件-1" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p><p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3）服务拉取和负载均衡"><a href="#3）服务拉取和负载均衡" class="headerlink" title="3）服务拉取和负载均衡"></a>3）服务拉取和负载均衡</h3><p>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p><p>不过这些动作不用我们去做，只需要添加一些注解即可。</p><p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713224049419.png" alt="image-20210713224049419"></p><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713224245731.png" alt="image-20210713224245731"></p><p>spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</p><h1 id="4-Ribbon负载均衡"><a href="#4-Ribbon负载均衡" class="headerlink" title="4.Ribbon负载均衡"></a>4.Ribbon负载均衡</h1><p>上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？</p><h2 id="4-1-负载均衡原理"><a href="#4-1-负载均衡原理" class="headerlink" title="4.1.负载均衡原理"></a>4.1.负载均衡原理</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713224517686.png" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是<a href="http://userservice/user/1，怎么变成了http://localhost:8081的呢？">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p><h2 id="4-2-源码跟踪"><a href="#4-2-源码跟踪" class="headerlink" title="4.2.源码跟踪"></a>4.2.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><p>我们进行源码跟踪：</p><h3 id="1）LoadBalancerIntercepor"><a href="#1）LoadBalancerIntercepor" class="headerlink" title="1）LoadBalancerIntercepor"></a>1）LoadBalancerIntercepor</h3><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/1525620483637.png" alt="1525620483637"></p><p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p><h3 id="2）LoadBalancerClient"><a href="#2）LoadBalancerClient" class="headerlink" title="2）LoadBalancerClient"></a>2）LoadBalancerClient</h3><p>继续跟入execute方法：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/1525620787090.png" alt="1525620787090"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是8081：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/1525620835911.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="3）负载均衡策略IRule"><a href="#3）负载均衡策略IRule" class="headerlink" title="3）负载均衡策略IRule"></a>3）负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/1525620835911.png" alt="1525620835911"></p><p>我们继续跟入：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/1544361421671.png" alt="1544361421671"></p><p>继续跟踪源码chooseServer方法，发现这么一段代码：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/1525622652849.png" alt="1525622652849"></p><p>我们看看这个rule是谁：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/1525622699666.png" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/1525622754316.png" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713224724673.png" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的RestTemplate请求<a href="http://userservice/user/1">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost:8081、localhost:8082</li><li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1，发起真实请求">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="4-3-负载均衡策略"><a href="#4-3-负载均衡策略" class="headerlink" title="4.3.负载均衡策略"></a>4.3.负载均衡策略</h2><h3 id="4-3-1-负载均衡策略"><a href="#4-3-1-负载均衡策略" class="headerlink" title="4.3.1.负载均衡策略"></a>4.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713225653000.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><div class="table-container"><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table></div><p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p><h3 id="4-3-2-自定义负载均衡策略"><a href="#4-3-2-自定义负载均衡策略" class="headerlink" title="4.3.2.自定义负载均衡策略"></a>4.3.2.自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><ol><li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><h2 id="4-4-饥饿加载"><a href="#4-4-饥饿加载" class="headerlink" title="4.4.饥饿加载"></a>4.4.饥饿加载</h2><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span></span><br></pre></td></tr></table></figure><h1 id="5-Nacos注册中心"><a href="#5-Nacos注册中心" class="headerlink" title="5.Nacos注册中心"></a>5.Nacos注册中心</h1><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</p><h2 id="5-1-认识和安装Nacos"><a href="#5-1-认识和安装Nacos" class="headerlink" title="5.1.认识和安装Nacos"></a>5.1.认识和安装Nacos</h2><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713230444308.png" alt="image-20210713230444308"></p><p>安装方式可以参考课前资料《Nacos安装指南.md》</p><h2 id="5-2-服务注册到nacos"><a href="#5-2-服务注册到nacos" class="headerlink" title="5.2.服务注册到nacos"></a>5.2.服务注册到nacos</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><h3 id="1）引入依赖-2"><a href="#1）引入依赖-2" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p></blockquote><h3 id="2）配置nacos地址"><a href="#2）配置nacos地址" class="headerlink" title="2）配置nacos地址"></a>2）配置nacos地址</h3><p>在user-service和order-service的application.yml中添加nacos地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote><h3 id="3）重启"><a href="#3）重启" class="headerlink" title="3）重启"></a>3）重启</h3><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713231439607.png" alt="image-20210713231439607"></p><h2 id="5-3-服务分级存储模型"><a href="#5-3-服务分级存储模型" class="headerlink" title="5.3.服务分级存储模型"></a>5.3.服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713232522531.png" alt="image-20210713232522531"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713232658928.png" alt="image-20210713232658928"></p><p>杭州机房内的order-service应该优先访问同机房的user-service。</p><h3 id="5-3-1-给user-service配置集群"><a href="#5-3-1-给user-service配置集群" class="headerlink" title="5.3.1.给user-service配置集群"></a>5.3.1.给user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713232916215.png" alt="image-20210713232916215"></p><p>我们再次复制一个user-service启动配置，添加属性：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</span><br></pre></td></tr></table></figure><p>配置如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713233528982.png" alt="image-20210713233528982"></p><p>启动UserApplication3后再次查看nacos控制台：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713233727923.png" alt="image-20210713233727923"></p><h3 id="5-3-2-同集群优先的负载均衡"><a href="#5-3-2-同集群优先的负载均衡" class="headerlink" title="5.3.2.同集群优先的负载均衡"></a>5.3.2.同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给order-service配置集群信息</p><p>修改order-service的application.yml文件，添加集群配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:8848</span><br><span class="line">      discovery:</span><br><span class="line">        cluster-name: HZ <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>2）修改负载均衡规则</p><p>修改order-service的application.yml文件，修改负载均衡规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><h2 id="5-4-权重配置"><a href="#5-4-权重配置" class="headerlink" title="5.4.权重配置"></a>5.4.权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713235133225.png" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210713235235219.png" alt="image-20210713235235219"></p><blockquote><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote><h2 id="5-5-环境隔离"><a href="#5-5-环境隔离" class="headerlink" title="5.5.环境隔离"></a>5.5.环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210714000101516.png" alt="image-20210714000101516"></p><h3 id="5-5-1-创建namespace"><a href="#5-5-1-创建namespace" class="headerlink" title="5.5.1.创建namespace"></a>5.5.1.创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210714000414781.png" alt="image-20210714000414781"></p><p>我们可以点击页面新增按钮，添加一个namespace：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210714000440143.png" alt="image-20210714000440143"></p><p>然后，填写表单：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210714000505928.png" alt="image-20210714000505928"></p><p>就能在页面看到一个新的namespace：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210714000522913.png" alt="image-20210714000522913"></p><h3 id="5-5-2-给微服务配置namespace"><a href="#5-5-2-给微服务配置namespace" class="headerlink" title="5.5.2.给微服务配置namespace"></a>5.5.2.给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210714000830703.png" alt="image-20210714000830703"></p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210714000837140.png" alt="image-20210714000837140"></p><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210714000941256.png" alt="image-20210714000941256"></p><h2 id="5-6-Nacos与Eureka的区别"><a href="#5-6-Nacos与Eureka的区别" class="headerlink" title="5.6.Nacos与Eureka的区别"></a>5.6.Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="https://cdn.jsdelivr.net/gh/ShallowRecall/Images@main/images/2023/11/image-20210714001728017.png" alt="image-20210714001728017"></p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringCloud01&quot;&gt;&lt;a href=&quot;#SpringCloud01&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud01&quot;&gt;&lt;/a&gt;SpringCloud01&lt;/h1&gt;&lt;h1 id=&quot;1-认识微服务&quot;&gt;&lt;a href=&quot;#1-</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/"/>
    
    <category term="SpringCloud" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SpringCloud/"/>
    
    
    <category term="微服务" scheme="https://www.shallowrecall.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>堆和栈的区别</title>
    <link href="https://www.shallowrecall.top/posts/322da11e.html"/>
    <id>https://www.shallowrecall.top/posts/322da11e.html</id>
    <published>2024-03-11T10:56:28.000Z</published>
    <updated>2024-03-11T14:02:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stack-Vs-Heap"><a href="#Stack-Vs-Heap" class="headerlink" title="Stack Vs Heap"></a>Stack Vs Heap</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ul><li>管理方式不同：栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放；</li><li>空间大小不同：栈的空间是有限的，在32位平台下，VC6下默认为1M，堆最大可以到4G；</li><li>能否产生碎片：栈和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，如果不停地调用malloc、free堆造成内存碎片很多;</li><li>生长方向不同：堆生长方向是向上的，也就是向着地址增加的方向，栈刚好相反，向着内存减小的方向生长。</li><li>分配方式不同：堆都是动态分配的，没有静态分配的堆。栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。</li><li>分配效率不同：栈的效率比堆高很多。栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。</li></ul><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Stack-Vs-Heap&quot;&gt;&lt;a href=&quot;#Stack-Vs-Heap&quot; class=&quot;headerlink&quot; title=&quot;Stack Vs Heap&quot;&gt;&lt;/a&gt;Stack Vs Heap&lt;/h2&gt;&lt;h3 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>IO流</title>
    <link href="https://www.shallowrecall.top/posts/fed4c017.html"/>
    <id>https://www.shallowrecall.top/posts/fed4c017.html</id>
    <published>2024-02-28T11:50:07.000Z</published>
    <updated>2024-12-01T10:47:28.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、IO流的概述"><a href="#一、IO流的概述" class="headerlink" title="一、IO流的概述"></a>一、IO流的概述</h2><ol><li>什么是IO流</li></ol><p>​    存储和读取数据的解决方案</p><p>​    I : input    O : ouput</p><p>​    流 : 像水流一样传输数据</p><ol><li>IO流的作用？</li></ol><p>​    用于读写数据(本地文件，网络)</p><ol><li>IO流按照流向可以分类哪两种流？</li></ol><p>​    流出流 : 程序  ——&gt;  文件</p><p>​    输入流 : 文件  ——&gt;  程序</p><ol><li>IO流按照操作文件的类型可以分类哪两种流？</li></ol><p>​    字节流 : 可以操作所有类型的文件</p><p>​    字符流 : 只能操作纯文本文件</p><ol><li>什么是纯文本文件？</li></ol><p>​    用Windows系统自带的记事本打开并且能读懂的文件(txt文件，md文件，xml文件，lrc文件等)</p><h2 id="二、FileOutputStream的介绍"><a href="#二、FileOutputStream的介绍" class="headerlink" title="二、FileOutputStream的介绍"></a>二、FileOutputStream的介绍</h2><h3 id="FileOutputStream书写细节"><a href="#FileOutputStream书写细节" class="headerlink" title="FileOutputStream书写细节"></a>FileOutputStream书写细节</h3><ol><li><p>创建字节输出流对象<br>细节1：参数是字符串表示的路径或者是FIle对象都可以<br>细节2: 如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的。<br>细节3: 如果文件已经存在，则会清空文件</p></li><li><p>写数据<br>细节：write方法的参数是整数，但是实际上写到本地文件中的是整数的ASCII上对应的字符</p></li><li><p>释放资源<br>每次使用完流之后都要释放资源</p></li></ol><h3 id="换行-和-续写"><a href="#换行-和-续写" class="headerlink" title="换行 和 续写"></a>换行 和 续写</h3><p>换行写:</p><p>再次写出一个换行符号就可以了<br>Windows: \r\n<br>早期的dos系统当中的回车是将光标放到这一行的开头，<br>换行才是真正的将光标移到下一行<br>Linux：  \n<br>Mac：    \r<br>细节：<br>在Windows系统当中，java对回车换行进行了优化。<br>虽然完整的是\r\n,但是我们写其中一个\r或者\n.<br>java也可以实现换行，因为java在底层会补全。<br>建议：<br>不要省略，还是写全了。</p><p>续写:<br>如果想要续写，打开续写开关即可<br>开关位置：创建对象的第二个参数<br>默认false：表示关闭续写，此时创建对象就会清空文件<br>手动传递true：表示打开续写，此时创建对象不会清空文件</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>FileOutputStream作用</p><p>可以把程序中的数据写在本地文件上，是字节流的基本流</p></li><li><p>书写步骤</p><p>创建对象，写出数据，释放资源</p></li><li><p>三步操作的细节</p><p>1）创建对象：文件存在(会清空内容，打开续写开关就可以在后面append)、文件不存在(会创建文件、但是需要保证父级文件存在，否则会报错)、追加写入</p><p>2）写出数据：写出整数(实际是ASCII表中对应的字符)、写出字节数组(相当于把字节数组的全部，或者一部分写入到本地文件当中)、换行写(写出一个换行符 windows : \r\n; Linux : \n; Mac : \r;)</p><p>3）释放资源: 关闭通道</p></li></ol><h2 id="三、FileInputStream的介绍"><a href="#三、FileInputStream的介绍" class="headerlink" title="三、FileInputStream的介绍"></a>三、FileInputStream的介绍</h2><h3 id="FileInputStream书写细节"><a href="#FileInputStream书写细节" class="headerlink" title="FileInputStream书写细节"></a>FileInputStream书写细节</h3><ol><li><p>创建字节输入流对象</p><p>细节1：如果文件不存在，就会直接报错。<br>Java为什么会这么设计？<br>输出流：不存在，创建<br>把数据写到文件当中</p><pre><code> 输入流：不存在，而是报错呢？                     因为创建出来的文件是没有数据的，没有任何意义。                     所以Java就没有设计这种无意义的逻辑，文件不存在直接报错。</code></pre><p>程序中最重要的是：数据。</p></li><li><p>读取数据</p><p>细节1：一次读一个字节，读出来的是数据在ASCII上对应的数字</p><p>细节2：读到文件末尾了，read方法返回-1。</p><p>tip：如果文件中最后一个是-1，会分两次读取，首先读取-号，然后读取1;</p></li><li><p>释放资源</p><p>细节：每次使用完流之后都要释放资源</p></li></ol><h3 id="字节输入流循环读取"><a href="#字节输入流循环读取" class="headerlink" title="字节输入流循环读取"></a>字节输入流循环读取</h3><p>read : 表示读取数据，而且是读取一个数据就移动一次指针</p><h2 id="四、字符集"><a href="#四、字符集" class="headerlink" title="四、字符集"></a>四、字符集</h2><h4 id="ASCII、GBK"><a href="#ASCII、GBK" class="headerlink" title="ASCII、GBK"></a>ASCII、GBK</h4><h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><p>1）计算机中最小存储单元是一个字节</p><p>2）计算机在存储英文时，只需要128个Byte就够了，而一个字节可以存储256个数据，因此一个字节就够了</p><p>3）假设现在要存储 ‘a’ ，其对应的ASCII为 97 , 97用二进制表示为110 0001，并不能直接将110 0001直接存储进去，而是需要编码{ASCII编码规则：前面补0，补齐8位}，因此真实存储在计算机里面的时0110 0001，如果现在要读取出来，就会读取到0110 0001 ，然后解码{ASCII解码规则：直接转成十进制} 得到 97，查询ASCII 读取到英文’a’</p><p>4）GBK存储规则：英文用一个字节存储，汉字用两个字节存储(可以记录65535个字符)</p><p>规则1：汉字两个字节存储</p><p>规则2：高位字节二进制一定以1开头，转成十进制之后是一个复数</p><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p>问题一：10111010  10111010  01100001</p><p>一个汉字一个英文[汉 a]</p><p>问题二：01100001  01100010  01100011</p><p>三个英文[a b c]</p><p>问题三：10110000  10100010  11100111  11100010  10111010 11000011  11001011  10100111</p><p>四个汉字[阿 玮 好 帅]</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ol><li><p>在计算书机中，任意数据都是以二进制的形式来存储的</p></li><li><p>计算机中最小的存储单元是一个字节</p></li><li><p>ASCII字符集中，一个英文占一个字节</p></li><li><p>简体中文版Windows，默认使用GBK字符集</p></li><li><p>GBK字符集完全兼容ASCII字符集</p><p>一个英文占一个字节，二进制第一位是0</p><p>一个英文占两个字节，二进制高位字节的第一位是1</p></li></ol><h4 id="Unicode：万国码"><a href="#Unicode：万国码" class="headerlink" title="Unicode：万国码"></a>Unicode：万国码</h4><h5 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h5><p>1）Unicode编码：</p><p>UTF(Unicode Transfer Format)</p><p>UTF-16编码规则：用2~4个字节保存</p><p>a —&gt; 97 —&gt; 00000000 01100001</p><p>UTF-32编码规则：固定使用四个字节保存</p><p>a —&gt; 97 —&gt;00000000 00000000 00000000 01100001</p><p>UTF-8编码规则：用1~4个字节保存</p><p>UTF-8编码方式(二进制)</p><blockquote><p>0xxxxxxxx (ASCII码)</p><p>110xxxxx 10xxxxxx (两个字节)</p><p>1110xxxx 10xxxxxx 10xxxxxx (三个字节)</p><p>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx (四个字节)</p></blockquote><p>a —&gt; 97 —&gt; 110 0001(英文采用一个字节) —&gt; (0110 0001)</p><p>汉 —&gt; 27721 —&gt; 01101100 01001001(汉字采用三个字节) —&gt;</p><p>11100110 10110001 10001001</p><p>英文：1个字节    中文：3个字节，第一个字节的首位是1</p><h5 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h5><ol><li><p>UTF-8是一个字符集吗？</p><p>不是，是Unicode字符集的一种编码方式</p></li><li><p>以下为Unicode字符集，利用UTF-8编码之后的二进制数据，请说出有几个中文，几个英文？</p><p>问题一：01001010 01100001 01110110 01100001</p><p>三个英文，零个汉字[j a v a]</p><p>问题二：01100001 01101001 11100100 10111101 10100000 11100101 10010011 10011111</p><p>两个英文，两个汉字[a i 你 哟]</p><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><ol><li><p>Unicode字符集的UTF-8编码格式</p><p>一个英文占一个字节，二进制第一位是0，转成十进制是正数</p><p>一个中文占三个字节，二进制第一位是1，第一个字节转成十进制是负数</p></li></ol></li></ol><h4 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h4><h5 id="为什么会产生乱码？"><a href="#为什么会产生乱码？" class="headerlink" title="为什么会产生乱码？"></a>为什么会产生乱码？</h5><p>原因1：读取数据时未读完整个汉字</p><p>原因2：编码和解码时的方式不统一</p><h5 id="如何不产生乱码？"><a href="#如何不产生乱码？" class="headerlink" title="如何不产生乱码？"></a>如何不产生乱码？</h5><ol><li>不要使用字节流读取文本文件</li><li>编码解码时使用同一个码表，同一个编码方式</li></ol><h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>疑问：字节流读取中文会乱码，但是为什么拷贝不会乱码呢？</p><blockquote><p>当使用字节流（如InputStream）读取中文字符时可能会出现乱码的情况，这是因为字节流是以字节为单位进行读取的，而中文字符通常需要多个字节来表示（例如UTF-8编码中的中文字符通常需要3个字节）。</p><p>如果你使用字节流直接读取，可能会把一个中文字符的一部分作为一个字节读取，导致解码时出现乱码。</p><p>然而，当你进行拷贝时，实际上是将原始的字节流进行了复制，不涉及字符编码和解码的过程。所以即使原始数据中存在中文字符，拷贝的过程中并不会对中文字符进行处理，因此不会出现乱码问题。</p><p>如果你希望在处理中文字符时避免乱码，可以考虑使用字符流（如Reader）和相应的字符编码（如UTF-8）来进行读取和写入，这样可以确保正确地处理中文字符。字符流会以字符为单位进行读取，而不是字节，从而避免了中文字符被拆分的问题。</p></blockquote><h2 id="五、FileReader-的介绍"><a href="#五、FileReader-的介绍" class="headerlink" title="五、FileReader 的介绍"></a>五、FileReader 的介绍</h2><h3 id="FileReader书写细节"><a href="#FileReader书写细节" class="headerlink" title="FileReader书写细节"></a>FileReader书写细节</h3><ol><li><p>创建字符输入流对象</p><p>public FileReader(File file)                        创建字符输入流关联本地文件<br>public FileReader(String pathname)               创建字符输入流关联本地文件</p><p>细节1：如果文件不存在，就直接报错。</p></li><li><p>读取数据</p><p>public int read()                                                  读取数据，读到末尾返回-1</p><p>public int read(char[] buffer)                            读取多个数据，读到末尾返回-1</p><p>细节1：按字节进行读取，遇到中文，一次读多个字节，读取后解码，返回一个整数</p><p>细节2：读到文件末尾了，read方法返回-1。</p></li><li><p>释放资源</p><p>public int close()                           释放资源/关流</p></li></ol><h2 id="六、FileWriter-的介绍"><a href="#六、FileWriter-的介绍" class="headerlink" title="六、FileWriter 的介绍"></a>六、FileWriter 的介绍</h2><h3 id="FileWriter书写细节"><a href="#FileWriter书写细节" class="headerlink" title="FileWriter书写细节"></a>FileWriter书写细节</h3><ol><li><p>创建字符输出流对象</p><p>细节1：参数是字符串表示的路径或者File对象都是可以的</p><p>细节2：如果文件不存在会创建一个新的文件，但要保证父级路径是存在的</p><p>细节3：如果文件已经存在，则会清空文件，如果不想清空可以打开续写开关</p></li><li><p>写数据</p><p>细节：如果writer方法额参数是整数，但实际上写到本地文件中的是整数在字符集上对应的字符</p></li><li><p>释放资源</p><p>细节：每次使用完流之后都要释放资源</p></li></ol><h4 id="字符流原理解析"><a href="#字符流原理解析" class="headerlink" title="字符流原理解析"></a>字符流原理解析</h4><h5 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h5><ol><li><p>创建字符输入流对象</p><p>底层：关联文件，并创建缓冲区(长度为8192的字节数组)</p></li><li><p>读取数据</p><p>底层：1.判断缓冲区是否有数据可以读取</p><p>​        2.缓冲区没有数据：就从文件中获取数据，装到缓冲区中，每次尽可能装满缓冲区</p><p>​                           如果文件中野没有数据了，返回-1</p><p>​            3.缓冲区有数据：就从缓冲区读取。</p><p>​    空参的read方法：一次读取一个字节，遇到中文一次读多个字节，并把字节源码转成十进制返回</p><p>​    有参的read方法：把读取字节，解码，强转三步合并了，强转之后的字符放到数组中</p></li></ol><h5 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、IO流的概述&quot;&gt;&lt;a href=&quot;#一、IO流的概述&quot; class=&quot;headerlink&quot; title=&quot;一、IO流的概述&quot;&gt;&lt;/a&gt;一、IO流的概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;什么是IO流&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​    存储和读取数据的解决方案&lt;/</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/"/>
    
    <category term="Java高级" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/Java%E9%AB%98%E7%BA%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring+SpringMVC+Mybatis</title>
    <link href="https://www.shallowrecall.top/posts/407fb720.html"/>
    <id>https://www.shallowrecall.top/posts/407fb720.html</id>
    <published>2024-02-27T13:04:44.000Z</published>
    <updated>2024-04-22T04:38:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Spring简介"><a href="#1-Spring简介" class="headerlink" title="1. Spring简介"></a>1. Spring简介</h2><h3 id="1-1-Spring是什么"><a href="#1-1-Spring是什么" class="headerlink" title="1.1 Spring是什么"></a>1.1 Spring是什么</h3><p>Spring是分层的Java SE/EE应用full-stack轻量级开源框架，以<code>IoC</code>（Inverse Of Control：反转控制）和<code>AOP</code>（Aspect Oriented<br>Programming：面向切面编程）为内核。</p><p>提供了<code>展现SpringMVC</code>和<code>持久层Spring JDBCTemplate</code>以及<code>业务层事务管理</code>等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java<br>EE 企业应用开源框架。</p><h3 id="1-2-Spring发展历程"><a href="#1-2-Spring发展历程" class="headerlink" title="1.2 Spring发展历程"></a>1.2 Spring发展历程</h3><p>1997年，IBM提出了 EJB 的思想</p><p>1998年，SUN制定开发标准规范 EJB 1.0</p><p>1999年，EJB 1.1 发布</p><p>2001年，EJB 2.0 发布</p><p>2003年，EJB 2.1 发布</p><p>2006年，EJB 3.0 发布</p><p><code>Rob Johnson（Spring之父）</code></p><p>Expert One-to-One J2EE Design and Development(2022)</p><p>阐述了 J2EE 使用EJB 开发设计的优缺点及解决方案</p><p>Expert One-to-One J2EE Development without EJB(2004)</p><p>阐述了 J2EE 开发不使用EJB 的解决方式（Spring雏形）</p><p><code>2017 年9月份发布了Spring的最新版本 Spring5.0 通用版（GA）</code></p><h3 id="1-3-Spring的优势"><a href="#1-3-Spring的优势" class="headerlink" title="1.3 Spring的优势"></a>1.3 Spring的优势</h3><p>1）方便解耦，简化开发</p><p>​ 通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p><p>2）AOP编程的支持</p><p>​ 通过 Spring的AOP功能，方便进行面向切面编程，许多不容易用传统OOP实现的功能可以通过AOP轻松实现。</p><p>3）声明式事务的支持</p><p>​ 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务管理，提高开发效率和质量。</p><p>4）方便程序的测试</p><p>​ 可以用费容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。</p><p>5）方便集成各种优秀框架</p><p>​ Spring对各种优秀框架（Struct、Hibernate、Hessian、Quartz）的支持。</p><p>6）降低JavaEE API 的使用难度</p><p>​ Spring对JavaEE API (如JDBC、JavaMail、远程调用等) 进行了薄薄的封装层，使这些API的使用难度大为降低。</p><p>7）Java源码是经典学习范例</p><p>​ Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java 设计模式灵活运用以及对Java技术的高深造诣。它的源代码无疑是Java技术的最佳实践的范例。</p><h3 id="1-4-Spring的体系结构"><a href="#1-4-Spring的体系结构" class="headerlink" title="1.4 Spring的体系结构"></a>1.4 Spring的体系结构</h3><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240215154337044.png" alt="image-20240215154337044" style="zoom: 33%;" /></p><h2 id="2-Spring快速入门"><a href="#2-Spring快速入门" class="headerlink" title="2. Spring快速入门"></a>2. Spring快速入门</h2><h3 id="2-1-Spring程序开发步骤"><a href="#2-1-Spring程序开发步骤" class="headerlink" title="2.1 Spring程序开发步骤"></a>2.1 Spring程序开发步骤</h3><p><img src="https://images.shallowrecall.top/images/2024/2/IMG_0306.jpeg" alt="IMG_0306" style="zoom: 33%;" /></p><p>① 导入 Spring开发的基本包坐标</p><p>② 编写 Dao接口和实现类</p><p>③ 创建 Spring核心配置文件</p><p>④ 在 Spring配置文件中配置UserDaoImpl</p><p>⑤ 使用 Spring的API获得 Bean实例</p><p>Spring的开发步骤：</p><p>① 导入坐标</p><p>② 创建Bean</p><p>③ 创建applicationContext.xml</p><p>④ 在配置文件中进行配置</p><p>⑤ 创建ApplicationContext对象getBean</p><h2 id="3-Spring配置文件"><a href="#3-Spring配置文件" class="headerlink" title="3. Spring配置文件"></a>3. Spring配置文件</h2><h3 id="3-1-Bean标签基本配置"><a href="#3-1-Bean标签基本配置" class="headerlink" title="3.1 Bean标签基本配置"></a>3.1 Bean标签基本配置</h3><p>用于配置对象交由<code>Spring</code>来创建</p><p>默认情况下它调用的是类中的<code>无参构造函数</code>，如果没有无参构造函数则不能创建成功。</p><p>基本属性：</p><ul><li><code>id</code>：Bean实例在Spring容器中的唯一标识</li><li><code>class</code>：Bean的全限定名称</li></ul><h3 id="3-2-Bean标签范围配置"><a href="#3-2-Bean标签范围配置" class="headerlink" title="3.2 Bean标签范围配置"></a>3.2 Bean标签范围配置</h3><p>scope：指对象的作用范围，取值如下：</p><div class="table-container"><table><thead><tr><th>取值范围</th><th>说明</th></tr></thead><tbody><tr><td><code>singleton</code></td><td><code>默认值，单例的</code></td></tr><tr><td><code>prototype</code></td><td><code>多例的</code></td></tr><tr><td>request</td><td>WEB 项目中，Spring创建一个Bean 的对象，将对象存入到request域中</td></tr><tr><td>session</td><td>WEB 项目中，Spring创建一个Bean 的对象，将对象存入到session域中</td></tr><tr><td>global session</td><td>WEB 项目中，应用在Portlet环境，如果没有Portlet环境那么globalSession相当于session</td></tr></tbody></table></div><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) app.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) app.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        System.out.println(userDao1);</span><br><span class="line">        System.out.println(userDao2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1）当scope的取值为<code>singleton</code>时</p><p>​ Bean的实例化个数：1个</p><p>​ Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例</p><p>​ Bean的生命周期：</p><ul><li>对象创建：当应用加载，创建容器时，对象就被创建</li><li>对象运行：只要容器在，对象一直活着</li><li>对象销毁：当应用卸载，销毁容器时，对象就被销毁了</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.dao.impl.UserDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.recallstudy.dao.impl.UserDaoImpl@76707e36</span><br><span class="line">com.recallstudy.dao.impl.UserDaoImpl@76707e36</span><br></pre></td></tr></table></figure><p>2）当scope的取值为<code>prototype</code></p><p>​ Bean的实例化个数：多个</p><p>​ Bean的实例化时机：当调用getBean()方法时实例化Bean</p><ul><li>对象创建：当使用对象时，创建新的对象实例</li><li>对象运行：只要对象在使用中，就一直活着</li><li>对象销毁：当对象长时间不用时，被Java的垃圾回收器回收了</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.dao.impl.UserDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.recallstudy.dao.impl.UserDaoImpl@76707e36</span><br><span class="line">com.recallstudy.dao.impl.UserDaoImpl@614ddd49</span><br></pre></td></tr></table></figure><h3 id="3-3-Bean生命周期配置"><a href="#3-3-Bean生命周期配置" class="headerlink" title="3.3 Bean生命周期配置"></a>3.3 Bean生命周期配置</h3><ul><li><code>init-method</code>：指定类中的初始化方法名称</li><li><code>destroy-method</code>：指定类中销毁方法名称</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.dao.impl.UserDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-4-Bean实例化三种方式"><a href="#3-4-Bean实例化三种方式" class="headerlink" title="3.4 Bean实例化三种方式"></a>3.4 Bean实例化三种方式</h3><ul><li><p>无参<code>构造</code>方法实例化</p></li><li><p>工厂<code>静态</code>方法实例化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.factory.StaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>工厂<code>实例</code>方法实例化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.factory.DynamicFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5-Bean的依赖注入分析"><a href="#3-5-Bean的依赖注入分析" class="headerlink" title="3.5 Bean的依赖注入分析"></a>3.5 Bean的依赖注入分析</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>目前UserService实例和UserDao实例都存在于Spring容器中，当前的做法是在容器外部获得UserService实例和UserDao实例，然后在程序中进行结合。</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240215211213442.png" alt="image-20240215211213442"></p><p>因为UserService和UserDao都在Spring容器，而最终程序直接使用的是UserService，所以可以在Spring容器中，将UserDao设置到UserService内部。</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240215211921957.png" alt="image-20240215211921957"></p><h3 id="3-6-Bean的依赖注入概念"><a href="#3-6-Bean的依赖注入概念" class="headerlink" title="3.6 Bean的依赖注入概念"></a>3.6 Bean的依赖注入概念</h3><p>依赖注入（<code>Dependency Injection</code>）：它是Spring框架核心IOC的具体现实。</p><p>在编写程序时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。</p><p>IOC解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p><p>那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring来维护了。</p><p>简单的说，就是坐等框架把持久化层对象传入业务层，而不用我们自己去获取。</p><h3 id="3-7-Bean的依赖注入方式"><a href="#3-7-Bean的依赖注入方式" class="headerlink" title="3.7 Bean的依赖注入方式"></a>3.7 Bean的依赖注入方式</h3><ul><li><code>构造方法</code></li><li><code>set方法</code></li></ul><p>1）set方法注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​ P命名空间注入本质也是set方法注入，主要体现在配置文件中，如下：</p><p>​ 首先，需要引入P命名空间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br></pre></td></tr></table></figure><p>​ 其次，需要修改注入方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.service.impl.UserServiceImpl&quot;</span> <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>2）构造方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-8-Bean的依赖注入的数据类型"><a href="#3-8-Bean的依赖注入的数据类型" class="headerlink" title="3.8 Bean的依赖注入的数据类型"></a>3.8 Bean的依赖注入的数据类型</h3><p>除了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。</p><p>注入数据的三种数据类型</p><ul><li><code>普通数据类型</code></li><li><code>引用数据类型</code></li><li><code>集合数据类型</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;strList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>ppp1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>ppp2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p3&quot;</span>&gt;</span>ppp3<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.domain.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tom&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.domain.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lucy&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tianjin&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-9-引入其他配置文件（分模块开发）"><a href="#3-9-引入其他配置文件（分模块开发）" class="headerlink" title="3.9 引入其他配置文件（分模块开发）"></a>3.9 引入其他配置文件（分模块开发）</h3><p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-xxx.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-10-知识要点"><a href="#3-10-知识要点" class="headerlink" title="3.10 知识要点"></a>3.10 知识要点</h3><p>Spring的重点配置</p><p><bean>标签</p><p>​ id属性：在容器中Bean实例的唯一标识，不允许重复</p><p>​ class属性：要实例化的Bean的全限定名</p><p>​ scope属性：Bean的作用范围，常用是Singleton（默认）和prototype</p><p>​        <property>标签：属性注入</p><p>​ name属性：属性名称</p><p>​ value属性：注入的普通属性值</p><p>​ ref属性：注入的对象引用值</p><p>​                &lt; list &gt;标签</p><p>​                &lt; map &gt;标签</p><p>​                &lt; properties &gt;标签</p><p>​        <constructor-arg>标签</p><p>&lt; import &gt;标签：导入其他的Spring的分文件</p><h2 id="4-Spring相关API"><a href="#4-Spring相关API" class="headerlink" title="4. Spring相关API"></a>4. Spring相关API</h2><h3 id="4-1-ApplicationContext的继承体系"><a href="#4-1-ApplicationContext的继承体系" class="headerlink" title="4.1 ApplicationContext的继承体系"></a>4.1 ApplicationContext的继承体系</h3><p><code>applicationContext</code>：接口类型，代表应用上下文，可以通过其实例获取得到Spring容器中的Bean 对象</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240216162617377.png" alt="image-20240216162617377" style="zoom:50%;" /></p><h3 id="4-2-ApplicationContext的实现类"><a href="#4-2-ApplicationContext的实现类" class="headerlink" title="4.2 ApplicationContext的实现类"></a>4.2 ApplicationContext的实现类</h3><p>1）<code>ClassPathXmlApplicationContext</code></p><p>​ 它是从类的根路径下加载配置文件推荐使用这种</p><p>2）<code>FileSystemXmlApplicationContext</code></p><p>​ 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</p><p>3）<code>AnnotationConfigApplicationContext</code></p><p>​ 当使用注解配置容器对象时，需要使用此类来创建spring容器。它用来读取注解。</p><h3 id="4-3-getBean-方法使用"><a href="#4-3-getBean-方法使用" class="headerlink" title="4.3 getBean()方法使用"></a>4.3 getBean()方法使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getBeanFactory().getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.assertBeanFactoryActive();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getBeanFactory().getBean(requiredType);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span>     <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) app.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> app.getBean(UserService.class);</span><br></pre></td></tr></table></figure><p>其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，这此方法会报错。</p><h3 id="4-4-知识要点"><a href="#4-4-知识要点" class="headerlink" title="4.4 知识要点"></a>4.4 知识要点</h3><p><code>Spring的重点API</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClasspathXmlApplicationContext</span>(<span class="string">&quot;xml文件&quot;</span>);</span><br><span class="line">app.getBean(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">app.getBean(Class);</span><br></pre></td></tr></table></figure><h2 id="5-Spring配置数据源"><a href="#5-Spring配置数据源" class="headerlink" title="5. Spring配置数据源"></a>5. Spring配置数据源</h2><h3 id="5-1-数据源（连接池）的作用"><a href="#5-1-数据源（连接池）的作用" class="headerlink" title="5.1 数据源（连接池）的作用"></a>5.1 数据源（连接池）的作用</h3><ul><li>数据源（连接池）是提高程序性能而出现的</li><li>事先实例化数据源，初始化部分连接资源</li><li>使用连接资源时从数据源中获取</li><li>使用完毕后将连接资源归还给数据源</li></ul><p>常见的数据源(连接池): <code>DBCP</code>、<code>C3P0</code>、<code>BoneCP</code>、<code>Druid</code>等</p><h3 id="5-2-数据源的开发步骤"><a href="#5-2-数据源的开发步骤" class="headerlink" title="5.2 数据源的开发步骤"></a>5.2 数据源的开发步骤</h3><p>① 导入数据源的坐标和数据源驱动坐标</p><p>② 创建数据源对象</p><p>③ 设置数据源的基本连接数据</p><h3 id="5-3-数据源的手动创建"><a href="#5-3-数据源的手动创建" class="headerlink" title="5.3 数据源的手动创建"></a>5.3 数据源的手动创建</h3><p>1）手动创建 c3p0 数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//测试手动创建 c3p0 数据源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        dataSource.setDriverClass(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">        dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;QY1989424334&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2）手动创建 druid 数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//测试手动创建 druid 数据源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;QY1989424334&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        dataSource.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3）手动创建 c3p0 数据源(加载properties配置文件)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//测试手动创建 c3p0 数据源(加载properties配置文件)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">rb</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;jdbc&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> rb.getString(<span class="string">&quot;jdbc.driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> rb.getString(<span class="string">&quot;jdbc.url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> rb.getString(<span class="string">&quot;jdbc.username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> rb.getString(<span class="string">&quot;jdbc.password&quot;</span>);</span><br><span class="line">        <span class="comment">//创建数据源对象 设置连接参数</span></span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        dataSource.setDriverClass(driver);</span><br><span class="line">        dataSource.setJdbcUrl(url);</span><br><span class="line">        dataSource.setUser(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-Spring配置数据源"><a href="#5-4-Spring配置数据源" class="headerlink" title="5.4 Spring配置数据源"></a>5.4 Spring配置数据源</h3><p>可以将DataSource的创建权交由Spring容器去完成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;QY1989424334&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//测试Spring容器产生数据源对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//DataSources dataSource =(DataSources) app.getBean(&quot;dataSource&quot;);</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> app.getBean(DataSource.class);</span><br><span class="line">        Connection connection=dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-抽取jdbc配置文件"><a href="#5-5-抽取jdbc配置文件" class="headerlink" title="5.5 抽取jdbc配置文件"></a>5.5 抽取jdbc配置文件</h3><p>applicationContext.xml加载jdbc.properties配置文件获得连接信息。</p><p>首先，需要引入context命名空间和约束路径：</p><ul><li><p>命名空间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://wwww.springframework.org/schema/context&quot;</span><br></pre></td></tr></table></figure></li><li><p>约束路径：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载外部的properties文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h3><p><code>Spring容器加载properties文件</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;xx.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;key&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-Spring注解开发"><a href="#6-Spring注解开发" class="headerlink" title="6.Spring注解开发"></a>6.Spring注解开发</h2><h3 id="6-1-Spring原始注解"><a href="#6-1-Spring原始注解" class="headerlink" title="6.1 Spring原始注解"></a>6.1 Spring原始注解</h3><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。</p><p>Spring原始注解主要是替代<Bean>的配置</p><div class="table-container"><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>使用在类上用于实例化Bean</td></tr><tr><td>@Controller</td><td>使用在web层类上用于实例化Bean</td></tr><tr><td>@Service</td><td>使用在service层类上用于实例化Bean</td></tr><tr><td>@Repository</td><td>使用在dao类层上用于实例化Bean</td></tr><tr><td>@Autowired</td><td>使用在字段上用于根据类型注入依赖</td></tr><tr><td>@Qualifier</td><td>结合@Autowired一起使用用于根据名称进行依赖注入</td></tr><tr><td>@Resource</td><td>相当于@Autowired+@Qualifier，按照名称进行注入</td></tr><tr><td>@Value</td><td>注入普通属性</td></tr><tr><td>@Scope</td><td>标注Bean的作用范围</td></tr><tr><td>@PostConstruct</td><td>使用在方法上标注该方法是Bean的初始化方法</td></tr><tr><td>@PreDestroy</td><td>使用在方法上标注方法是Bean的销毁方法</td></tr></tbody></table></div><p><code>注意：</code></p><p>使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.recallstudy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-Spring新注解"><a href="#6-2-Spring新注解" class="headerlink" title="6.2 Spring新注解"></a>6.2 Spring新注解</h3><p>使用上面的注解还不能全部代替xml配置文件，还需要使用注解替代的配置如下：</p><ul><li>非自定义的Bean的配置：<bean></li><li>加载properties文件的配置：<context:property-placeholder ></li><li>组件扫描的配置：<context:component-scan ></li><li>引入其他文件：<import></li></ul><div class="table-container"><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>用于指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解</td></tr><tr><td>@ComponentScan</td><td>用于指定Spring在初始化容器时要扫描的包。作用和在Spring的xml配置文件中的<context:component-scan base-package="com.recallstudy"/>一样</td></tr><tr><td>@Bean</td><td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td></tr><tr><td>@PropertySource</td><td>用于加载.properties文件中的配置</td></tr><tr><td>@Import</td><td>用于导入其他配置类</td></tr></tbody></table></div><ol><li><p>DataSourceConfiguration.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标志该类是Spring的核心配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//&lt;context:component-scan base-package=&quot;com.recallstudy&quot;&gt;&lt;/context:component-scan&gt;</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.recallstudy&quot;)</span></span><br><span class="line"><span class="comment">//&lt;import resource=&quot;&quot;/&gt;</span></span><br><span class="line"><span class="meta">@Import(&#123;DataSourceConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DataSourceConfiguration.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span>  <span class="comment">//Spring会将当前方法的返回值以指定名称注册到Spring容器中</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        dataSource.setDriverClass(driver);</span><br><span class="line">        dataSource.setJdbcUrl(url);</span><br><span class="line">        dataSource.setUser(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);</span><br></pre></td></tr></table></figure></li></ol><h2 id="7-Spring集成Junit"><a href="#7-Spring集成Junit" class="headerlink" title="7.Spring集成Junit"></a>7.Spring集成Junit</h2><h3 id="7-1-原始Junit测试Spring的问题"><a href="#7-1-原始Junit测试Spring的问题" class="headerlink" title="7.1 原始Junit测试Spring的问题"></a>7.1 原始Junit测试Spring的问题</h3><p>在测试类中，每个测试方法都有以下两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"><span class="type">IAccountService</span> <span class="variable">as</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;accountService&quot;</span>,IAccountService.class);</span><br></pre></td></tr></table></figure><p>这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。</p><h3 id="7-2-上述问题解决思路"><a href="#7-2-上述问题解决思路" class="headerlink" title="7.2 上述问题解决思路"></a>7.2 上述问题解决思路</h3><ul><li>让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它</li><li>将需要进行测试Bean直接在测试类中进行注入</li></ul><h3 id="7-3-Spring集成Junit步骤"><a href="#7-3-Spring集成Junit步骤" class="headerlink" title="7.3 Spring集成Junit步骤"></a>7.3 Spring集成Junit步骤</h3><p>① 导入spring集成Junit的坐标</p><p>② 使用@Runwith注解替换原来的运行期</p><p>③ 使用@ContextConfiguration指定配置文件或配置类</p><p>④ 使用@Autowired注入需要测试的对象</p><p>⑤ 创建测试方法进行测试</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        userService.save();</span><br><span class="line">        System.out.println(dataSource.getConnection());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Spring集成web环境"><a href="#8-Spring集成web环境" class="headerlink" title="8.Spring集成web环境"></a>8.Spring集成web环境</h2><h3 id="8-1-ApplicationContext应用上下文获取方式"><a href="#8-1-ApplicationContext应用上下文获取方式" class="headerlink" title="8.1 ApplicationContext应用上下文获取方式"></a>8.1 ApplicationContext应用上下文获取方式</h3><p>应用上下文对象是通过<code>new ClasspathXmlApplicationContext(spring配置文件)</code>方式获取的，但是每次从容器中获得Bean时都要编写<code>newClasspathXmlApplicationContext(spring配置文件)</code>，这样的弊端是配置文件加载多次，应用上下文对象创建对次。</p><p>在Web项目中，可以使用<code>ServletContextListener</code>监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象<code>ApplicationContext</code>，在将其存储到最大的域<code>servletContext</code>域中，这样就可以在任意位置从域中获得应用上下文<code>ApplicationContext</code>对象了。</p><p>ContextLoaderListener.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> ContextLoaderListener <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> servletContextEvent.getServletContext();</span><br><span class="line">        <span class="comment">//读取web.xml中的全局参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextConfigLocation</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;contextConfigLocation&quot;</span>);</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(contextConfigLocation);</span><br><span class="line">        <span class="comment">//将Spring的应用上下文对象存储到ServletContext域中</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;app&quot;</span>, app);</span><br><span class="line">        System.out.println(<span class="string">&quot;spring容器创建完毕...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局初始化参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.recallstudy.listener.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>UserServlet.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="comment">//ApplicationContext app = (ApplicationContext) servletContext.getAttribute(&quot;app&quot;);</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> app.getBean(UserService.class);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebApplicationContextUtils.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebApplicationContextUtils</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title function_">getWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (ApplicationContext) servletContext.getAttribute(<span class="string">&quot;app&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-Spring提供获取应用上下文的工具"><a href="#8-2-Spring提供获取应用上下文的工具" class="headerlink" title="8.2 Spring提供获取应用上下文的工具"></a>8.2 Spring提供获取应用上下文的工具</h3><p>Spring提供了一个监听器<code>ContextLoaderListener</code>就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到<code>ServletContext</code>域中，提供了一个客户端工具<code>WebApplicationContextUtils</code></p><p>供使用者获得应用上下文对象。</p><p>所以我们需要做的只有两件事：</p><p>① 在<code>web.xml</code>中配置<code>ContextLoaderListener</code>监听器（导入spring-web坐标）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局初始化参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>② 使用<code>WebApplicationContextUtils</code>获得应用上下文对象<code>ApplicationContext</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br></pre></td></tr></table></figure><h3 id="8-3-导入Spring集成web的坐标"><a href="#8-3-导入Spring集成web的坐标" class="headerlink" title="8.3 导入Spring集成web的坐标"></a>8.3 导入Spring集成web的坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-4-配置ContextLoaderListener监听器"><a href="#8-4-配置ContextLoaderListener监听器" class="headerlink" title="8.4 配置ContextLoaderListener监听器"></a>8.4 配置ContextLoaderListener监听器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局初始化参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-5通过工具获得应用上下文对象"><a href="#8-5通过工具获得应用上下文对象" class="headerlink" title="8.5通过工具获得应用上下文对象"></a>8.5通过工具获得应用上下文对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="8-6-知识要点"><a href="#8-6-知识要点" class="headerlink" title="8.6 知识要点"></a>8.6 知识要点</h3><p><code>Spring集成web环境步骤</code></p><p>① 配置ContextLoaderListener监听器</p><p>② 使用WebApplicationContextUtils获得应用上下文</p><h2 id="9-SpringMVC简介"><a href="#9-SpringMVC简介" class="headerlink" title="9.SpringMVC简介"></a>9.SpringMVC简介</h2><h3 id="9-1-SpringMVC概述"><a href="#9-1-SpringMVC概述" class="headerlink" title="9.1 SpringMVC概述"></a>9.1 SpringMVC概述</h3><p><code>SpringMVC</code>是一种基本Java的实现<code>MVC设计模型</code>的请求驱动类型的轻量级<code>Web框架</code>，属于<code>SpringFrameWork</code>的后续产品，已经融合在Spring<br>Web Flow中。</p><p>SpringMVC已经成为目前最主流的MVC框架之一，并且随着Spring3.0的发布，全面超越Structs2，成为最优秀的MVC框架。它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持<code>RESTful</code>编程风格的请求。</p><h3 id="9-2-SpringMVC快速入门"><a href="#9-2-SpringMVC快速入门" class="headerlink" title="9.2 SpringMVC快速入门"></a>9.2 SpringMVC快速入门</h3><p>要求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。</p><p>开发步骤：</p><p>① 导入SpringMVC相关坐标</p><p>② 配置SpringMVC核心控制器DispatcherServlet</p><p>③ 创建Controller类和视图页面</p><p>④ 使用注解配置Controller类中业务方法的映射地址</p><p>⑤ 配置SpringMVC核心文件spring-mvc.xml</p><p>⑥ 客户端发起请求测试</p><h3 id="9-3-SpringMVC流程图示"><a href="#9-3-SpringMVC流程图示" class="headerlink" title="9.3 SpringMVC流程图示"></a>9.3 SpringMVC流程图示</h3><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240217211853259.png" alt="image-20240217211853259"></p><h3 id="9-4-知识要点"><a href="#9-4-知识要点" class="headerlink" title="9.4 知识要点"></a>9.4 知识要点</h3><p><code>SpringMVC的开发步骤</code></p><p>① 导入SpringMVC相关坐标</p><p>② 配置SpringMVC核心控制器DispatcherServlet</p><p>③ 创建Controller类是视图页面</p><p>④ 使用注解配置Controller业务方法的映射地址</p><p>⑤ 配置SpringMVC核心文件spring-mvc.xml</p><p>⑥ 客户端发起请求测试</p><h2 id="10-SpringMVC组件解析"><a href="#10-SpringMVC组件解析" class="headerlink" title="10.SpringMVC组件解析"></a>10.SpringMVC组件解析</h2><h3 id="10-1-SpringMVC的执行流程"><a href="#10-1-SpringMVC的执行流程" class="headerlink" title="10.1 SpringMVC的执行流程"></a>10.1 SpringMVC的执行流程</h3><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240217213024311.png" alt="image-20240217213024311"></p><p>① 用户发送请求至前端控制器DispatcherServlet</p><p>② DispatcherServlet收到请求调用HandlerMapping处理器映射器</p><p>③ 处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器对象及处理器拦截器（如果有则生成）一并返回给DispatcherServlet</p><p>④ DispatcherServlet调用HandlerAdapter处理器适配器</p><p>⑤ HandlerAdapter经过适配器调用具体的处理器（Controller，也叫后端控制器）</p><p>⑥ Controller执行完成返回ModelAndView</p><p>⑦ HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</p><p>⑧ DispatcherServlet将ModelAndView传给ViewResolver视图解析器</p><p>⑨ ViewResolver解析后返回具体View</p><p>⑩ DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户</p><h3 id="10-2-SpringMVC注解解析"><a href="#10-2-SpringMVC注解解析" class="headerlink" title="10.2 SpringMVC注解解析"></a>10.2 SpringMVC注解解析</h3><p><code>@RequestMapping</code></p><p>作用：用于建立请求URL和处理请求方法之间的对应关系</p><p>位置：</p><ul><li>类上，请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录</li><li>方法上，请求URL的第二级访问目录，与类的使用@RequestMapping标注的一级目录一起组成访问虚拟路径</li></ul><p>属性：</p><ul><li><code>value</code>：拥有指定请求的URL。它和path属性的作用是一样的</li><li><code>method</code>：用于指定请求的方式</li><li><code>params</code>：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样</li></ul><p>例如：</p><ul><li><code>params = &#123;&quot;accountName&quot;&#125;</code>，表示请求参数必须有accountName</li><li><code>params = &#123;&quot;moneny!100&quot;&#125;</code>，表示请求参数中money不能是100</li></ul><h3 id="10-3-SpringMVC注解解析"><a href="#10-3-SpringMVC注解解析" class="headerlink" title="10.3 SpringMVC注解解析"></a>10.3 SpringMVC注解解析</h3><ol><li><p><code>mvc命名空间引入</code></p><p>命名空间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br></pre></td></tr></table></figure><p>约束地址：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">http://www.springframework.org/schema/mvc</span><br><span class="line">http://www.springframework.org/schema/mvc/spring-mvc.xsd</span><br></pre></td></tr></table></figure></li><li><p><code>组件扫描</code></p><p>SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;<br>context:component-scan base-package=”com.recallstudy.controller”/&gt;进行组件扫描。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Controller组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.recallstudy&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="10-4-SpringMVC的XML配置解析"><a href="#10-4-SpringMVC的XML配置解析" class="headerlink" title="10.4 SpringMVC的XML配置解析"></a>10.4 SpringMVC的XML配置解析</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置内部资源视图解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /jsp/success.jsp --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/jsp/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="10-5-知识要点"><a href="#10-5-知识要点" class="headerlink" title="10.5 知识要点"></a>10.5 知识要点</h3><p><code>SpringMVC的相关组件</code></p><ul><li>前端控制器：DispatcherServlet</li><li>处理器映射器：HandlerMapping</li><li>处理器适配器：HandlerAdapter</li><li>处理器：Handler</li><li>视图解析器：ViewResolver</li><li>视图：View</li></ul><p><code>SpringMVC的注解和配置</code></p><ul><li><p>请求映射注解：@RequestMapping</p></li><li><p>视图解析器配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REDIRECT_URL_PREFIX = &quot;redirect:&quot;</span><br><span class="line">FORWARD_URL_PREFIX = &quot;forward:&quot;</span><br><span class="line">prefix = &quot;&quot;;</span><br><span class="line">suffix = &quot;&quot;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-SpringMVC的数据响应"><a href="#11-SpringMVC的数据响应" class="headerlink" title="11.SpringMVC的数据响应"></a>11.SpringMVC的数据响应</h2><h3 id="11-1-SpringMVC的数据响应方式"><a href="#11-1-SpringMVC的数据响应方式" class="headerlink" title="11.1 SpringMVC的数据响应方式"></a>11.1 SpringMVC的数据响应方式</h3><p>1）页面跳转</p><ul><li>直接返回字符串</li><li>通过ModelAndView对象返回</li></ul><p>2）回写数据</p><ul><li>直接返回字符串</li><li>返回对象或集合</li></ul><h3 id="11-2-页面跳转"><a href="#11-2-页面跳转" class="headerlink" title="11.2 页面跳转"></a>11.2 页面跳转</h3><ol><li><p>返回字符串形式</p><p>直接返回字符串：此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">quickMethod</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>转发资源地址：<code>/WEB-INF/views/index.jsp</code></p><p>返回带有前缀的字符串：</p><p>转发：<code>forward:/WEB-INF/views/index.jsp</code></p><p>重定向：<code>redirect:/index.jsp</code></p></li><li><p>返回ModelAndView对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">save3</span><span class="params">(ModelAndView modelAndView)</span>&#123;</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="11-3-回写数据"><a href="#11-3-回写数据" class="headerlink" title="11.3 回写数据"></a>11.3 回写数据</h3><ol><li><p>直接返回字符串</p><p>Web集基础阶段，客户端访问服务器端，如果想直接回写字符串作为响应体返回的话，只需要使用response.getWriter().print(“hello<br>world”)即可。</p><p>在Controller中回写字符串：</p><p>① 通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”)回写数据，此时不需要视图跳转，业务方法返回值为void。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick6&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save6</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;hello recall&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>② 将需要回写的字符串直接返回，但此时需要通过<code>@ResponseBody</code>注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick9&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save9</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">//使用json的转换工具将对象转换成json格式字符串再返回</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/quick8&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save8</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;zhangsan\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/quick7&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span> <span class="comment">//告知SpringMVC框架 不进行视图跳转 直接进行数据响应</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save7</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello recall&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>返回对象或集合</p><p>通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置处理器映射器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在方法上添加<code>@ResponseBody</code>就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mvc的注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在SpringMVC的各个组件中，<code>处理器映射器、处理器适配器、视图解析器</code>称为SpringMVC的三大组件。使用&lt; mvc:<br>annotation-driven/ &gt;<br>自动加载RequestMappingHandlerMapping（处理映射器）和RequestMappingHandlerAdapter（处理适配器），可用在Spring-xml.xml配置文件中使用&lt;<br>mvc:annotation-driven/ &gt;替代注解处理器和适配器的配置。同时使用&lt; mvc:annotation-driven/ &gt;<br>默认底层就会集成jackson进行对象或集合的json格式字符串的转换。</p></li></ol><h3 id="11-4-知识要点"><a href="#11-4-知识要点" class="headerlink" title="11.4 知识要点"></a>11.4 知识要点</h3><p><code>SpringMVC的数据响应方式</code></p><p>1）页面跳转</p><ul><li>直接返回字符串</li><li>通过ModelAndView对象返回</li></ul><p>2）回写数据</p><ul><li>直接返回字符串</li><li>返回对象或集合</li></ul><h2 id="12-SpringMVC获得请求数据"><a href="#12-SpringMVC获得请求数据" class="headerlink" title="12.SpringMVC获得请求数据"></a>12.SpringMVC获得请求数据</h2><h3 id="12-1-获得请求参数"><a href="#12-1-获得请求参数" class="headerlink" title="12.1 获得请求参数"></a>12.1 获得请求参数</h3><p>客户端请求参数的格式是：<code>name=value&amp;name=value... ...</code></p><p>服务端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数：</p><ul><li>基本类型参数</li><li>POJO类型参数</li><li>数组类型参数</li><li>集合类型参数</li></ul><h3 id="12-2-获得基本类型参数"><a href="#12-2-获得基本类型参数" class="headerlink" title="12.2 获得基本类型参数"></a>12.2 获得基本类型参数</h3><p>Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。</p><p><a href="http://localhost:8080/recall_springmvc/quick9?username=zhangsan&amp;age=12">http://localhost:8080/recall_springmvc/quick9?username=zhangsan&amp;age=12</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick9&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod9</span><span class="params">(String username,<span class="type">int</span> age)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">  System.out.println(username);</span><br><span class="line">  System.out.println(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-3-获得POJO类型参数"><a href="#12-3-获得POJO类型参数" class="headerlink" title="12.3 获得POJO类型参数"></a>12.3 获得POJO类型参数</h3><p>Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。</p><p><a href="http://localhost:8080/recall_springmvc/quick9?username=zhangsan&amp;age=12">http://localhost:8080/recall_springmvc/quick9?username=zhangsan&amp;age=12</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick12&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save12</span><span class="params">(User user)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-获得数组类型参数"><a href="#12-4-获得数组类型参数" class="headerlink" title="12.4 获得数组类型参数"></a>12.4 获得数组类型参数</h3><p>Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。</p><p><a href="http://localhost:8080/recall_springmvc/quick11?strs=111&amp;strs=222&amp;strs=333">http://localhost:8080/recall_springmvc/quick11?strs=111&amp;strs=222&amp;strs=333</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick13&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save13</span><span class="params">(String[] strs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(Arrays.asList(strs));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="12-5-获得集合类型参数"><a href="#12-5-获得集合类型参数" class="headerlink" title="12.5 获得集合类型参数"></a>12.5 获得集合类型参数</h3><p>获的集合参数时，要将集合参数包装到一个POJO中才可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick14&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save14</span><span class="params">(VO vo)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(vo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用·POJO进行包装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//模拟数据</span></span><br><span class="line">    <span class="keyword">var</span> userList = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    userList.<span class="title function_">push</span>(&#123;<span class="attr">username</span>:<span class="string">&quot;zhangsan&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;);</span><br><span class="line">    userList.<span class="title function_">push</span>(&#123;<span class="attr">username</span>:<span class="string">&quot;lisi&quot;</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;);</span><br><span class="line"></span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick15&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(userList),</span><br><span class="line">    <span class="attr">contentType</span>:<span class="string">&quot;application/json;charset=utf-8&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick15&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save15</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; userList)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态资源访问的开启：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开放资源的访问--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/img/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/img/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="12-6-请求数据乱码问题"><a href="#12-6-请求数据乱码问题" class="headerlink" title="12.6 请求数据乱码问题"></a>12.6 请求数据乱码问题</h3><p>当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置全局过滤的filter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="12-7-参数绑定注解-requestParam"><a href="#12-7-参数绑定注解-requestParam" class="headerlink" title="12.7 参数绑定注解@requestParam"></a>12.7 参数绑定注解@requestParam</h3><p>当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick16&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save16</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解@RequestParam还有如下参数可以使用：</p><ul><li><code>value</code>：与请求参数名称</li><li><code>required</code>：此在指定的请求参数是否必须包含，默认是true，提交时如果没有此参数则报错</li><li><code>defaultValue</code>：当没有指定请求参数是，则使用指定的默认值赋值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick16&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save16</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;,required = false,defaultValue = &quot;recall&quot;)</span> String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-8-获得Restful风格的参数"><a href="#12-8-获得Restful风格的参数" class="headerlink" title="12.8 获得Restful风格的参数"></a>12.8 获得Restful风格的参数</h3><p><code>Restful</code>是一种软件<code>架构风格</code>、<code>设计风格</code>，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p><p><code>Restful</code>风格的请求是使用<code>”url+请求方式“</code>表示一次请求目的的，HTTP协议里面四个表示操作方式的动词如下：</p><ul><li>GET：用于获取资源</li><li>POST：用于新建资源</li><li>PUT：用于更新资源</li><li>DELETE：用于删除资源</li></ul><p>例如：</p><ul><li>/user/1 GET：得到 id = 1 的 user</li><li>/user/1 DELETE：删除 id = 1 的 user</li><li>/user/1 PUT：更新 id = 1 的 user</li><li>/user POST：新增 user</li></ul><p>上述url地址/user/1中的1就是要过得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick17/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save17</span><span class="params">(<span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-9-自定义类型转换器"><a href="#12-9-自定义类型转换器" class="headerlink" title="12.9 自定义类型转换器"></a>12.9 自定义类型转换器</h3><ul><li>SpringMVC默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。</li><li>但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。</li></ul><p>自定义类型转换器的开发步骤：</p><p>① 定义转换器类实现Converter接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, Date&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">convert</span><span class="params">(String dateStr)</span> &#123;</span><br><span class="line">        <span class="comment">//将日期的字符串转换成日期对象 返回</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = format.parse(dateStr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 在配置文件中声明转换器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明转化器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.converter.DateConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>③ 在&lt; annotation-driven &gt;中引用转换器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mvc的注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="12-10-获得Servlet相关API"><a href="#12-10-获得Servlet相关API" class="headerlink" title="12.10 获得Servlet相关API"></a>12.10 获得Servlet相关API</h3><p>SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下：</p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick19&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save19</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HttpSession session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(request);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    System.out.println(session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-11-获得请求头"><a href="#12-11-获得请求头" class="headerlink" title="12.11 获得请求头"></a>12.11 获得请求头</h3><ol><li><p>@RequestHeader</p><p>使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name)</p><p>@RequestHeader注解的属性如下：</p><ul><li><code>value</code>：请求头的名称</li><li><code>required</code>：是否必须携带此请求头</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick20&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save20</span><span class="params">(<span class="meta">@RequestHeader(value = &quot;User-Agent&quot;,required = false)</span> String user_agent)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(user_agent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@CookieValue</p><p>使用@CookieValue可以获得指定Cookie的值</p><p>@CookieValue注解的属性如下：</p><ul><li><code>Value</code>：指定cookie的名称</li><li><code>required</code>：是否必须携带此cookie</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick21&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save21</span><span class="params">(<span class="meta">@CookieValue(value = &quot;JSESSIONID&quot;)</span> String jsessionId)</span>&#123;</span><br><span class="line">    System.out.println(jsessionId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="12-12-文件上传"><a href="#12-12-文件上传" class="headerlink" title="12.12 文件上传"></a>12.12 文件上传</h3><ol><li><p>文件上传客户端三要素</p><ul><li>表单项type= “file”</li><li>表单的提交方式是post</li><li>表单的enctype属性是多部分表单形式，及enctype= “multipart/form-data”</li></ul></li><li><p>文件上传原理</p><ul><li>当form表单修改为多部分表单时，request.getParameter()将失效。</li><li>enctype= “application/x-www-form-urlencoded” 时，form表单的正文内容格式是：<code>key=value&amp;key=value&amp;key=value</code></li><li>当form表单的enctype取值为Multipart/form-dat时，请求正文内容就变成多部分形式：</li></ul><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240220170118368.png" alt="image-20240220170118368"></p></li></ol><h3 id="12-13-单文件上传步骤"><a href="#12-13-单文件上传步骤" class="headerlink" title="12.13 单文件上传步骤"></a>12.13 单文件上传步骤</h3><p>① 导入fileupload和io坐标</p><p>② 配置文件上传解析器</p><p>③ 编写文件上传代码</p><h3 id="12-14-单文件上传实现"><a href="#12-14-单文件上传实现" class="headerlink" title="12.14 单文件上传实现"></a>12.14 单文件上传实现</h3><p>① 导入fileupload和io坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>② 配置文件上传解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置文件上传解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;500000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>③ 编写上传文件代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick22&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save22</span><span class="params">(String username, MultipartFile uploadFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="comment">//获得上传文件的名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> uploadFile.getOriginalFilename();</span><br><span class="line">    uploadFile.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/zhouyu/Programming_ learning/Java/SSM/Spring/recallstudy_spring_mvc/src/main/webapp/upload/&quot;</span>+originalFilename));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-15-多文件上传实现"><a href="#12-15-多文件上传实现" class="headerlink" title="12.15 多文件上传实现"></a>12.15 多文件上传实现</h3><p>多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/quick23&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save23</span><span class="params">(String username, MultipartFile[] uploadFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile multipartFile : uploadFile) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> multipartFile.getOriginalFilename();</span><br><span class="line">        multipartFile.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/zhouyu/Programming_ learning/Java/SSM/Spring/recallstudy_spring_mvc/src/main/webapp/upload/&quot;</span> + originalFilename));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-16-知识要点"><a href="#12-16-知识要点" class="headerlink" title="12.16 知识要点"></a>12.16 知识要点</h3><p><code>MVC实现数据请求方式</code></p><ul><li>基本类型参数</li><li>POJO类型参数</li><li>数组类型参数</li><li>集合类型参数</li></ul><p><code>MVC获取数据细节</code></p><ul><li>中文乱码问题</li><li>@RequestParam 和 @PathVariable</li><li>自定义类型装换器</li><li>获得Servlet相关API</li><li>@RequestHeader 和 @CookieValue</li><li>文件上传</li></ul><h2 id="13-Spring-JdbcTemplate基本使用"><a href="#13-Spring-JdbcTemplate基本使用" class="headerlink" title="13.Spring JdbcTemplate基本使用"></a>13.Spring JdbcTemplate基本使用</h2><h3 id="13-1-JdbcTemplate概述"><a href="#13-1-JdbcTemplate概述" class="headerlink" title="13.1 JdbcTemplate概述"></a>13.1 JdbcTemplate概述</h3><p>它是spring框架中提供的一个对象，是对原始繁琐的Jdbc<br>API对象的简单封装。spring框架为我们提供了很多操作模版类。例如：操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。</p><h3 id="13-2-JdbcTemplate开发步骤"><a href="#13-2-JdbcTemplate开发步骤" class="headerlink" title="13.2 JdbcTemplate开发步骤"></a>13.2 JdbcTemplate开发步骤</h3><p>① 导入spring-jdbc和spring-tx坐标</p><p>② 创建数据库和实体</p><p>③ 创建jdbcTemplate对象</p><p>④ 执行数据库操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="13-3-Spring产生JdbcTemplate对象"><a href="#13-3-Spring产生JdbcTemplate对象" class="headerlink" title="13.3 Spring产生JdbcTemplate对象"></a>13.3 Spring产生JdbcTemplate对象</h3><p>我们可以将JdbcTemplate的创建权给Spring，将数据源DataSource的创建权也交给Spring，在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中，配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载jdbc.properties--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--数据源对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jdbc模版对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="13-4-JdbcTemplate的常用操作"><a href="#13-4-JdbcTemplate的常用操作" class="headerlink" title="13.4 JdbcTemplate的常用操作"></a>13.4 JdbcTemplate的常用操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateCRUD</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;update account set money = ? where name = ? &quot;</span>, <span class="number">10000</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> jdbcTemplate.update(<span class="string">&quot;delete from account where name = ? &quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryAll</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Account&gt; accountList = jdbcTemplate.query(<span class="string">&quot;select * from account&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class));</span><br><span class="line">    System.out.println(accountList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;select * from account where name = ?&quot;</span>, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Account&gt;(Account.class), <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    System.out.println(account);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;select count(*) from account&quot;</span>, Long.class);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-5-知识要点"><a href="#13-5-知识要点" class="headerlink" title="13.5 知识要点"></a>13.5 知识要点</h3><p>① 导入 spring-jdbc和spring-tx坐标</p><p>② 创建数据库表和实体</p><p>③ 创建JdbcTemplate对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">jdbcTemplate.setDataSource(dataSource);</span><br></pre></td></tr></table></figure><p>④ 执行数据库操作</p><p>​ 更新操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.update(sql,params)</span><br></pre></td></tr></table></figure><p>​ 查询操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.query(sql,Mapper,params)</span><br><span class="line">jdbcTemplate.queryForObject(sql,Mapper,params)</span><br></pre></td></tr></table></figure><h2 id="14-SpringMVC拦截器"><a href="#14-SpringMVC拦截器" class="headerlink" title="14.SpringMVC拦截器"></a>14.SpringMVC拦截器</h2><h3 id="14-1-拦截器（interceptor）的作用"><a href="#14-1-拦截器（interceptor）的作用" class="headerlink" title="14.1 拦截器（interceptor）的作用"></a>14.1 拦截器（interceptor）的作用</h3><p>Spring MVC的<code>拦截器</code>类似于Servlet 开发中的过滤器Filter，用于对处理器进行<code>预处理</code>和<code>后处理</code>。</p><p>将拦截器按一定的顺序结成一条链，这条链称为<code>拦截器链（InterceptorChain）</code>。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。</p><h3 id="14-2-拦截器和过滤器区别"><a href="#14-2-拦截器和过滤器区别" class="headerlink" title="14.2 拦截器和过滤器区别"></a>14.2 拦截器和过滤器区别</h3><div class="table-container"><table><thead><tr><th>区别</th><th>过滤器（Filter）</th><th>拦截器（Interceptor）</th></tr></thead><tbody><tr><td>使用范围</td><td>是Servlet规范中的一部分，任何Java Web工程都可以使用</td><td>是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能用</td></tr><tr><td>拦截范围</td><td>在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截</td><td>在<mvc:mapping path=""/>中配置了/** 之后，也可以多所有资源进行拦截，但是可以通过<mvc:exclude-mapping path=""/>标签排除不需要拦截的资源</td></tr></tbody></table></div><h3 id="14-3-拦截器的快速入门"><a href="#14-3-拦截器的快速入门" class="headerlink" title="14.3 拦截器的快速入门"></a>14.3 拦截器的快速入门</h3><p>自定义拦截器的步骤：</p><p>① 创建拦截器类实现HandlerInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在目标方法执行之前 执行</span></span><br><span class="line">preHandle</span><br><span class="line"><span class="comment">//在目标方法执行之后 视图对象返回之前执行</span></span><br><span class="line">postHandle</span><br><span class="line"><span class="comment">//在流程都执行完毕后 执行</span></span><br><span class="line">afterCompletion</span><br></pre></td></tr></table></figure><p>② 配置拦截器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对哪些资源执行拦截操作--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.interceptor.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>③ 测试拦截器的拦截效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//执行顺序</span><br><span class="line">MyInterceptor1 preHandle......</span><br><span class="line">MyInterceptor2 preHandle......</span><br><span class="line">目标资源执行......</span><br><span class="line">MyInterceptor2 postHandle......</span><br><span class="line">MyInterceptor1 postHandle......</span><br><span class="line">MyInterceptor2 afterCompletion......</span><br><span class="line">MyInterceptor1 afterCompletion......</span><br></pre></td></tr></table></figure><h3 id="14-4-拦截器方法说明"><a href="#14-4-拦截器方法说明" class="headerlink" title="14.4 拦截器方法说明"></a>14.4 拦截器方法说明</h3><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>preHandle()</td><td>方法将在请求处理之前进行调用，该方法的返回值是布尔值Boolean类型的，当它返回为false时，表示请求结束，后续的Interceptor和Controller都不会再执行；当放回值为true时就会继续调用下一个Interceptor的preHandle方法</td></tr><tr><td>postHandle()</td><td>该方法是在当前请求进行处理之后被调用，前提是preHandle方法的返回值为true 时才能被调用，且它会在DispatcherServlet进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller处理之后的ModelAndView对象进行操作</td></tr><tr><td>afterCompletion()</td><td>该方法将在整个请求结束之后，也就是在DispatcherServlet渲染了对应的视图之后执行，前提是preHandle方法的返回值为true时才能被调用</td></tr></tbody></table></div><h3 id="14-5-知识要点"><a href="#14-5-知识要点" class="headerlink" title="14.5 知识要点"></a>14.5 知识要点</h3><p>自定义拦截器步骤</p><p>① 创建拦截器类实现HandlerInterceptor接口</p><p>② 配置拦截器</p><p>③ 测试拦截器的拦截效果</p><h2 id="15-SpringMVC异常处理"><a href="#15-SpringMVC异常处理" class="headerlink" title="15.SpringMVC异常处理"></a>15.SpringMVC异常处理</h2><h3 id="15-1-异常处理的思路"><a href="#15-1-异常处理的思路" class="headerlink" title="15.1 异常处理的思路"></a>15.1 异常处理的思路</h3><p>系统中异常包括两类：<code>预期异常</code>和<code>运行时异常RuntimeException</code>，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p><p>系统的<code>Dao</code>、<code>Service</code>、<code>Controller</code>出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图：</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240222215949860.png" alt="image-20240222215949860"></p><h3 id="15-2-异常处理两种方式"><a href="#15-2-异常处理两种方式" class="headerlink" title="15.2 异常处理两种方式"></a>15.2 异常处理两种方式</h3><ul><li>使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver</li><li>实现Spring的异常处理接口HandlerExceptionResolve自定义自己的异常处理器</li></ul><h3 id="15-3-简单异常处理器SimpleMappingExceptionResolver"><a href="#15-3-简单异常处理器SimpleMappingExceptionResolver" class="headerlink" title="15.3 简单异常处理器SimpleMappingExceptionResolver"></a>15.3 简单异常处理器SimpleMappingExceptionResolver</h3><p>SpringMVC已经定义好了该类型装换器，在使用时可以根据项目情况进行相应异常与视图的映射配置</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240222222325229.png" alt="image-20240222222325229"></p><h3 id="15-4-自定义异常处理步骤"><a href="#15-4-自定义异常处理步骤" class="headerlink" title="15.4 自定义异常处理步骤"></a>15.4 自定义异常处理步骤</h3><p>① 创建异常处理器类实现HandlerExceptionResolver</p><p>② 配置异常处理器</p><p>③ 编写异常页面</p><p>④ 测试异常跳转</p><h3 id="15-5-知识要点"><a href="#15-5-知识要点" class="headerlink" title="15.5 知识要点"></a>15.5 知识要点</h3><p><code>异常处理方式</code></p><ul><li>配置简单异常处理器SimpleMappingExceptionResolver</li><li>自定义异常处理器</li></ul><p><code>自定义异常处理步骤</code></p><p>① 创建异常处理器类实现HandlerExceptionResolver</p><p>② 配置异常处理器</p><p>③ 编写异常页面</p><p>④ 测试异常跳转</p><h2 id="16-Spring的AOP简介"><a href="#16-Spring的AOP简介" class="headerlink" title="16.Spring的AOP简介"></a>16.Spring的AOP简介</h2><h3 id="16-1-什么是AOP"><a href="#16-1-什么是AOP" class="headerlink" title="16.1 什么是AOP"></a>16.1 什么是AOP</h3><p><code>AOP</code>为<code>A</code>spect <code>O</code>riented <code>P</code>rogramming的缩写，意思为<code>面向切面编程</code>，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p><p>AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生泛型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><h3 id="16-2-AOP的作用及其优势"><a href="#16-2-AOP的作用及其优势" class="headerlink" title="16.2 AOP的作用及其优势"></a>16.2 AOP的作用及其优势</h3><ul><li>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强</li><li>优势：减少重复代码，提高开发效率，并且便于维护</li></ul><h3 id="16-3-AOP的底层实现"><a href="#16-3-AOP的底层实现" class="headerlink" title="16.3 AOP的底层实现"></a>16.3 AOP的底层实现</h3><p>实际上，AOP的底层是通过Spring提供的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p><h3 id="16-4-AOP的动态代理技术"><a href="#16-4-AOP的动态代理技术" class="headerlink" title="16.4 AOP的动态代理技术"></a>16.4 AOP的动态代理技术</h3><p>常用的动态代理技术</p><ul><li>JDK代理：基于接口的动态代理技术</li><li>cglib代理：基于父类的动态代理技术</li></ul><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240223165331991.png" alt="image-20240223165331991"></p><p>JDK动态代理和CGlib动态代理的区别：</p><ol><li>JDK动态代理是面向接口的，只能增强实现类中存在的方法。CGlib是面向父类的，可以增强父类的所有方法</li><li>JDK得到的对象是JDK代理对象实例，而CGlib得到的对象是被代理对象的子类</li></ol><h3 id="16-5-JDK的动态代理"><a href="#16-5-JDK的动态代理" class="headerlink" title="16.5 JDK的动态代理"></a>16.5 JDK的动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="comment">//获得增强对象</span></span><br><span class="line">        <span class="type">Advance</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Advance</span>();</span><br><span class="line">        <span class="comment">//返回值 就是动态生成的代理对象</span></span><br><span class="line">        <span class="type">TargetInterface</span> <span class="variable">proxy</span> <span class="operator">=</span> (TargetInterface) Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">//目标对象类加载器</span></span><br><span class="line">                target.getClass().getInterfaces(), <span class="comment">//目标对象相同的接口字节码对象数组</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="comment">//调用代理对象的任何方法 实质执行的都是invoke方法</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">//前置增强</span></span><br><span class="line">                        advance.before();</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);<span class="comment">//执行目标方法</span></span><br><span class="line">                        <span class="comment">//后置增强</span></span><br><span class="line">                        advance.after();</span><br><span class="line">                        <span class="keyword">return</span> invoke;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//调用代理对象的方法</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-6-cglib的动态代理"><a href="#16-6-cglib的动态代理" class="headerlink" title="16.6 cglib的动态代理"></a>16.6 cglib的动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="comment">//获得增强对象</span></span><br><span class="line">        <span class="type">Advance</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Advance</span>();</span><br><span class="line">        <span class="comment">//返回值 就是动态生成的代理对象  基于cglib</span></span><br><span class="line">        <span class="comment">//1、创建增强器</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//2、设置父类（目标）</span></span><br><span class="line">        enhancer.setSuperclass(Target.class);</span><br><span class="line">        <span class="comment">//3、设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                advance.before();<span class="comment">//执行前置</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);<span class="comment">//执行目标</span></span><br><span class="line">                advance.after();<span class="comment">//执行后置</span></span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//4、创建代理对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target) enhancer.create();</span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-7-AOP-相关概念"><a href="#16-7-AOP-相关概念" class="headerlink" title="16.7 AOP 相关概念"></a>16.7 AOP 相关概念</h3><p>Spring的AOP实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。</p><p>AOP的常用相关术语：</p><ul><li>Target（目标对象）：代理的目标对象</li><li>Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类</li><li>Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中，这些点指的是方法，因为spring只支持方法类型的连接点</li><li>PointCut（切入点）：所谓切入点是指我们要对哪些Joinpoint进行拦截的定义</li><li>Advice（通知/增强）：所谓通知是指拦截到Joinpoint之后所要做的事情就是通知</li><li>Aspect（切面）：是切入点和通知（引介）的结合</li><li>Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入</li></ul><h3 id="16-8-AOP开发明确的事项"><a href="#16-8-AOP开发明确的事项" class="headerlink" title="16.8 AOP开发明确的事项"></a>16.8 AOP开发明确的事项</h3><ol><li><p>需要编写的内容</p><ul><li><p>编写核心业务代码（目标类的目标方法）</p></li><li><p>-编写切面类，切面类中有通知（增强功能方法）</p></li><li>在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合</li></ul></li><li><p>AOP技术实现的内容</p><p>Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p></li><li><p>AOP底层使用哪种代理方式</p><p>在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</p></li></ol><h3 id="16-9-知识要点"><a href="#16-9-知识要点" class="headerlink" title="16.9 知识要点"></a>16.9 知识要点</h3><ul><li><p>aop：面向切面编程</p></li><li><p>aop底层实现：基于JDK的动态代理和基于Cglib的动态代理</p></li><li><p>aop的重点概念：</p><p>Pointcut（切入点）：被增强的方法</p><p>Advice（通知/增强）：封装增强业务逻辑的方法</p><p>Aspect（切面）：切点+通知</p><p>Weaving（织入）：将切点与通知结合的过程</p></li><li><p>开发明确事项：</p><p>谁是切点（切点表达式配置）</p><p>谁是通知（切面类中的增强方法）</p><p>将切点和通知进行织入配置</p></li></ul><h2 id="17-基于XML的AOP开发"><a href="#17-基于XML的AOP开发" class="headerlink" title="17.基于XML的AOP开发"></a>17.基于XML的AOP开发</h2><h3 id="17-1-快速入门"><a href="#17-1-快速入门" class="headerlink" title="17.1 快速入门"></a>17.1 快速入门</h3><p>① 导入AOP相关坐标</p><p>② 创建目录接口和目标类（内部有切点）</p><p>③ 创建切面类（内部有增强方法）</p><p>④ 将目标类和切面类的对象创建权交给spring</p><p>⑤ 在 applicationContext.xml 中配置织入关系</p><p>⑥ 测试代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--目标对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.aop.Target&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--切面对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.aop.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置织入：告诉spring框架 哪些方法(切点)需要进行哪些增强(前置、后置...)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明切面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切面：切点+通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public void com.recallstudy.aop.Target.save())&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="17-2-XML配置AOP详解"><a href="#17-2-XML配置AOP详解" class="headerlink" title="17.2 XML配置AOP详解"></a>17.2 XML配置AOP详解</h3><ol><li><p>切点表达式的写法</p><p>表达式语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution([修饰符] 返回值类型 包名.类名.方法名(参数))</span><br></pre></td></tr></table></figure><ul><li>访问修饰符可以省略</li><li>返回值类型、包名、类名、方法名可以使用星号* 代表任意</li><li>包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</li><li>参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</li></ul><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execution(public void com.recallstudy.aop.Target.method())</span><br><span class="line">execution(void com.recallstudy.aop.Target.*(..))</span><br><span class="line">execution(* com.recallstudy.aop.*.*(..))</span><br><span class="line">execution(* com.recallstudy.aop..*.*(..))</span><br><span class="line">execution(* *..*.*(..))</span><br></pre></td></tr></table></figure></li><li><p>通知的类型</p><p>通知的配置语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:通知类型 method=&quot;切面类中方法名&quot; pointcut=&quot;切点表达式&quot;&gt;&lt;/aop:通知类型&gt;</span><br></pre></td></tr></table></figure><p>| 名称     | 标签                      | 说明                             |<br>|————|————————————-|————————————————|<br>| 前置通知   | &lt; aop:before &gt;          | 用于配置前置通知。指定增强的方法在切入点方法之前执行     |<br>| 后置通知   | &lt; aop:after-returning &gt; | 用于配置后置通知。指定增强的方法在切入点方法之后执行     |<br>| 环绕通知   | &lt; aop:around &gt;          | 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 |<br>| 异常抛出通知 | &lt; aop:throwing &gt;        | 用于配置异常抛出通知。指定增强的方法在出现异常时执行     |<br>| 最终通知   | &lt; aop:after &gt;           | 用于配置最终通知。无论增强方式执行是否有异常都会执行     |</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置织入：告诉spring框架 哪些方法(切点)需要进行哪些增强(前置、后置...)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切面：切点+通知--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void com.recallstudy.aop.Target.save())&quot;&gt;&lt;/aop:before&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(* com.recallstudy.aop.*.*(..))&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;aop:after-returning method=&quot;afterReturning&quot; pointcut=&quot;execution(* com.recallstudy.aop.*.*(..))&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.recallstudy.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.recallstudy.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.recallstudy.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>切点表达式的抽取</p><p>当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用pointcut-ref属性代替pointcut属性来引用抽取后的切点表达式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引用MyAspect的Bean位切面对象--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.recallstudy.aop.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="17-3-知识要点"><a href="#17-3-知识要点" class="headerlink" title="17.3 知识要点"></a>17.3 知识要点</h3><ul><li><p>aop织入的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;切面类&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;通知方法名称&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;切点表达式&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知</p></li><li><p>切点表达式的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution([修饰符])返回值类型 包名.类名.方法名(参数))</span><br></pre></td></tr></table></figure></li></ul><h2 id="18-基于注解的AOP开发"><a href="#18-基于注解的AOP开发" class="headerlink" title="18.基于注解的AOP开发"></a>18.基于注解的AOP开发</h2><h3 id="18-1-快速入门"><a href="#18-1-快速入门" class="headerlink" title="18.1 快速入门"></a>18.1 快速入门</h3><p>基于注解的aop开发步骤：</p><p>① 创建目标接口和目标类（内部有切点）</p><p>② 创建切面类（内部有增强方法）</p><p>③ 将目标类和切面类的对象创建权交给spring</p><p>④ 在切面类中使用注解配置织入关系</p><p>⑤ 在配置文件中开启组件扫描和AOP的自动代理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.recallstudy.anno&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--aop自动代理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>⑥ 测试</p><h3 id="18-2-注解配置AOP详解"><a href="#18-2-注解配置AOP详解" class="headerlink" title="18.2 注解配置AOP详解"></a>18.2 注解配置AOP详解</h3><ol><li><p>注解通知的类型</p><p>通知的配置语法：@通知注解(“切点表达式”)</p></li></ol><div class="table-container"><table><thead><tr><th>名称</th><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>前置通知</td><td>@Before</td><td>用于配置前置通知。指定增强的方法在切入点方法之前执行</td></tr><tr><td>后置通知</td><td>@AfterReturning</td><td>用于配置后置通知。指定增强的方法在切入点方法之后执行</td></tr><tr><td>环绕通知</td><td>@Around</td><td>用于配置环绕通知。指定增强的方法切入点方法之前和之后都执行</td></tr><tr><td>异常抛出通知</td><td>@AfterThrowing</td><td>用于配置异常抛出通知。指定增强的方法在出现异常时执行</td></tr><tr><td>最终通知</td><td>@After</td><td>用于配置最终通知。无论增强方式执行是否有异常都会执行</td></tr></tbody></table></div><ol><li><p>切点表达式的抽取</p><p>同xml配置aop一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在增强注解中进行引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义切点表达式</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.recallstudy.anno.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;环绕前增强......&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> pjp.proceed();<span class="comment">//切点方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;环绕后增强......&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After(&quot;MyAspect.pointcut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;最终增强......&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="18-3-知识要点"><a href="#18-3-知识要点" class="headerlink" title="18.3 知识要点"></a>18.3 知识要点</h3><ul><li><p>注解aop开发步骤</p><p>① 使用@Aspect标注切面类</p><p>② 使用@通知注解标注通知方法</p><p>③ 在配置文件中配置aop自动代理&lt; aop:aspectj-autoproxy /&gt;</p></li><li><p>通知注解类型</p></li></ul><div class="table-container"><table><thead><tr><th>名称</th><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>前置通知</td><td>@Before</td><td>用于配置前置通知。指定增强的方法在切入点方法之前执行</td></tr><tr><td>后置通知</td><td>@AfterReturning</td><td>用于配置后置通知。指定增强的方法在切入点方法之后执行</td></tr><tr><td>环绕通知</td><td>@Around</td><td>用于配置环绕通知。指定增强的方法切入点方法之前和之后都执行</td></tr><tr><td>异常抛出通知</td><td>@AfterThrowing</td><td>用于配置异常抛出通知。指定增强的方法在出现异常时执行</td></tr><tr><td>最终通知</td><td>@After</td><td>用于配置最终通知。无论增强方式执行是否有异常都会执行</td></tr></tbody></table></div><h2 id="19-编程式事务控制相关对象"><a href="#19-编程式事务控制相关对象" class="headerlink" title="19.编程式事务控制相关对象"></a>19.编程式事务控制相关对象</h2><h3 id="19-1-PlatformTransactionManager"><a href="#19-1-PlatformTransactionManager" class="headerlink" title="19.1 PlatformTransactionManager"></a>19.1 PlatformTransactionManager</h3><p>PlatformTransactionManager接口是spring的事务管理器，它里面提供了我们常用的操作事务的方法。</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>TransactionStatus<br>getTransaction(TransactionDefinition definition)</td><td>获取事务的状态信息</td></tr><tr><td>void commit (TransactionStatus status)</td><td>提交事务</td></tr><tr><td>void rollback(TransactionStatus status)</td><td>回滚事务</td></tr></tbody></table></div><p><code>注意：</code></p><p>PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：</p><p>Dao层技术是jdbc或mybatis时：org.springframework.jdbc.datasource.DataSourceTransactionManager</p><p>Dao层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager</p><h3 id="19-2-TransactionDefinition"><a href="#19-2-TransactionDefinition" class="headerlink" title="19.2 TransactionDefinition"></a>19.2 TransactionDefinition</h3><p>TransactionDefinition是事务的定义信息对象，里面有如下方法：</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getIsolationLevel()</td><td>获得事务的隔离级别</td></tr><tr><td>int getPropagationBehavior()</td><td>获得事务的传播行为</td></tr><tr><td>int getTimeout()</td><td>获得超时时间</td></tr><tr><td>boolean isReadOnly()</td><td>是否只读</td></tr></tbody></table></div><ol><li><p>事务隔离级别</p><p>设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。</p><ul><li>ISOLATION_DEFAULT</li><li>ISOLATION_READ_UNCOMMITTED</li><li>ISOLATION_READ_COMMITTED</li><li>ISOLATION_REPEATABLE_READ</li><li>ISOLATION_SERIALIZABLE</li></ul></li><li><p>事务传播行为</p><ul><li><code>REQUIRED</code>：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</li><li><code>SUPPORTS</code>：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</li><li>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常</li><li>REQUITERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。</li><li>NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li><li>NEVER：以非事务方式运行，如果当前存在事务，抛出异常</li><li>NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED类似的操作</li><li>超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置</li><li>是否只读：建议查询时设置为只读</li></ul></li></ol><h3 id="19-3-TransactionStatus"><a href="#19-3-TransactionStatus" class="headerlink" title="19.3 TransactionStatus"></a>19.3 TransactionStatus</h3><p>TransactionStatus接口提供的是事务具体的运行状态，方法介绍如下。</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean hasSavepoint()</td><td>是否存储回滚点</td></tr><tr><td>boolean isCompleted()</td><td>事务是否完成</td></tr><tr><td>boolean isNewTransaction()</td><td>是否是新事务</td></tr><tr><td>boolean isRollbackOnly()</td><td>事务是否回滚</td></tr></tbody></table></div><h3 id="19-4-知识要点"><a href="#19-4-知识要点" class="headerlink" title="19.4 知识要点"></a>19.4 知识要点</h3><p><code>编程式事务控制三大对象</code></p><ul><li>PlatformTransactionManager</li><li>TransactionDefinition</li><li>TransactionStatus</li></ul><h2 id="20-基于XML的声明式事务控制"><a href="#20-基于XML的声明式事务控制" class="headerlink" title="20.基于XML的声明式事务控制"></a>20.基于XML的声明式事务控制</h2><h3 id="20-1-什么是声明式事务控制"><a href="#20-1-什么是声明式事务控制" class="headerlink" title="20.1 什么是声明式事务控制"></a>20.1 什么是声明式事务控制</h3><p>Spring的声明式事务顾名思义就是<code>采用声明的方式来处理事务</code>。这里所说的声明，就是指在配置文件中声明，用在Spring配置文件中声明式的处理事务来代理代码式的处理事务。</p><p><strong>声明式事务处理的作用</strong></p><ul><li>事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可</li><li>在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</li></ul><p><code>注意</code>：Spring声明式事务控制底层就是AOP。</p><h3 id="20-2-声明式事务控制的实现"><a href="#20-2-声明式事务控制的实现" class="headerlink" title="20.2 声明式事务控制的实现"></a>20.2 声明式事务控制的实现</h3><p>声明式事务控制明确事项：</p><ul><li>谁是切点？</li><li>谁是通知？</li><li>配置切面？</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--通知 事务的增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置事务的属性信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置事务的aop织入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.recallstudy.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="20-3-切点方法的事务参数的配置"><a href="#20-3-切点方法的事务参数的配置" class="headerlink" title="20.3 切点方法的事务参数的配置"></a>20.3 切点方法的事务参数的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通知 事务的增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，&lt; tx:methode &gt;代表切点方法的事务参数的配置，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;-1&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>name：切点方法名称</li><li>isolation：事务的隔离级别</li><li>propogation：事务的传播行为</li><li>timeout：超时时间</li><li>read-only：是否只读</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--通知 事务的增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置事务的属性信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置事务的aop织入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.recallstudy.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="20-4-知识要点"><a href="#20-4-知识要点" class="headerlink" title="20.4 知识要点"></a>20.4 知识要点</h3><p><code>声明式事务控制的配置要点</code></p><ul><li>平台事务管理器配置</li><li>事务通知的配置</li><li>事务aop织入的配置</li></ul><h2 id="21-基于注解的声明式事务控制"><a href="#21-基于注解的声明式事务控制" class="headerlink" title="21.基于注解的声明式事务控制"></a>21.基于注解的声明式事务控制</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--事物的注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>① 使用@Transaction在需要进行事务控制的类或是方法上修饰，注解可用的属性同xml配置方式，例如隔离级别、传播行为等。</p><p>② 注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。</p><p>③ 使用在方法上，不同的方法可以采用不同的事务参数配置。</p><p>④ Xml配置文件中要开启事务的注解驱动&lt; tx:annotation-driven /&gt;</p><h2 id="22-MyBatis简介"><a href="#22-MyBatis简介" class="headerlink" title="22.MyBatis简介"></a>22.MyBatis简介</h2><h3 id="22-1-原始jdbc操作（查询数据）"><a href="#22-1-原始jdbc操作（查询数据）" class="headerlink" title="22.1 原始jdbc操作（查询数据）"></a>22.1 原始jdbc操作（查询数据）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//获得连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///test&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="comment">//获得statement</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;select id,username,password from user&quot;</span>);</span><br><span class="line"><span class="comment">//执行查询</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery();</span><br><span class="line"><span class="comment">//遍历结果集</span></span><br><span class="line"><span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">  <span class="comment">//封装实体</span></span><br><span class="line">  <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">  user.setId(resultSet.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">  user.setUsername(resultSet.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">  user.setPassword(resultSet.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">  <span class="comment">//user实体封装完毕</span></span><br><span class="line">  System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">resultSet.close();</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><p>原始jdbc操作（插入数据）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟实体对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">2</span>);</span><br><span class="line">user.setUsername(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">user.setPassword(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//获得连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///test&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="comment">//获得statement</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;insert into user(id,username,password) values(?,?,?)&quot;</span>);</span><br><span class="line"><span class="comment">//设置占位符</span></span><br><span class="line">statement.setInt(<span class="number">1</span>, user.getId());</span><br><span class="line">statement.setString(<span class="number">2</span>, user.getUsername());</span><br><span class="line">statement.setString(<span class="number">3</span>, user.getPassword());</span><br><span class="line"><span class="comment">//执行更新操作</span></span><br><span class="line">statement.executeUpdate();</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><h3 id="22-2-原始jdbc操作的分析"><a href="#22-2-原始jdbc操作的分析" class="headerlink" title="22.2 原始jdbc操作的分析"></a>22.2 原始jdbc操作的分析</h3><p>原始jdbc开发存在的问题如下：<br>① 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能</p><p>② sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p><p>③ 查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置</p><p>应对上述问题给出的解决方案：</p><p>① 使用数据库连接池初始化连接资源</p><p>② 将sql语句抽取到xml配置文件中</p><p>③ 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射</p><h3 id="22-3-什么是Mybatis"><a href="#22-3-什么是Mybatis" class="headerlink" title="22.3 什么是Mybatis"></a>22.3 什么是Mybatis</h3><ul><li>mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</li><li>mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</li><li>最后mybatis框架执行sql并将结果映射为java对象返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc<br>api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。</li></ul><h2 id="23-Mybatis的快速入门"><a href="#23-Mybatis的快速入门" class="headerlink" title="23.Mybatis的快速入门"></a>23.Mybatis的快速入门</h2><h3 id="23-1-Mybatis开发步骤"><a href="#23-1-Mybatis开发步骤" class="headerlink" title="23.1 Mybatis开发步骤"></a>23.1 Mybatis开发步骤</h3><p>MyBatis官网地址：<a href="http://www.mybatis.org/mybatis-3/">http://www.mybatis.org/mybatis-3/</a></p><p>MyBatis开发步骤：</p><p>① 添加MyBatis的坐标</p><p>② 创建user数据表</p><p>③ 编写User实体类</p><p>④ 编写映射文件UserMapper.xml</p><p>⑤ 编写核心文件SqlMapConfig.xml</p><p>⑥ 编写测试类</p><h3 id="23-2-环境搭建"><a href="#23-2-环境搭建" class="headerlink" title="23.2 环境搭建"></a>23.2 环境搭建</h3><ol><li><p>导入MyBatis的坐标和其他相关坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mysql驱动坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单元测试坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建user数据表</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240225154043881.png" alt="image-20240225154043881"></p></li><li><p>编写User实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="comment">//省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写UserMapper映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.recall.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写MyBatis核心文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--数据源环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&gt;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;QY1989424334&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--加载映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/recall/mapper/UserMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="23-3-编写测试代码"><a href="#23-3-编写测试代码" class="headerlink" title="23.3 编写测试代码"></a>23.3 编写测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources. getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得sqlSession工厂对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得sqlSession对象</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行sql语句</span></span><br><span class="line">List&lt;User&gt; userList = sqlSession.selectList (<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">System. out.println(userList);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure><h3 id="23-4-知识小结"><a href="#23-4-知识小结" class="headerlink" title="23.4 知识小结"></a>23.4 知识小结</h3><p><code>MyBatis开发步骤：</code></p><p>① 添加MyBatis的坐标</p><p>② 创建user数据表</p><p>③ 编写User实体类</p><p>④ 编写映射文件UserMapper.xml</p><p>⑤ 编写核心文件SqlMapConfig.xml</p><p>⑥ 编写测试类</p><h2 id="24-MyBatis的映射文件概述"><a href="#24-MyBatis的映射文件概述" class="headerlink" title="24.MyBatis的映射文件概述"></a>24.MyBatis的映射文件概述</h2><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240225164328602.png" alt="image-20240225164328602"></p><h2 id="25-MyBatis的增删改查操作"><a href="#25-MyBatis的增删改查操作" class="headerlink" title="25.MyBatis的增删改查操作"></a>25.MyBatis的增删改查操作</h2><h3 id="25-1-MyBatis的插入数据操作"><a href="#25-1-MyBatis的插入数据操作" class="headerlink" title="25.1 MyBatis的插入数据操作"></a>25.1 MyBatis的插入数据操作</h3><ol><li><p>编写UserMapper映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--插入操作--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.recall.domain.User&quot;</span>&gt;</span></span><br><span class="line">    insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写插入实体User的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获得session工厂对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line"><span class="comment">//获得session会话对象</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//执行操作  参数：namespace+id</span></span><br><span class="line">sqlSession.insert(<span class="string">&quot;userMapper.save&quot;</span>, user);</span><br><span class="line"><span class="comment">//mybatis执行更新操作  提交事务</span></span><br><span class="line">sqlSession.commit();</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure></li><li><p>插入操作注意问题</p><ul><li>插入语句使用insert标签</li><li>在映射文件中使用parameterType属性指定要插入的数据类型</li><li>Sql语句中使用#{实体属性名}方式引用实体中的属性值</li><li>插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象);</li><li>插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit()</li></ul></li></ol><h3 id="25-2-MyBatis的修改数据操作"><a href="#25-2-MyBatis的修改数据操作" class="headerlink" title="25.2 MyBatis的修改数据操作"></a>25.2 MyBatis的修改数据操作</h3><ol><li><p>编写UserMapper映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--修改操作--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.recall.domain.User&quot;</span>&gt;</span></span><br><span class="line">    update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写修改实体User的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获得session工厂对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line"><span class="comment">//获得session会话对象</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//执行操作  参数：namespace+id</span></span><br><span class="line">sqlSession.update(<span class="string">&quot;userMapper.update&quot;</span>, user);</span><br><span class="line"><span class="comment">//mybatis执行更新操作  提交事务</span></span><br><span class="line">sqlSession.commit();</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure></li><li><p>修改操作注意问题</p><ul><li>修改语句使用update标签</li><li>修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象);</li></ul></li></ol><h3 id="25-3-MyBatis的删除数据操作"><a href="#25-3-MyBatis的删除数据操作" class="headerlink" title="25.3 MyBatis的删除数据操作"></a>25.3 MyBatis的删除数据操作</h3><ol><li><p>编写UserMapper映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--删除操作--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">    delete from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写删除数据的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获得session工厂对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line"><span class="comment">//获得session会话对象</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//执行操作  参数：namespace+id</span></span><br><span class="line">sqlSession.delete(<span class="string">&quot;userMapper.delete&quot;</span>,<span class="number">7</span> );</span><br><span class="line"><span class="comment">//mybatis执行更新操作  提交事务</span></span><br><span class="line">sqlSession.commit();</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure></li><li><p>删除操作注意问题</p><ul><li>删除语句使用delete标签</li><li>Sql语句中使用#{任意字符串}方式引用传递的单个参数</li><li>删除操作使用的API是sqlSession.delete(“命名空间.id”,Object);</li></ul></li></ol><h3 id="25-4-知识小结"><a href="#25-4-知识小结" class="headerlink" title="25.4 知识小结"></a>25.4 知识小结</h3><p><code>增删改查映射配置与API</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--删除操作--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">    delete from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--修改操作--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.recall.domain.User&quot;</span>&gt;</span></span><br><span class="line">update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--插入操作--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.recall.domain.User&quot;</span>&gt;</span></span><br><span class="line">insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--查询操作--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.recall.domain.User&quot;</span>&gt;</span></span><br><span class="line">select *</span><br><span class="line">from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.delete(<span class="string">&quot;userMapper.delete&quot;</span>,<span class="number">7</span> );<span class="comment">//删除数据</span></span><br><span class="line">sqlSession.update(<span class="string">&quot;userMapper.update&quot;</span>, user);<span class="comment">//更新数据</span></span><br><span class="line">sqlSession.insert(<span class="string">&quot;userMapper.save&quot;</span>, user);<span class="comment">//插入数据</span></span><br><span class="line">List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);<span class="comment">//查询数据</span></span><br></pre></td></tr></table></figure><h2 id="26-MyBatis核心配置文件概述"><a href="#26-MyBatis核心配置文件概述" class="headerlink" title="26.MyBatis核心配置文件概述"></a>26.MyBatis核心配置文件概述</h2><h3 id="26-1-MyBatis核心配置文件层级关系"><a href="#26-1-MyBatis核心配置文件层级关系" class="headerlink" title="26.1 MyBatis核心配置文件层级关系"></a>26.1 MyBatis核心配置文件层级关系</h3><p>   <img src="https://images.shallowrecall.top/images/2024/2/image-20240225181327547.png" alt="image-20240225181327547"></p><h3 id="26-2-MyBatis常用配置解析"><a href="#26-2-MyBatis常用配置解析" class="headerlink" title="26.2 MyBatis常用配置解析"></a>26.2 MyBatis常用配置解析</h3><ol><li><p>environments标签</p><p>数据库环境的配置，支持多环境配置</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240225182150235.png" alt="image-20240225182150235"></p><p>其中，事务管理器（transactionManager）类型有两种：</p><ul><li>JDBC：这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。</li><li>MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。<br>默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置 为 false 来阻止它默认的关闭行为。</li></ul><p>其中，数据源（dataSource）类型有三种：</p><ul><li>UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。</li><li>POOLED ：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。</li><li>JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置 一个 JNDI<br>上下文的引用。</li></ul></li><li><p>mapper标签</p><p>该标签的作用是加载映射的，加载方式有如下几种：</p><ul><li><p>使用相对于类路径的资源引用，例如：</p><mapper resource="org/mybatis/builder/AuthorMapper.xml"/></li><li><p>使用完全限定资源定位符（URL），例如：</p><mapper url="file:///var/mappers/AuthorMapper.xml"/></li><li><p>使用映射器接口实现类的完全限定类名，例如：</p><mapper class="org.mybatis.builder.AuthorMapper"/></li><li><p>将包内的映射器接口实现全部注册为映射器，例如：</p><package name="org.mybatis.builder"/></li></ul></li><li><p>Properties标签</p><p>实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240225184225513.png" alt="image-20240225184225513"></p></li><li><p>typeAliases标签</p><p>类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240225184308693.png" alt="image-20240225184308693"></p><p>上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名</p></li></ol><div class="table-container"><table><thead><tr><th>别名</th><th>数据类型</th></tr></thead><tbody><tr><td>string</td><td>String</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>… …</td><td>… …</td></tr></tbody></table></div><h3 id="26-3-知识小结"><a href="#26-3-知识小结" class="headerlink" title="26.3 知识小结"></a>26.3 知识小结</h3><p><code>核心配置文件常用配置</code>：</p><ol><li><p>properties标签：该标签可以加载外部的properties文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过properties标签加载properties文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>typeAliases标签：设置类型别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.recall.domain.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>mappers标签：加载映射配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载映射文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/recall/mapper/UserMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>environments标签：数据源环境配置标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--数据源环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="27-MyBatis相应API"><a href="#27-MyBatis相应API" class="headerlink" title="27.MyBatis相应API"></a>27.MyBatis相应API</h2><h3 id="27-1-SqlSession工厂构建器SqlSessionFactoryBuilder"><a href="#27-1-SqlSession工厂构建器SqlSessionFactoryBuilder" class="headerlink" title="27.1 SqlSession工厂构建器SqlSessionFactoryBuilder"></a>27.1 SqlSession工厂构建器SqlSessionFactoryBuilder</h3><p>常用API：SqlSessionFactory build(InputStream inputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot; org/mybatis/builder/mybatis-config.xml&quot;</span> ;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>(); </span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build(inputStream);</span><br></pre></td></tr></table></figure><p>其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或 一个 web URL 中加载资源文件。</p><h3 id="27-2-SqlSession工厂对象SqlSessionFactory"><a href="#27-2-SqlSession工厂对象SqlSessionFactory" class="headerlink" title="27.2 SqlSession工厂对象SqlSessionFactory"></a>27.2 SqlSession工厂对象SqlSessionFactory</h3><p>SqlSessionFactory 有多个个方法创建 SqlSession 实例。常用的有如下两个：</p><div class="table-container"><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>openSession()</td><td>会默认开启一个事务，但事务不会自动提交，也就意味着需要手动提 交该事务，更新操作数据才会持久化到数据库中</td></tr><tr><td>openSession(boolean autoCommit)</td><td>参数为是否自动提交，如果设置为true，那么不需要手动提交事务</td></tr></tbody></table></div><h3 id="27-3-SqlSession会话对象"><a href="#27-3-SqlSession会话对象" class="headerlink" title="27.3 SqlSession会话对象"></a>27.3 SqlSession会话对象</h3><p>SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。<br>执行语句的方法主要有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span></span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement, Object parameter)</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement, Object parameter)</span></span><br></pre></td></tr></table></figure><p>操作业务的方法主要有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h2 id="28-MyBatis的Dao层实现"><a href="#28-MyBatis的Dao层实现" class="headerlink" title="28.MyBatis的Dao层实现"></a>28.MyBatis的Dao层实现</h2><h3 id="28-1-传统开发方式"><a href="#28-1-传统开发方式" class="headerlink" title="28.1 传统开发方式"></a>28.1 传统开发方式</h3><ol><li><p>编写UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写UserDaoImpl实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMapperImpl</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    List&lt;User&gt; userListt = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> userListt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试传统方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//创建dao层对象  当前dao层实现是手动编写的</span></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserMapperImpl</span>();</span><br><span class="line">    List&lt;User&gt; all = userMapper.findAll();</span><br><span class="line">    System.out.println(all);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="28-2-代理开发方式"><a href="#28-2-代理开发方式" class="headerlink" title="28.2 代理开发方式"></a>28.2 代理开发方式</h3><ol><li><p>采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper<br>接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接 口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p><p>Mapper 接口开发需要遵循以下规范：</p><ol><li>Mapper.xml文件中的namespace与mapper接口的全限定名相同</li><li>Mapper接口方法名和Mapper.xml中定义的每个statement的id相同</li><li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同</li><li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</li></ol></li><li><p>编写UserMapper接口</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240225201915699.png" alt="image-20240225201915699"></p></li><li><p>测试代理方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">List&lt;User&gt; all = mapper.findAll();</span><br><span class="line">System.out.println(all);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.findById(<span class="number">1</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line">sqlSession.close</span><br></pre></td></tr></table></figure></li></ol><h3 id="28-3-知识小结"><a href="#28-3-知识小结" class="headerlink" title="28.3 知识小结"></a>28.3 知识小结</h3><p><code>MyBatis的Dao层实现的两种方式</code>：</p><ul><li><p>手动对Dao进行实现：传统开发方式</p></li><li><p>代理方式对Dao进行实现：</p><p>UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240225201915699.png" alt="image-20240225201915699"></p></li></ul><h2 id="29-Mybatis映射文件深入"><a href="#29-Mybatis映射文件深入" class="headerlink" title="29.Mybatis映射文件深入"></a>29.Mybatis映射文件深入</h2><h3 id="29-1-动态sql语句"><a href="#29-1-动态sql语句" class="headerlink" title="29.1 动态sql语句"></a>29.1 动态sql语句</h3><ol><li><p>动态sql语句概述</p><p>Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的， 此时在前面的学习中我们的<br>SQL 就不能满足要求了。 参考的官方文档，描述如下：</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240225204551273.png" alt="image-20240225204551273"></p></li><li><p>动态SQL之<if></p><p>我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果 username<br>不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中 经常会碰到。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=0&quot;</span>&gt;</span></span><br><span class="line">            and id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username!=null&quot;</span>&gt;</span></span><br><span class="line">            and username=#&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password!=null&quot;</span>&gt;</span></span><br><span class="line">            and password=#&#123;password&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>动态 SQL 之<foreach></p><p>循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>foreach标签的属性含义如下：</p><p><foreach>标签用于遍历集合，它的属性：</p><ul><li>collection：代表要遍历的集合元素，注意编写时不要写#{}</li><li>open：代表语句的开始部分</li><li>close：代表结束部分</li><li>item：代表遍历集合的每个元素，生成的变量名</li><li>sperator：代表分隔符</li></ul></li></ol><h3 id="29-2-SQL片段抽取"><a href="#29-2-SQL片段抽取" class="headerlink" title="29.2 SQL片段抽取"></a>29.2 SQL片段抽取</h3><p>Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240225213405171.png" alt="image-20240225213405171"></p><h3 id="29-3-知识小结"><a href="#29-3-知识小结" class="headerlink" title="29.3 知识小结"></a>29.3 知识小结</h3><p><code>MyBatis映射文件配置</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span>：查询</span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span>&gt;</span>：插入</span><br><span class="line">        <span class="tag">&lt;<span class="name">update</span>&gt;</span>：修改</span><br><span class="line">            <span class="tag">&lt;<span class="name">delete</span>&gt;</span>：删除</span><br><span class="line">                <span class="tag">&lt;<span class="name">where</span>&gt;</span>：where条件</span><br><span class="line">                    <span class="tag">&lt;<span class="name">if</span>&gt;</span>：if 判断</span><br><span class="line">                        <span class="tag">&lt;<span class="name">foreach</span>&gt;</span>：循环</span><br><span class="line">                            <span class="tag">&lt;<span class="name">sql</span>&gt;</span>：sql片段抽取</span><br></pre></td></tr></table></figure><h2 id="30-MyBatis核心配置文件深入"><a href="#30-MyBatis核心配置文件深入" class="headerlink" title="30.MyBatis核心配置文件深入"></a>30.MyBatis核心配置文件深入</h2><h3 id="30-1-typeHandlers标签"><a href="#30-1-typeHandlers标签" class="headerlink" title="30.1 typeHandlers标签"></a>30.1 typeHandlers标签</h3><p>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用 类型处理器将获取的值以合适的方式转换成<br>Java 类型。下表描述了一些默认的类型处理器（截取部分）。</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226133041980.png" alt="image-20240226133041980"></p><p>可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现<br>org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然<br>后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一<br>个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。</p><p>开发步骤：</p><p>① 定义转换类继承类BaseTypeHandler<T></p><p>② 覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult 为查询时<br>mysql的字符串类型转换成 java的Type类型的方法</p><p>③ 在MyBatis核心配置文件中进行注册</p><p>④ 测试转换是否正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;Date&gt; &#123;</span><br><span class="line"><span class="comment">//将java类型 转换成 数据库需要的类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement preparedStatement, <span class="type">int</span> i, Date date, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> date.getTime();</span><br><span class="line">    preparedStatement.setLong(i,time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据库中类型 转换成java类型</span></span><br><span class="line"><span class="comment">//String参数 要转换的字段名称</span></span><br><span class="line"><span class="comment">//ResultSet 查询出的结果集</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(ResultSet resultSet, String s)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">//获取结果集中需要的数据(long) 转换成Date类型 返回</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">aLong</span> <span class="operator">=</span> resultSet.getLong(s);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(aLong);</span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据库中类型 转换成java类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(ResultSet resultSet, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">aLong</span> <span class="operator">=</span> resultSet.getLong(i);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(aLong);</span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据库中类型 转换成java类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(CallableStatement callableStatement, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">aLong</span> <span class="operator">=</span> callableStatement.getLong(i);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(aLong);</span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册类型处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.recallstudy.handler.DateTypeHandler&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeHandler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="30-2-plugins标签"><a href="#30-2-plugins标签" class="headerlink" title="30.2 plugins标签"></a>30.2 plugins标签</h3><p>MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即 可获得分页的相关数据</p><p>开发步骤:</p><p>① 导入通用PageHelper的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--分页助手--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.jsqlparser<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsqlparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>② 在mybatis核心配置文件中配置PageHelper插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置分页助手插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定方言--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>③ 测试分页数据获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置分页的相关参数 当前页+每页显示的条数</span></span><br><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; userList = mapper.findAll();</span><br><span class="line"><span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得分页相关的其他参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得与分页相关参数</span></span><br><span class="line">PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;User&gt;(userList);</span><br><span class="line">System.out.println(<span class="string">&quot;当前页：&quot;</span> + pageInfo.getPageNum());</span><br><span class="line">System.out.println(<span class="string">&quot;当页显示条数：&quot;</span> + pageInfo.getPageSize());</span><br><span class="line">System.out.println(<span class="string">&quot;总条数：&quot;</span> + pageInfo.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;总页数：&quot;</span> + pageInfo.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;上一页：&quot;</span> + pageInfo.getPrePage());</span><br><span class="line">System.out.println(<span class="string">&quot;下一页：&quot;</span> + pageInfo.getNextPage());</span><br><span class="line">System.out.println(<span class="string">&quot;是否是第一页：&quot;</span> + pageInfo.isIsFirstPage());</span><br><span class="line">System.out.println(<span class="string">&quot;是否是最后一页：&quot;</span> + pageInfo.isIsLastPage());</span><br></pre></td></tr></table></figure><h3 id="30-3-知识小结"><a href="#30-3-知识小结" class="headerlink" title="30.3 知识小结"></a>30.3 知识小结</h3><p><code>MyBatis核心配置文件常用标签:</code></p><ol><li>properties标签：该标签可以加载外部的properties文件</li><li>typeAliases标签：设置类型别名</li><li>environments标签：数据源环境配置标签</li><li>typeHandlers标签：配置自定义类型处理器</li><li>plugins标签：配置MyBatis的插件</li></ol><h2 id="31-MyBatis的多表操作"><a href="#31-MyBatis的多表操作" class="headerlink" title="31.MyBatis的多表操作"></a>31.MyBatis的多表操作</h2><h3 id="31-1-一对一查询"><a href="#31-1-一对一查询" class="headerlink" title="31.1 一对一查询"></a>31.1 一对一查询</h3><ol><li><p>一对一查询的模型</p><p>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226153427233.png" alt="image-20240226153427233"></p></li><li><p>一对一查询的语句</p><p>对应的sql语句：select * from orders o,user u where o.uid=u.id;</p><p>查询的结果如下：</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226153739540.png" alt="image-20240226153739540"></p></li><li><p>创建Order和User实体</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226153904437.png" alt="image-20240226153904437"></p></li><li><p>创建OrderMapper接口</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154019368.png" alt="image-20240226154019368"></p></li><li><p>配置OrderMapper.xml</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154053823.png" alt="image-20240226154053823"></p><p>其中<resultMap>还可以配置如下：</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154130887.png" alt="image-20240226154130887"></p></li><li><p>测试结果</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154201652.png" alt="image-20240226154201652"></p></li></ol><h3 id="31-2-一对多查询"><a href="#31-2-一对多查询" class="headerlink" title="31.2 一对多查询"></a>31.2 一对多查询</h3><ol><li><p>一对多查询的模型</p><p>用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154307831.png" alt="image-20240226154307831"></p></li><li><p>一对多查询的语句</p><p>对应的sql语句：select *,o.id oid from user u left join orders o on u.id=o.uid;</p><p>查询的结果如下：</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154348179.png" alt="image-20240226154348179"></p></li><li><p>修改User实体</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154419672.png" alt="image-20240226154419672"></p></li><li><p>创建UserMapper接口</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154445298.png" alt="image-20240226154445298"></p></li><li><p>配置UserMapper.xml</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154540488.png" alt="image-20240226154540488"></p></li><li><p>测试结果</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154616149.png" alt="image-20240226154616149"></p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154636504.png" alt="image-20240226154636504"></p></li></ol><h3 id="31-3-多对多查询"><a href="#31-3-多对多查询" class="headerlink" title="31.3 多对多查询"></a>31.3 多对多查询</h3><ol><li><p>多对多查询的模型</p><p>用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154803410.png" alt="image-20240226154803410"></p></li><li><p>多对多查询的语句</p><p>对应的sql语句：select u.<em>,r.</em>,r.id rid from user u left join user_role ur on u.id=ur.user_id inner join role r on<br>ur.role_id=r.id;</p><p>查询的结果如下：</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154840575.png" alt="image-20240226154840575"></p></li><li><p>创建Role实体，修改User实体</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154933317.png" alt="image-20240226154933317"></p></li><li><p>添加UserMapper接口方法</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226154957311.png" alt="image-20240226154957311"></p></li><li><p>配置UserMapper.xml</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226155023933.png" alt="image-20240226155023933"></p></li><li><p>测试结果</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226155048499.png" alt="image-20240226155048499"></p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226155111666.png" alt="image-20240226155111666"></p></li></ol><h3 id="31-4-知识小结"><a href="#31-4-知识小结" class="headerlink" title="31.4 知识小结"></a>31.4 知识小结</h3><p><code>MyBatis多表配置方式：</code></p><p>一对一配置：使用<resultMap>做配置</p><p>一对多配置：使用<resultMap>+<collection>做配置</p><p>多对多配置：使用<resultMap>+<collection>做配置</p><h2 id="32-Mybatis的注解开发"><a href="#32-Mybatis的注解开发" class="headerlink" title="32.Mybatis的注解开发"></a>32.Mybatis的注解开发</h2><h3 id="32-1-MyBatis的常用注解"><a href="#32-1-MyBatis的常用注解" class="headerlink" title="32.1 MyBatis的常用注解"></a>32.1 MyBatis的常用注解</h3><p>这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper映射文件了。</p><p>@Insert：实现新增</p><p>@Update：实现更新</p><p>@Delete：实现删除</p><p>@Select：实现查询</p><p>@Result：实现结果集封装</p><p>@Results：可以与@Result 一起使用，封装多个结果集</p><p>@One：实现一对一结果集封装</p><p>@Many：实现一对多结果集封装</p><h3 id="32-2-MyBatis的增删改查"><a href="#32-2-MyBatis的增删改查" class="headerlink" title="32.2 MyBatis的增删改查"></a>32.2 MyBatis的增删改查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> UserMapper mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">    mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    mapper.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    user.setUsername(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    mapper.update(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;</span><br><span class="line">    mapper.delete(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.findById(<span class="number">2</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;User&gt; userList = mapper.findAll();</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的 Mapper接口即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描使用注解的类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.recallstudy.mapper.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者指定扫描包含映射关系的接口所在的包也可以</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描使用注解的类所在的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.recallstudy.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="32-3-MyBatis的注解实现复杂映射开发"><a href="#32-3-MyBatis的注解实现复杂映射开发" class="headerlink" title="32.3 MyBatis的注解实现复杂映射开发"></a>32.3 MyBatis的注解实现复杂映射开发</h3><div class="table-container"><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Results</td><td>代替的是标签&lt;resultMap&gt;该注解中可以使用单个@Result注解，也可以使用@Result 集 合。使用格式：@Results（{@Result（），@Result（）}）或@Results（@Result（））</td></tr><tr><td>@Result</td><td>代替了<id>标签和<result>标签<br> @Result中属性介绍：<br> column：数据库的列名<br> property：需要装配的属性名 <br>one ：需要使用的@One 注解（@Result （one=@One）（）））<br> many：需要使用的@Many 注解（@Result （many=@many）（）））</td></tr><tr><td>@One （一对一）</td><td>代替了<assocation> 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。 @One注解属性介绍：<br> select: 指定用来多表查询的 sqlmapper &lt;br&gt;使用格式：@Result(column=” “,property=””,one=@One(select=””))</td></tr><tr><td>@Many （多对一）</td><td>代替了<collection> 标签, 是是多表查询的关键，在注解中用来指定子查询返回对象集合。 使用格式：@Result(property=””,column=””,many=@Many(select=””))</td></tr></tbody></table></div><h3 id="32-4-一对一查询"><a href="#32-4-一对一查询" class="headerlink" title="32.4 一对一查询"></a>32.4 一对一查询</h3><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226211524175.png" alt="image-20240226211524175"></p><h3 id="32-5-一对多查询"><a href="#32-5-一对多查询" class="headerlink" title="32.5 一对多查询"></a>32.5 一对多查询</h3><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226211621367.png" alt="image-20240226211621367"></p><h3 id="32-6-多对多查询"><a href="#32-6-多对多查询" class="headerlink" title="32.6 多对多查询"></a>32.6 多对多查询</h3><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226211716603.png" alt="image-20240226211716603"></p><h2 id="33-SSM框架整合"><a href="#33-SSM框架整合" class="headerlink" title="33.SSM框架整合"></a>33.SSM框架整合</h2><h3 id="33-1-准备工作"><a href="#33-1-准备工作" class="headerlink" title="33.1 准备工作"></a>33.1 准备工作</h3><ol><li>原始方式整合<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database ssm; <span class="keyword">create</span> <span class="keyword">table</span> account(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">money <span class="keyword">double</span>(<span class="number">7</span>,<span class="number">2</span>) );</span><br></pre></td></tr></table></figure><img src="https://images.shallowrecall.top/images/2024/2/image-20240226222548388.png" alt="image-20240226222548388"></li><li>创建Maven工程<br><img src="https://images.shallowrecall.top/images/2024/2/image-20240226222631160.png" alt="image-20240226222631160" style="zoom:50%;"  align="left"/></li><li><p>导入Maven坐标</p></li><li><p>编写实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id; </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money; </span><br><span class="line">    <span class="comment">//省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountMapper</span> &#123;</span><br><span class="line">    <span class="comment">//保存账户数据</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询账户数据</span></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Service接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123; </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>; <span class="comment">//保存账户数据 </span></span><br><span class="line">  List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>; <span class="comment">//查询账户数据 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Service接口实现</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226223253391.png" alt="image-20240226223253391"></p></li><li><p>编写Controller</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226223322237.png" alt="image-20240226223322237"></p></li><li><p>编写添加页面</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226223346649.png" alt="image-20240226223346649"></p></li><li><p>编写列表页面</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226223401485.png" alt="image-20240226223401485"></p></li><li><p>编写相应配置文件</p><ul><li>Spring配置文件：applicationContext.xml</li><li>SpringMVC配置文件：spring-mvc.xml</li><li>MyBatis映射文件：AccountMapper.xml</li><li>MyBatis核心文件：sqlMapConfig.xml</li><li>数据库连接信息文件：jdbc.properties</li><li>Web.xml文件：web.xml</li><li>日志文件：log4j.xml</li></ul></li><li><p>测试添加账户</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226223601694.png" alt="image-20240226223601694"></p></li><li><p>测试账户列表</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226223625795.png" alt="image-20240226223625795"></p></li></ol><h3 id="33-2-Spring整合MyBatis"><a href="#33-2-Spring整合MyBatis" class="headerlink" title="33.2 Spring整合MyBatis"></a>33.2 Spring整合MyBatis</h3><ol><li><p>整合思路</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226223711833.png" alt="image-20240226223711833"></p></li><li><p>将SqlSessionFactory配置到Spring容器中</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226223742161.png" alt="image-20240226223742161"></p></li><li><p>扫描Mapper，让Spring容器产生Mapper实现类</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226223806080.png" alt="image-20240226223806080"></p></li><li><p>配置声明式事务控制</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226223833523.png" alt="image-20240226223833523"></p></li><li><p>.修改Service实现类代码</p><p><img src="https://images.shallowrecall.top/images/2024/2/image-20240226223851561.png" alt="image-20240226223851561"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Spring简介&quot;&gt;&lt;a href=&quot;#1-Spring简介&quot; class=&quot;headerlink&quot; title=&quot;1. Spring简介&quot;&gt;&lt;/a&gt;1. Spring简介&lt;/h2&gt;&lt;h3 id=&quot;1-1-Spring是什么&quot;&gt;&lt;a href=&quot;#1-1-Sp</summary>
      
    
    
    
    <category term="编程学习" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/"/>
    
    <category term="SSM" scheme="https://www.shallowrecall.top/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java/SSM/"/>
    
    
    <category term="Spring" scheme="https://www.shallowrecall.top/tags/Spring/"/>
    
    <category term="SpringMVC" scheme="https://www.shallowrecall.top/tags/SpringMVC/"/>
    
    <category term="MyBatis" scheme="https://www.shallowrecall.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown基本语法</title>
    <link href="https://www.shallowrecall.top/posts/4a098468.html"/>
    <id>https://www.shallowrecall.top/posts/4a098468.html</id>
    <published>2024-02-27T12:36:45.000Z</published>
    <updated>2024-12-01T10:47:28.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MarkDown基本语法"><a href="#MarkDown基本语法" class="headerlink" title="MarkDown基本语法"></a>MarkDown基本语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 标题名字（井号的个数代表标题的级数）</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br><span class="line"><span class="section">####### 最多支持六级标题</span></span><br></pre></td></tr></table></figure><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>段落没有特殊的格式，直接用一个空行来表示重新开始一个段落。</p><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是用来 *斜体* 的 _文本_</span><br></pre></td></tr></table></figure><p>这是用来 <em>斜体</em> 的  <em>文本</em></p><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是用来 **加粗** 的 __文本__</span><br></pre></td></tr></table></figure><p>这是用来 <strong>加粗</strong> 的 <strong>文本</strong></p><h2 id="斜体-加粗"><a href="#斜体-加粗" class="headerlink" title="斜体+加粗"></a>斜体+加粗</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是用来 ***斜体+加粗*** 的 ___文本___</span><br></pre></td></tr></table></figure><p>这是用来 <strong><em>斜体+加粗</em></strong> 的 <strong><em>文本</em></strong></p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这就是 ~~删除线~~（使用波浪号）</span><br></pre></td></tr></table></figure><p>这就是 <del>删除线</del>（使用波浪号）</p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>下划线是HTML语法</p><p><code>下划线</code><u>下划线（快捷键<code>command+U</code>，Mac系统）</u></p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>可以在一行中使用三个或更多的<code>*</code>、<code>-</code>或<code>_</code>来添加分隔线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">------</span><br><span class="line">___</span><br></pre></td></tr></table></figure><hr><hr><h2 id="扩展语法的说明"><a href="#扩展语法的说明" class="headerlink" title="扩展语法的说明"></a>扩展语法的说明</h2><p>部分渲染可可能不支持该效果，若不在意垮软件性可以使用（意思就是换个别的支持markdown语法的地方敲字，某些样式可能识别不出来）</p><h2 id="高亮（需勾选扩展语法）"><a href="#高亮（需勾选扩展语法）" class="headerlink" title="高亮（需勾选扩展语法）"></a>高亮（需勾选扩展语法）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是用来 ==高亮== 的文本</span><br></pre></td></tr></table></figure><p>这是用来 ==高亮== 的文本</p><h2 id="下标（需勾选扩展语法）"><a href="#下标（需勾选扩展语法）" class="headerlink" title="下标（需勾选扩展语法）"></a>下标（需勾选扩展语法）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">水 H~2~O</span><br><span class="line">双氧水 H~2~O~2~</span><br></pre></td></tr></table></figure><p>水 H~2~O<br>双氧水 H~2~O~2~</p><h2 id="上标（需勾选扩展语法）"><a href="#上标（需勾选扩展语法）" class="headerlink" title="上标（需勾选扩展语法）"></a>上标（需勾选扩展语法）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">面积 m^2^</span><br><span class="line">体积 m^3^</span><br></pre></td></tr></table></figure><p>面积 m^2^<br>体积 m^3^</p><h2 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h2><p>Emoji支持表情符号，你可以用系统默认的Emoji符号。</p><p>输入方式</p><ol><li>输入<code>:</code>将会出现智能提示<code>:smile:</code></li><li>直接输入法选入</li><li>快捷键后点选：<ul><li>Mac：control+command+space点选</li><li>Window：使用Win键+. 或者Win+. 点选</li></ul></li></ol><p>不同方式输入的emoji可能最后渲染的会不一样，影响不大</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</span><br></pre></td></tr></table></figure><p>:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>符号 空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 可以使用 `*` 作为标记</span><br><span class="line">+ 也可以使用 `+`</span><br><span class="line">- 或者 `-`</span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>*</code> 作为标记</li><li>也可以使用<code>+</code></li><li>或者<code>-</code></li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>数字<code>.</code>空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表以数字和 `.` 开始；</span><br><span class="line">3. 数字的序列并不会影响生成的列表序列；</span><br><span class="line">4.但任然推荐按照自然顺序（1.2.3...)编写。</span><br></pre></td></tr></table></figure><ol><li>有序列表以数字和 <code>.</code> 开始；</li><li>数字的序列并不会影响生成的列表序列；</li><li>4.但任然推荐按照自然顺序（1.2.3…)编写。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以使用：数字\. 来取消显示为列表（用反斜杠进行转义）</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来分隔表头和其他行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name | price</span><br><span class="line">--- |---</span><br><span class="line">friend chicken | 19</span><br><span class="line">cola|5</span><br></pre></td></tr></table></figure><blockquote><p>为了使Markdown更清晰，<code>|</code>和<code>-</code> 两侧需要至少有一个空格（最左侧和最右侧的<code>|</code>外就不需要了）。</p></blockquote><div class="table-container"><table><thead><tr><th>name</th><th>price</th></tr></thead><tbody><tr><td>friend chicken</td><td>19</td></tr><tr><td>cola</td><td>5</td></tr></tbody></table></div><p>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用<code>|</code>来标记单元格边界，在表头下方的分隔线标记中加入<code>:</code>，即可标记下方单元格内容的对齐方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|    name       | price |</span><br><span class="line">| :------------ | :---: |</span><br><span class="line">| fried chicken | 19    |</span><br><span class="line">| cola          |  32   |</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">name</th><th style="text-align:center">price</th></tr></thead><tbody><tr><td style="text-align:left">fried chicken</td><td style="text-align:center">19</td></tr><tr><td style="text-align:left">cola</td><td style="text-align:center">32</td></tr></tbody></table></div><p>==使用快捷键<code>command</code>+<code>opt</code>+<code>T</code>更方便(段落→表格→插入表格，即可查看快捷键)==</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>开头使用&gt;符号，然后后面紧跟一个<strong>空格</strong>符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; &quot;后悔创业&quot;</span><br></pre></td></tr></table></figure><blockquote><p>“后悔创业”</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 也可以在引用中</span><br><span class="line">&gt;&gt; 使用嵌套的引用</span><br></pre></td></tr></table></figure><blockquote><p>也可以在引用中</p><blockquote><p>使用嵌套的引用</p></blockquote></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块中的文本（包括Markdow语法）都会显示为原始内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```语言名称（也可以不指定）</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p>也可以通过反引号（``）,插入行内代码</p><p><img src="https://jojo-995.gitee.io/2021/03/06/markdown-tutorial/image-20210306171044147.png" alt="image-20210306171044147"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如 `Markdown`</span><br></pre></td></tr></table></figure><p>例如<code>Markdown</code></p><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><h3 id="外部跳转—超链接"><a href="#外部跳转—超链接" class="headerlink" title="外部跳转—超链接"></a>外部跳转—超链接</h3><p>格式为<code>[link text](link)</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[帮助文档](https://support.typora.io/Links/#faq)</span><br></pre></td></tr></table></figure><p><a href="https://support.typora.io/Links/#faq">帮助文档</a></p><h3 id="内部跳转—本文件内跳—Typora支持"><a href="#内部跳转—本文件内跳—Typora支持" class="headerlink" title="内部跳转—本文件内跳—Typora支持"></a>内部跳转—本文件内跳—Typora支持</h3><p>格式为<code>[link text](#要去的目的地—标题名称)</code>。</p><p>不管标题有几个#，设置链接时只有一个#，标题里的空格可以用’-‘代替，开头结尾的空格无所谓。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[我想跳转](#完结)</span><br></pre></td></tr></table></figure><blockquote><p>Open Links in Typora</p><p>You can use <code>command+click</code> (macOS),or <code>ctrl+click</code>(Linux/Windows)  on links in Typora to jump to target headings,or open them in Typora,or open in related apps.</p></blockquote><p><a href="#完结">我想跳转</a></p><p>如果不想跳到标题，则可以自定义<a name="anchor">锚点</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#anchor&quot;</span>&gt;</span>不，你不想跳，你要回去<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;anchor&quot;</span>&gt;</span>锚点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>使用<code>&lt;&gt;</code>包括的URL或邮箱地址会被自动转换为超链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;https://www.baidu.com&gt;</span><br><span class="line"></span><br><span class="line">&lt;123@email.com&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com">https://www.baidu.com</a></p><p><a href="mailto:123@email.com">123@email.com</a></p><h3 id="重复链接"><a href="#重复链接" class="headerlink" title="重复链接"></a>重复链接</h3><p>当在一个文章==重复使用同一个链接（对下面的图片也是一样的适用）==时，我们可以通过变量来设置一个链接，相当于给这个链接起了个名字，方便统一修改，变量赋值在文档引用的下面进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这个链接用 1 作为网址变量名字 [百度][1]</span><br><span class="line">这个链接用 Recall 作为网址变量名字 [Recall的博客][recall]</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line"> [1]: http://www.baidu.com/</span><br><span class="line"> [recall]: http://blog.qianyiwb.com/</span><br></pre></td></tr></table></figure><p>这个链接用 1 作为网址变量名字 <a href="http://www.baidu.com/">百度</a><br>这个链接用 Recall 作为网址变量名字 <a href="http://blog.qianyiwb.com/">Recall的博客</a><br>然后在文档的结尾为变量赋值（网址）</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![自己起的图片名字](图片地址或者图片本地存储的路径)</span><br></pre></td></tr></table></figure><h4 id="网上的图片"><a href="#网上的图片" class="headerlink" title="网上的图片"></a>网上的图片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![我爱的🍗](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg)</span><br></pre></td></tr></table></figure><p><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg" alt="我爱的🍗"></p><h4 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h4><p>在同一个文件夹里（用相对路径）或者直接拷贝（配合snipaste截屏工具使用效果一级棒）<a href="https://zh.snipaste.com">点击下载</a></p><p><a href="https://zh.snipaste.com">snipaste</a></p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p><a href="#anchor">不，你不想跳，你要回去</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MarkDown基本语法&quot;&gt;&lt;a href=&quot;#MarkDown基本语法&quot; class=&quot;headerlink&quot; title=&quot;MarkDown基本语法&quot;&gt;&lt;/a&gt;MarkDown基本语法&lt;/h1&gt;&lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术笔记" scheme="https://www.shallowrecall.top/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Markdown" scheme="https://www.shallowrecall.top/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Markdown/"/>
    
    
    <category term="技术" scheme="https://www.shallowrecall.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Windows运行命令大全</title>
    <link href="https://www.shallowrecall.top/posts/24e1cb9d.html"/>
    <id>https://www.shallowrecall.top/posts/24e1cb9d.html</id>
    <published>2024-01-12T10:20:07.000Z</published>
    <updated>2024-03-07T14:49:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows运行命令大全"><a href="#Windows运行命令大全" class="headerlink" title="Windows运行命令大全"></a>Windows运行命令大全</h1><div class="table-container"><table><thead><tr><th>关于Windows</th><th>winver</th></tr></thead><tbody><tr><td>添加设备</td><td>devicepairingwizard</td></tr><tr><td>添加硬件</td><td>hdwwiz</td></tr><tr><td>用户账户</td><td>netplwiz</td></tr><tr><td>授权管理器</td><td>azman（Win7）</td></tr><tr><td>备份和还原</td><td>sdclt</td></tr><tr><td>Bluetooth文件传送</td><td>fsquirt</td></tr><tr><td>计算器</td><td>calc</td></tr><tr><td>证书</td><td>certmgr（Win7）</td></tr><tr><td>性能选项</td><td>systempropertiesperformance</td></tr><tr><td>数据执行保护</td><td>systempropertiesdataexecutionprevention</td></tr><tr><td>打印机用户界面</td><td>printui</td></tr><tr><td>字符映射表</td><td>charmap</td></tr><tr><td>ClearType文本调谐器</td><td>cttune</td></tr><tr><td>颜色管理</td><td>colorcpl</td></tr><tr><td>命令提示符</td><td>cmd</td></tr><tr><td>组件服务</td><td>comexp（Win7）</td></tr><tr><td>组件服务</td><td>dcomcnfg</td></tr><tr><td>计算机管理</td><td>compmgmt</td></tr><tr><td>计算机管理</td><td>compmgmtlauncher</td></tr><tr><td>连接到网络投影仪</td><td>netproj（Win7）</td></tr><tr><td>显示切换</td><td>displayswitch</td></tr><tr><td>控制面板</td><td>control</td></tr><tr><td>创建共享文件夹向导</td><td>shrpubw</td></tr><tr><td>创建系统修复光盘</td><td>recdisc</td></tr><tr><td>存储的用户名和密码</td><td>credwiz</td></tr><tr><td>默认位置</td><td>locationnotifications（Win7）</td></tr><tr><td>设备管理器</td><td>devmgmt.msc</td></tr><tr><td>Microsoft 支持诊断工具</td><td>msdt</td></tr><tr><td>数字化校准工具</td><td>tabcal</td></tr><tr><td>DirectX 诊断工具</td><td>dxdiag</td></tr><tr><td>磁盘清理</td><td>cleanmgr</td></tr><tr><td>优化驱动器</td><td>dfrgui</td></tr><tr><td>磁盘管理</td><td>diskmgmt.msc</td></tr><tr><td>显示</td><td>dpiscaling</td></tr><tr><td>显示颜色校准</td><td>dccw</td></tr><tr><td>受保护的内容迁移</td><td>dpapimig</td></tr><tr><td>驱动程序验证程序管理器</td><td>verifier</td></tr><tr><td>轻松使用设置中心</td><td>utilman</td></tr><tr><td>加密文件系统</td><td>rekeywiz</td></tr><tr><td>事件查看器</td><td>eventvwr</td></tr><tr><td>传真封面编辑器</td><td>fxscover</td></tr><tr><td>文件签名验证</td><td>sigverif</td></tr><tr><td>Windows 入门</td><td>gettingstarted（Win7）</td></tr><tr><td>IExpress 向导</td><td>iexpress</td></tr><tr><td>导入 Windows 联系人</td><td>wabmig</td></tr><tr><td>Microsoft iSCSI</td><td>iscsicpl</td></tr><tr><td>安装或卸载显示语言</td><td>lpksetup</td></tr><tr><td>本地组策略编辑器</td><td>gpedit.msc</td></tr><tr><td>本地安全策略</td><td>secpol.msc</td></tr><tr><td>本地用户和组</td><td>lusrmgr.msc</td></tr><tr><td>放大镜</td><td>magnify</td></tr><tr><td>Microsoft Windows 恶意软件删除工具</td><td>mrt</td></tr><tr><td>数学输入面板</td><td>mip</td></tr><tr><td>MMC管理控制台</td><td>mmc</td></tr><tr><td>NAP 客户端配置</td><td>napclcfg（Win7）</td></tr><tr><td>讲述人设置</td><td>narrator</td></tr><tr><td>扫描仪</td><td>wiaacmgr</td></tr><tr><td>记事本</td><td>notepad</td></tr><tr><td>ODBC 数据源管理程序</td><td>odbcad32</td></tr><tr><td>屏幕键盘</td><td>osk</td></tr><tr><td>画图</td><td>mspaint</td></tr><tr><td>性能监视器</td><td>perfmon</td></tr><tr><td>电话括号程序</td><td>dialer</td></tr><tr><td>演示设置</td><td>presentationsettings</td></tr><tr><td>打印管理</td><td>printmanagement.msc</td></tr><tr><td>打印机迁移</td><td>printbrmui</td></tr><tr><td>专用字符编辑程序</td><td>eudcedit</td></tr><tr><td>步骤记录器</td><td>psr</td></tr><tr><td>注册表编辑器</td><td>regedit</td></tr><tr><td>远程桌面连接</td><td>mstsc</td></tr><tr><td>资源监视器</td><td>resmon</td></tr><tr><td>组策略结果集</td><td>rsop</td></tr><tr><td>保护 Windows 账户数据库的安全</td><td>syskey</td></tr><tr><td>服务</td><td>services.msc</td></tr><tr><td>设置程序访问此计算机的默认值</td><td>computerdefaults</td></tr><tr><td>共享文件夹</td><td>fsmgmt.msc</td></tr><tr><td>截图工具</td><td>snippingtool</td></tr><tr><td>录音机</td><td>soundrecorder（Win7）</td></tr><tr><td>SQL Server 客户端网络实用工具</td><td>cliconfg</td></tr><tr><td>便签</td><td>stikynot</td></tr><tr><td>同步中心</td><td>mobsync</td></tr><tr><td>系统配置</td><td>msconfig</td></tr><tr><td>系统信息</td><td>msinfo32</td></tr><tr><td>系统属性-高级</td><td>systempropertiesadvanced</td></tr><tr><td>系统属性-计算机名</td><td>systempropertiescomputername</td></tr><tr><td>系统属性-硬件</td><td>systempropertieshardware</td></tr><tr><td>系统属性-远程</td><td>systempropertiesremote</td></tr><tr><td>系统属性-系统保护</td><td>systempropertiesprotection</td></tr><tr><td>系统还原</td><td>rstrui</td></tr><tr><td>任务管理器</td><td>taskmgr</td></tr><tr><td>任务计划程序</td><td>taskschd.msc</td></tr><tr><td>受信任的平台(TPM)管理</td><td>tpm.msc</td></tr><tr><td>用户账户控制设置</td><td>useraccountcontrolsettings</td></tr><tr><td>音量合成器</td><td>sndvol</td></tr><tr><td>Windows 激活</td><td>slui</td></tr><tr><td>联系人</td><td>wab</td></tr><tr><td>Windows 光盘映像刻录机</td><td>isoburn</td></tr><tr><td>Windows 资源管理器</td><td>explorer</td></tr><tr><td>Windows 传真和扫描</td><td>wfs</td></tr><tr><td>Windows 功能</td><td>optionalfeatures</td></tr><tr><td>高级安全 Windows 防火墙</td><td>wf.msc</td></tr><tr><td>Windows 帮助和支持</td><td>winhlp32</td></tr><tr><td>Windows 日记本</td><td>journal</td></tr><tr><td>Windows Media Player</td><td>wmplayer</td></tr><tr><td>Windows 内存诊断</td><td>mdsched</td></tr><tr><td>Windows 移动中心</td><td>mblctr</td></tr><tr><td>Windows Powershell</td><td>powershell</td></tr><tr><td>Windows PowerShell ISE</td><td>powershell_ise</td></tr><tr><td>Windows 远程协助</td><td>msra</td></tr><tr><td>Windows 脚本宿主设置</td><td>wscript</td></tr><tr><td>Windows Update</td><td>wuapp（Win7）</td></tr><tr><td>Windows 更新独立安装程序</td><td>wusa</td></tr><tr><td>WMI 管理</td><td>wmimgmt.msc</td></tr><tr><td>WMI 测试器</td><td>wbemtest</td></tr><tr><td>写字板</td><td>write</td></tr><tr><td>XPS 查看器</td><td>xpsrchvw</td></tr><tr><td>屏幕分辨率</td><td>desk.cpl</td></tr><tr><td>鼠标属性</td><td>main.cpl</td></tr><tr><td>安全性与维护</td><td>wscui.cpl</td></tr><tr><td>网络连接</td><td>ncpa.cpl</td></tr><tr><td>电源选项</td><td>powercfg.cpl</td></tr><tr><td>卸载或更改程序</td><td>appwiz.cpl</td></tr><tr><td>系统属性</td><td>sysdm.cpl</td></tr><tr><td>Windows 防火墙</td><td>firewall.cpl</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows运行命令大全&quot;&gt;&lt;a href=&quot;#Windows运行命令大全&quot; class=&quot;headerlink&quot; title=&quot;Windows运行命令大全&quot;&gt;&lt;/a&gt;Windows运行命令大全&lt;/h1&gt;&lt;div class=&quot;table-container&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数学基础编程题</title>
    <link href="https://www.shallowrecall.top/posts/c703b936.html"/>
    <id>https://www.shallowrecall.top/posts/c703b936.html</id>
    <published>2024-01-10T15:05:05.000Z</published>
    <updated>2024-12-01T10:47:28.110Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.shallowrecall.top/images/2024/1/img.png" alt="第一题"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">B = np.array([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>, -<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              [<span class="number">1</span>, -<span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">4</span>, <span class="number">0</span>, -<span class="number">2</span>]])</span><br><span class="line">S = np.dot(A, B)</span><br><span class="line"><span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure><pre><code>[[ 6 -7  8] [20 -5 -6]]</code></pre><p>2、编程解决如下投入产出问题：某县区有A、B、C三个企业，A企业每生产l元的产品要消耗0.4元B企业的产品和0.3元C企业的产品；B企业每生产l元的产品要消耗0.7元A企业的产品、0.l2元自产的产品和0.2元C企业的产品；C企业每生产l元的产品要消耗0.6元A企业的产品和0.l5元B企业的产品。如果这3个企业接到的外来订单分别为7万元、8.5万元和5万元，那么他们各生产多少才能满足需求?模型假设：假设不考虑价格变动等其他因素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义投入产出系数矩阵</span></span><br><span class="line">A = np.array([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0.7</span>, <span class="number">0.6</span>],  <span class="comment"># A企业自身不消耗，但生产1元产品需要消耗B企业0.7元，C企业0.6元的产品</span></span><br><span class="line">    [<span class="number">0.4</span>, <span class="number">0.12</span>, <span class="number">0</span>],  <span class="comment"># B企业生产1元产品需要消耗A企业0.4元，自身0.12元，C企业不消耗的产品</span></span><br><span class="line">    [<span class="number">0.3</span>, <span class="number">0.15</span>, <span class="number">0</span>]   <span class="comment"># C企业生产1元产品需要消耗A企业0.3元，B企业0.15元的产品</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义外部订单需求向量</span></span><br><span class="line">d = np.array([<span class="number">70</span>, <span class="number">85</span>, <span class="number">50</span>])  <span class="comment"># 单位：万元</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个企业为了满足外部订单需求而必须生产的产品总额</span></span><br><span class="line"><span class="comment"># 系统方程为：x = Ax + d，可以重写为 (I - A)x = d，其中I为单位矩阵</span></span><br><span class="line">I = np.identity(<span class="number">3</span>)  <span class="comment"># 创建一个3x3的单位矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解线性方程组 (I - A)x = d 来找到x</span></span><br><span class="line">x = np.linalg.solve(I - A, d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印每个企业需要生产的产品总额</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A企业需要生产的产品总额（万元）:&quot;</span>, x[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;B企业需要生产的产品总额（万元）:&quot;</span>, x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;C企业需要生产的产品总额（万元）:&quot;</span>, x[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><pre><code>A企业需要生产的产品总额（万元）: 382.5197238658777B企业需要生产的产品总额（万元）: 270.46351084812625C企业需要生产的产品总额（万元）: 205.32544378698225</code></pre><p>3、编程解决如下问题：—个家禽养殖基地每天投入2元资金用于饲料、设备、人力，估计可使一只2千克重的鹅每天增加0.1千克。目前鹅出售市场价格为每千克30元，但是预测每天会降低0.04元。该基地应该什么时候出售这批鹅?如果上面的估计和预测有出入，那么对结果有多大影响?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize_scalar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数定义</span></span><br><span class="line">initial_weight = <span class="number">2</span>  <span class="comment"># 鹅的初始重量（千克）</span></span><br><span class="line">weight_gain_per_day = <span class="number">0.1</span>  <span class="comment"># 每天增重（千克）</span></span><br><span class="line">initial_price_per_kg = <span class="number">30</span>  <span class="comment"># 初始每千克价格（元）</span></span><br><span class="line">price_decrease_per_day = <span class="number">0.04</span>  <span class="comment"># 每天每千克价格下降（元）</span></span><br><span class="line">daily_investment = <span class="number">2</span>  <span class="comment"># 每天投资（元）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义利润函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">profit</span>(<span class="params">days</span>):</span><br><span class="line">    total_weight = initial_weight + days * weight_gain_per_day</span><br><span class="line">    price_per_kg = initial_price_per_kg - days * price_decrease_per_day</span><br><span class="line">    total_revenue = total_weight * price_per_kg</span><br><span class="line">    total_cost = days * daily_investment</span><br><span class="line">    <span class="keyword">return</span> -(total_revenue - total_cost)  <span class="comment"># 我们用负值因为我们要最大化利润，而minimize_scalar是求最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用数值优化方法找到最大化利润的天数</span></span><br><span class="line">result = minimize_scalar(profit, bounds=(<span class="number">0</span>, <span class="number">500</span>), method=<span class="string">&#x27;bounded&#x27;</span>)  <span class="comment"># 假设最多500天</span></span><br><span class="line"></span><br><span class="line">optimal_days = result.x</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;在第<span class="subst">&#123;<span class="built_in">round</span>(optimal_days)&#125;</span>天出售&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>在第115天出售</code></pre><p>4、用Python编程实现如何获得两组模拟的正态分布的数据并输出结果。正态分布模拟的标准差为δ＝0.l5和δ＝0.3的两组数据,共40个点,通过matplotlib模块绘制出曲线图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> FontProperties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 例如使用黑体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 解决负号“-”显示为方块的问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正态分布的参数</span></span><br><span class="line">mean_1, mean_2 = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 两组数据的均值</span></span><br><span class="line">std_dev_1, std_dev_2 = <span class="number">0.15</span>, <span class="number">0.3</span>  <span class="comment"># 两组数据的标准差</span></span><br><span class="line">n_points = <span class="number">40</span>  <span class="comment"># 每组数据的点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成两组正态分布的随机数据</span></span><br><span class="line">data_1 = np.random.normal(mean_1, std_dev_1, n_points)</span><br><span class="line">data_2 = np.random.normal(mean_2, std_dev_2, n_points)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据进行排序，以便绘图</span></span><br><span class="line">sorted_data_1 = np.sort(data_1)</span><br><span class="line">sorted_data_2 = np.sort(data_2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为data_1创建正态分布曲线</span></span><br><span class="line">fit_1 = <span class="number">1</span> / (std_dev_1 * np.sqrt(<span class="number">2</span> * np.pi)) * np.exp(-<span class="number">0.5</span> * ((sorted_data_1 - mean_1) / std_dev_1)**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为data_2创建正态分布曲线</span></span><br><span class="line">fit_2 = <span class="number">1</span> / (std_dev_2 * np.sqrt(<span class="number">2</span> * np.pi)) * np.exp(-<span class="number">0.5</span> * ((sorted_data_2 - mean_2) / std_dev_2)**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制结果</span></span><br><span class="line">plt.plot(sorted_data_1, fit_1, label=<span class="string">f&#x27;正态分布（均值=<span class="subst">&#123;mean_1&#125;</span>, 标准差=<span class="subst">&#123;std_dev_1&#125;</span>）&#x27;</span>)</span><br><span class="line">plt.plot(sorted_data_2, fit_2, label=<span class="string">f&#x27;正态分布（均值=<span class="subst">&#123;mean_2&#125;</span>, 标准差=<span class="subst">&#123;std_dev_2&#125;</span>）&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">&#x27;不同标准差的正态分布&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;数值&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;概率密度&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://images.shallowrecall.top/images/2024/1/project_7_0.png" alt="png"><br>​</p><p>5、使用批量梯度下降算法拟合多维数据。待拟合的数据点为样本点对应的x值：[[6, 2], [8, 1], [10, 0], [14, 2], [18, 0]])，样本点对应的y值：[19, 21, 23, 43, 47])。上述数据点是根据函数y=3x1+4x2-7生成的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量梯度下降算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">batch_gradient_descent</span>(<span class="params">X, y, learning_rate=<span class="number">0.001</span>, n_iterations=<span class="number">1000</span></span>):</span><br><span class="line">    m, n = X.shape</span><br><span class="line">    X_b = np.c_[np.ones((m, <span class="number">1</span>)), X]  <span class="comment"># 添加x0 = 1</span></span><br><span class="line">    theta = np.zeros((n + <span class="number">1</span>, <span class="number">1</span>))  <span class="comment"># 初始化参数为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> iteration <span class="keyword">in</span> <span class="built_in">range</span>(n_iterations):</span><br><span class="line">        gradients = <span class="number">2</span>/m * X_b.T.dot(X_b.dot(theta) - y)</span><br><span class="line">        theta -= learning_rate * gradients</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 样本点对应的x值和y值</span></span><br><span class="line">X = np.array([[<span class="number">6</span>, <span class="number">2</span>], [<span class="number">8</span>, <span class="number">1</span>], [<span class="number">10</span>, <span class="number">0</span>], [<span class="number">14</span>, <span class="number">2</span>], [<span class="number">18</span>, <span class="number">0</span>]])</span><br><span class="line">y = np.array([<span class="number">19</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">43</span>, <span class="number">47</span>]).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用批量梯度下降算法</span></span><br><span class="line">theta = batch_gradient_descent(X, y)</span><br><span class="line"><span class="built_in">print</span>(theta)</span><br></pre></td></tr></table></figure><pre><code>[[-0.36773111] [ 2.59937037] [ 2.27070972]]</code></pre><p>6、某配送中心为所属的几个超市配送某品牌的厨具，假设超市每天对这种厨具的需求量是稳定的，订货费与每套产品每天的存贮费都是常数。如果超市对这种厨具的需求是可以缺货的，试编程制定最优的存贮策略。假设日需求为l00元，一次订货费为5000元，每套厨具每天的存贮费为l元，每套厨具每天的缺货费为0.l元。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_total_cost</span>(<span class="params">demand_per_day, ordering_cost, holding_cost_per_unit, shortage_cost_per_unit, order_quantity</span>):</span><br><span class="line">    days = order_quantity / demand_per_day</span><br><span class="line">    total_holding_cost = <span class="number">0.5</span> * order_quantity * holding_cost_per_unit * days</span><br><span class="line">    total_shortage_cost = <span class="number">0.5</span> * demand_per_day * shortage_cost_per_unit * days</span><br><span class="line">    total_ordering_cost = ordering_cost</span><br><span class="line">    <span class="keyword">return</span> total_ordering_cost + total_holding_cost + total_shortage_cost</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参数</span></span><br><span class="line">demand_per_day = <span class="number">100</span>  <span class="comment"># 日需求</span></span><br><span class="line">ordering_cost = <span class="number">5000</span>  <span class="comment"># 一次订货费</span></span><br><span class="line">holding_cost_per_unit = <span class="number">1</span>  <span class="comment"># 每套厨具每天的存贮费</span></span><br><span class="line">shortage_cost_per_unit = <span class="number">0.1</span>  <span class="comment"># 每套厨具每天的缺货费</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算不同订货量下的总成本</span></span><br><span class="line">order_quantities = np.arange(demand_per_day, <span class="number">5000</span>, <span class="number">100</span>)  <span class="comment"># 从日需求量到一个较大的数值</span></span><br><span class="line">costs = [calculate_total_cost(demand_per_day, ordering_cost, holding_cost_per_unit, shortage_cost_per_unit, q) <span class="keyword">for</span> q <span class="keyword">in</span> order_quantities]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到成本最低的订货量</span></span><br><span class="line">optimal_order_quantity = order_quantities[np.argmin(costs)]</span><br><span class="line"><span class="built_in">print</span>(optimal_order_quantity)</span><br></pre></td></tr></table></figure><pre><code>100</code></pre><p><img src="https://images.shallowrecall.top/images/2024/1/img_1.png" alt="7"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义矩阵 A 和 B</span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">3</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">B = np.array([[<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, -<span class="number">2</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              [<span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">2</span>, -<span class="number">4</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 M = 4A^2 + 3AB - 2BA + 5B^2 + (AB)^T</span></span><br><span class="line">M = <span class="number">4</span> * np.dot(A, A) + <span class="number">3</span> * np.dot(A, B) - <span class="number">2</span> * np.dot(B, A) + <span class="number">5</span> * np.dot(B, B) + np.dot(A, B).T</span><br><span class="line"><span class="built_in">print</span>(M)</span><br></pre></td></tr></table></figure><pre><code>[[129  71 128  26] [ 93 113 -10  32] [ 84  51  28 -25] [155  85 -19 141]]</code></pre><p>8、编程解决如下金融公司支付基金的流动问题：金融机构为保证现金充分支付，设立—笔总额8600万元的基金，分开放置在位于甲城和乙城的两家公司，基金在平时可以使用，但每周末结算时必须确保总额仍然为8600万元。经过相当长的一段时期的现金流动，发现每过一周，各公司的支付基金在流通过程中多数还留在自己的公司内，而甲城公司有l5％支付基金流动到乙城公司，乙城公司则有l8％支付基金流动到甲城公司。起初甲城公司基金为4l00万元，乙城公司基金为4600万元。按此规律，两公司支付基金数额变化趋势如何?如果金融专家认为每个公司的支付基金不能少于3900万元，那么是否需要在必要时调动基金?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现矩阵 M 的计算并打印结果</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义矩阵 A 和 B</span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">3</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">B = np.array([[<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, -<span class="number">2</span>],</span><br><span class="line">              [<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              [<span class="number">2</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">2</span>, -<span class="number">4</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 M = 4A^2 + 3AB - 2BA + 5B^2 + (AB)^T</span></span><br><span class="line">M = <span class="number">4</span> * np.dot(A, A) + <span class="number">3</span> * np.dot(A, B) - <span class="number">2</span> * np.dot(B, A) + <span class="number">5</span> * np.dot(B, B) + np.dot(A, B).T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印矩阵 M</span></span><br><span class="line"><span class="built_in">print</span>(M)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 金融公司支付基金的流动问题</span></span><br><span class="line"><span class="comment"># 定义状态转移矩阵</span></span><br><span class="line">transition_matrix = np.array([[<span class="number">0.85</span>, <span class="number">0.18</span>],</span><br><span class="line">                              [<span class="number">0.15</span>, <span class="number">0.82</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义初始基金分布</span></span><br><span class="line">funds_distribution = np.array([[<span class="number">4100</span>],</span><br><span class="line">                               [<span class="number">4500</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行多周的基金流动模拟</span></span><br><span class="line"><span class="keyword">for</span> week <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">53</span>):  <span class="comment"># 模拟一年的周数</span></span><br><span class="line">    funds_distribution = np.dot(transition_matrix, funds_distribution)</span><br><span class="line">    <span class="comment"># 检查是否需要调动基金</span></span><br><span class="line">    <span class="keyword">if</span> funds_distribution[<span class="number">0</span>] &lt; <span class="number">3900</span> <span class="keyword">or</span> funds_distribution[<span class="number">1</span>] &lt; <span class="number">3900</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;在第 <span class="subst">&#123;week&#125;</span> 周需要调动基金。&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印最终的基金分布</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;一年后甲城公司基金为：<span class="subst">&#123;funds_distribution[<span class="number">0</span>][<span class="number">0</span>]&#125;</span>万元&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;一年后乙城公司基金为：<span class="subst">&#123;funds_distribution[<span class="number">1</span>][<span class="number">0</span>]&#125;</span>万元&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>[[129  71 128  26] [ 93 113 -10  32] [ 84  51  28 -25] [155  85 -19 141]]一年后甲城公司基金为：4690.909090375244万元一年后乙城公司基金为：3909.090909624741万元</code></pre><p>9、编程计算全０、全１、单位二阶方阵的特征值与特征向量，并给出相应结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> eig  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 全0矩阵  </span></span><br><span class="line">A1 = np.zeros((<span class="number">2</span>,<span class="number">2</span>))  </span><br><span class="line"><span class="comment"># 全1矩阵  </span></span><br><span class="line">A2 = np.ones((<span class="number">2</span>,<span class="number">2</span>))  </span><br><span class="line"><span class="comment"># 单位矩阵  </span></span><br><span class="line">A3 = np.eye(<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 计算特征值和特征向量  </span></span><br><span class="line">eig_vals1, eig_vecs1 = eig(A1)  </span><br><span class="line">eig_vals2, eig_vecs2 = eig(A2)  </span><br><span class="line">eig_vals3, eig_vecs3 = eig(A3)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;全0矩阵的特征值和特征向量:&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;特征值:&quot;</span>, eig_vals1)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;特征向量:\n&quot;</span>, eig_vecs1)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n全1矩阵的特征值和特征向量:&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;特征值:&quot;</span>, eig_vals2)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;特征向量:\n&quot;</span>, eig_vecs2)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n单位矩阵的特征值和特征向量:&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;特征值:&quot;</span>, eig_vals3)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;特征向量:\n&quot;</span>, eig_vecs3)</span><br></pre></td></tr></table></figure><pre><code>全0矩阵的特征值和特征向量:特征值: [0. 0.]特征向量: [[1. 0.] [0. 1.]]全1矩阵的特征值和特征向量:特征值: [2. 0.]特征向量: [[ 0.70710678 -0.70710678] [ 0.70710678  0.70710678]]单位矩阵的特征值和特征向量:特征值: [1. 1.]特征向量: [[1. 0.] [0. 1.]]</code></pre><p>10、编程求向量的曼哈顿距离、欧氏距离和切比雪夫距离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.spatial <span class="keyword">import</span> distance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个向量</span></span><br><span class="line">vector_a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">vector_b = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算曼哈顿距离</span></span><br><span class="line">manhattan_dist = distance.cityblock(vector_a, vector_b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算欧氏距离</span></span><br><span class="line">euclidean_dist = distance.euclidean(vector_a, vector_b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算切比雪夫距离</span></span><br><span class="line">chebyshev_dist = distance.chebyshev(vector_a, vector_b)</span><br><span class="line"></span><br><span class="line">manhattan_dist, euclidean_dist, chebyshev_dist</span><br></pre></td></tr></table></figure><pre><code>(9, 5.196152422706632, 3)</code></pre><p>11、用Python编程实现贝叶斯公式的计算：假设有两个教室各有l00个学生，A教室中有60个男生、40个女生，B教室中有30个男生、70个女生。假设随机选择其中一个教室,从里面叫出一个人记下性别再回到原来的教室，那么被选择的教室是A教室的概率有多大?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义先验概率</span></span><br><span class="line">prob_A = <span class="number">1</span>/<span class="number">2</span>  <span class="comment"># 选择A教室的概率</span></span><br><span class="line">prob_B = <span class="number">1</span>/<span class="number">2</span>  <span class="comment"># 选择B教室的概率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义条件概率</span></span><br><span class="line">prob_boy_given_A = <span class="number">60</span>/<span class="number">100</span>  <span class="comment"># A教室中选到男生的概率</span></span><br><span class="line">prob_boy_given_B = <span class="number">30</span>/<span class="number">100</span>  <span class="comment"># B教室中选到男生的概率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据贝叶斯公式计算在已知选出的是男生的条件下，是从A教室选出的概率</span></span><br><span class="line"><span class="comment"># P(A|boy) = (P(boy|A) * P(A)) / (P(boy|A) * P(A) + P(boy|B) * P(B))</span></span><br><span class="line">prob_A_given_boy = (prob_boy_given_A * prob_A) / (prob_boy_given_A * prob_A + prob_boy_given_B * prob_B)</span><br><span class="line">prob_A_given_boy</span><br></pre></td></tr></table></figure><pre><code>0.6666666666666667</code></pre><p>12使用批量梯度下降算法拟合直线。待拟合的二维平面数据点：(6, 7)， (8, 9)， (10, 13)，(14, 17.5)， (18, 18)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义批量梯度下降算法拟合直线</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linear_regression</span>(<span class="params">X, y, learning_rate=<span class="number">0.001</span>, n_iterations=<span class="number">10000</span></span>):</span><br><span class="line">    m = <span class="built_in">len</span>(X)  <span class="comment"># 样本数量</span></span><br><span class="line">    X_b = np.c_[np.ones((m, <span class="number">1</span>)), X]  <span class="comment"># 添加x0 = 1</span></span><br><span class="line">    theta = np.random.randn(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 随机初始化参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> iteration <span class="keyword">in</span> <span class="built_in">range</span>(n_iterations):</span><br><span class="line">        gradients = <span class="number">2</span>/m * X_b.T.dot(X_b.dot(theta) - y)</span><br><span class="line">        theta -= learning_rate * gradients</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据点</span></span><br><span class="line">X = np.array([<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">18</span>]).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">y = np.array([<span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">17.5</span>, <span class="number">18</span>]).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用线性回归模型</span></span><br><span class="line">theta = linear_regression(X, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(theta)</span><br></pre></td></tr></table></figure><pre><code>[[1.7207352 ] [0.99534866]]</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.shallowrecall.top/images/2024/1/img.png&quot; alt=&quot;第一题&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    <category term="大学课程" scheme="https://www.shallowrecall.top/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="机器学习数学基础" scheme="https://www.shallowrecall.top/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机专业英语</title>
    <link href="https://www.shallowrecall.top/posts/62a3a0d6.html"/>
    <id>https://www.shallowrecall.top/posts/62a3a0d6.html</id>
    <published>2024-01-09T13:32:03.000Z</published>
    <updated>2024-12-01T10:47:28.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机专业英语"><a href="#计算机专业英语" class="headerlink" title="计算机专业英语"></a>计算机专业英语</h1><ol><li><p>Waterfall model 瀑布模型</p><p><img src="https://images.shallowrecall.top/images/2024/1/wecom-temp-1001939-f3c97ec2812fe2e56245f3bc6310f0d9.png" alt="wecom-temp-1001939-f3c97ec2812fe2e56245f3bc6310f0d9"></p><p>Progress is seen as flowing steadily downwards through the phases of requirements analysis，design，implementation，testing，and maintenance.</p></li><li><p>Data Mining 数据挖掘</p><p>Several types of analytical software are available：statistics，machine learning，and neural networks.</p></li><li><p>Five types of relationships are sought：</p><ul><li>Classes analysis       分类分析</li><li>Cluster analysis          聚类分析</li><li>Association analysis  关联分析</li><li>Outlier analysis          孤立点分析</li><li>Sequential pattern analysis 序列模式分析</li></ul></li><li><p>段落翻译</p><ul><li>HarmonyOS 鸿蒙系统</li></ul><p>​        Huawei HarmonyOS is an operating system officially launched by Huawei at the Huawei Developer Conference(HDC) held in Dongguan on August 9,2019,as part of its broader push to solve China’s problem of lacking homegrown operating systems for fundamental digital technologies.</p><p>作为其更广泛努力解决中国缺乏基础数字技术本土操作系统问题的一部分。</p><p>​        HarmonyOS is a new distributed operating system oriented to the whole scence,creating a  super virual terminal interconnected world,connecting people ,equipment and scene organically,realizing rapid discovery,rapid connection,hardware mutual assistance and resource sharing of various intalligent terminals that consumers come into contact with in the whole scene of life.</p><p>HarmonyOS是面向全场景的新型分布式操作系统，打造了一个超级虚拟终端互联世界，将人、设备、场景有机地连接在一起，实现了消费者在生活全场景中接触到的各种智能终端的快速发现、快速连接、硬件互助和资源共享。</p><p>​        On September 10,2020,Huawei said that its in-house operating system HarmonyOS would be used in smartphones next year,marking a breakthrough in Chinese companies’ efforts to commercialize self-developed operating system and to build their own globally competive software ecosystems.The number of developers of HMS stood at over 1.8 million and the mobile applications integrated whit HMS so far have exceeded 96,000.</p><p>2020年9月10日，华为表示，其自有操作系统HarmonyOS将于明年用于智能手机，这标志着中国公司在将自主开发的操作系统商业化和构建自己的具有全球竞争力的软件生态系统方面取得了突破。HMS的开发者人数超过180万，到目前为止，与HMS集成的移动应用程序已经超过9.6万。</p><p>​        HarmonyOS is already used in Huawei’s smart TV products.With the upgrade of the system,and will be used in smartwatches,personal computers and other Internet of Things(IoT) devices later.</p><p>HarmonyOS已经在华为的智能电视产品中使用。随着系统的升级，并将在未来用于智能手表、个人电脑和其他物联网(IoT)设备。</p><p>​        Huawei has also promised to make HarmonyOS open source,which means anyone can freely examine the system specification to make sure there’s no problem.The code for small Internet of Things devices with 128 megabytes or less storage is available now.The code for larger device will be freely published in April 2021,and the remaining code will be available for download by October 2021.</p><p>华为还承诺将HarmonyOS开源，这意味着任何人都可以自由检查系统规范，以确保没有问题。128MB或更小存储空间的小型物联网设备的代码现已可用。较大设备的代码将于2021年4月免费发布，其余代码将于2021年10月供下载。</p><ul><li>Google</li></ul><p>​    Google is the most popular search engine with a stunning 91.42% market share.It holds first place in search with a difference of 88.28% from second in place Bing.According to statistics from Statista and StatCounter,Google is dominating the market in all countries on any device(desptop,mobile,and tablet).</p><p>谷歌是最受欢迎的搜索引擎，拥有惊人的91.42%的市场份额。谷歌以88.28%的差距位居搜索引擎首位，与第二位的必应相差88.28%。根据Statista和StatCounter的统计数据，谷歌在所有国家的任何设备(Deptop、移动设备和平板电脑)上都主导着市场。</p><p>​        What made Google the most popular and trusted search engine is the quality of its search results.Google is using sophisticated algorithms to present the most accurate results to the user.</p><p>谷歌之所以成为最受欢迎和最值得信赖的搜索引擎，是因为其搜索结果的质量。谷歌正在使用复杂的算法将最准确的结果呈现给用户。</p><p>​        Google’s founders Larry Page and Serey Brin came up with the idea that websites referenced by other websites are more important than others and thus deserv a higher ranking in the search results.</p><p>谷歌创始人拉里·佩奇和塞利·布林提出了一个想法，即被其他网站引用的网站比其他网站更重要，因此应该在搜索结果中获得更高的排名。</p><p>​        Over the years the Google ranking algorithm has been enriched with hundreds of other factors (including the help of machine learning) and still remains the most reliable way to find exactly what you are looking for on the Internet.</p><p>多年来，Google排名算法已经丰富了数百个其他因素（包括机器学习的帮助），并且仍然是在互联网上准确找到您正在寻找的内容的最可靠方法。</p><p>Router</p><p>​        Sometimes,however,the networks to be connected have incompatible characteristics.For instance ,the characteristics of a WIFI network are not readily compatible with an Ethernet network.In these cases the networks must be connected in a manner that builds a network of networks,known as an internet,in which the original networks their individuality and continue to function as autonomous networks .The connection between networks to form an internet is handled by devices known as routers,which are special purpose computers used for forwarding messages.</p><p>然而，有时要连接的网络具有不兼容的特性。例如，WiFi网络的特性不容易与以太网络兼容。在这些情况下，网络必须以一种建立网络网络的方式连接，称为因特网，在该网络中，原始网络具有其个性并继续作为自治网络起作用。网络之间的连接形成因特网由称为路由器的设备来处理，该设备是用于转发消息的专用计算机。</p></li><li><p>CPU</p><ul><li>the arithmetic / logic unit       算术逻辑单元</li><li>the control unit                        控制单元</li><li>the register unit                        寄存单元</li></ul></li><li><p>五层模型</p><ul><li>Application Layer</li><li>Transport Layer</li><li>Internet Layer</li><li>Link Layer</li><li>Physical Layer</li></ul><ol><li><p><strong>Application Layer:</strong> This topmost layer enables software applications to communicate over a network. It provides protocols that applications use to exchange data, like HTTP for web browsing and SMTP for email.</p><p>这一最顶层使软件应用程序能够通过网络进行通信。它提供了应用程序用来交换数据的协议，比如用于网页浏览的HTTP和用于电子邮件的SMTP。</p></li><li><p><strong>Transport Layer:</strong> This layer is responsible for the reliable transmission of data segments between points on a network, including error checking and data flow control. Protocols like TCP (Transmission Control Protocol) and UDP (User Datagram Protocol) operate at this layer.</p><p>这一层负责在网络上的点之间可靠地传输数据段，包括错误检查和数据流控制。像TCP(传输控制协议)和UDP(用户数据报协议)这样的协议在这一层运行。</p></li><li><p><strong>Internet Layer:</strong> This layer handles the routing of data packets across networks. The most famous protocol at this level is the Internet Protocol (IP), which is responsible for addressing and routing packets so they can travel between devices on different networks.</p><p>这一层处理数据包在网络上的路由。这一层最著名的协议是互联网协议（IP），它负责寻址和路由数据包，使它们可以在不同网络上的设备之间传输。</p></li><li><p><strong>Link Layer:</strong> Also known as the Data Link Layer, this layer is concerned with the network-specific transmission of data and handles the movement of packets between devices on the same network. This layer includes protocols like Ethernet and WiFi.</p><p>也称为数据链路层，该层负责特定于网络的数据传输，并处理同一网络中的设备之间的数据包移动。这一层包括以太网和WiFi等协议。</p></li><li><p><strong>Physical Layer:</strong> The foundational layer, it is responsible for the physical transmission of data over network communication media. It translates the digital data into electrical, radio, or optical signals. For example, this layer would determine how bits are modulated onto signals transmitted over Ethernet cables or through wireless connections.</p><p>基础层负责通过网络通信介质进行数据的物理传输。它将数字数据转换成电信号、无线电信号或光信号。例如，这一层将确定如何将位调制到通过以太网电缆或通过无线连接传输的信号上。</p></li></ol></li><li><p>云计算五大特征</p><ul><li>On-Demand Self-Service</li><li>Broad Network Access</li><li>Resource Pooling</li><li>Rapid Elasticity</li><li>Metered Service</li></ul><ol><li><p><strong>On-Demand Self-Service:</strong> Users can automatically provision computing resources like server time and network storage without requiring human interaction with service providers.</p><p>用户可以自动配置服务器时间和网络存储等计算资源，而无需与服务提供商进行人工交互。</p></li><li><p><strong>Broad Network Access:</strong> Resources are available over the network and can be accessed through standard mechanisms by diverse client platforms (e.g., mobile phones, laptops, and PDAs).</p><p>各种客户端平台(例如，移动电话、笔记本电脑和PDA)可以通过标准机制访问网络上的资源。</p></li><li><p><strong>Resource Pooling:</strong> The provider’s computing resources are pooled to serve multiple consumers, with different physical and virtual resources dynamically assigned and reassigned according to demand.</p><p>提供者的计算资源被集中起来为多个消费者服务，不同的物理和虚拟资源根据需求动态分配和重新分配。</p></li><li><p><strong>Rapid Elasticity:</strong> Capabilities can be elastically provisioned and released to scale rapidly outward and inward commensurate with demand, appearing to the user as unlimited resources that can be purchased in any quantity at any time.</p><p>可以灵活地配置和释放功能，以根据需求快速向外和向内扩展，在用户看来就像是可以在任何时间购买任何数量的无限资源。</p></li><li><p><strong>Metered Service:</strong> Cloud systems automatically control and optimize resource use by leveraging a metering capability at some level of abstraction appropriate to the type of service (e.g., storage, processing, bandwidth, and active user accounts). Users are billed based on service usage.</p><p>云系统通过在适合于服务类型的某个抽象级别（例如，存储、处理、带宽和活动用户帐户）。用户根据服务使用情况付费。</p></li></ol></li><li><p>SDLC（Softerware Development Life Cycle）软件生命周期</p></li></ol><ul><li>Analysis 需求分析</li><li>Design 设计</li><li>implementation 实施</li><li>Testing 测试</li><li>Development 部署</li><li>Maintenance 维护</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机专业英语&quot;&gt;&lt;a href=&quot;#计算机专业英语&quot; class=&quot;headerlink&quot; title=&quot;计算机专业英语&quot;&gt;&lt;/a&gt;计算机专业英语&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Waterfall model 瀑布模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;htt</summary>
      
    
    
    
    <category term="英语学习" scheme="https://www.shallowrecall.top/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>数学基础考点</title>
    <link href="https://www.shallowrecall.top/posts/b1609aae.html"/>
    <id>https://www.shallowrecall.top/posts/b1609aae.html</id>
    <published>2024-01-07T03:43:17.000Z</published>
    <updated>2024-12-01T10:47:28.111Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>如何实现两个向量的数乘、内积、外积和分量乘法？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个向量</span></span><br><span class="line">vector1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">vector2 = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数乘</span></span><br><span class="line">scalar_multiply = <span class="number">2</span>  <span class="comment"># 乘以2</span></span><br><span class="line">result_scalar_multiply = vector1 * scalar_multiply</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数乘结果:&quot;</span>, result_scalar_multiply)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内积（点积）</span></span><br><span class="line">dot_product = np.dot(vector1, vector2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;内积结果:&quot;</span>, dot_product)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外积（叉积）</span></span><br><span class="line">cross_product = np.cross(vector1, vector2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;外积结果:&quot;</span>, cross_product)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分量乘法</span></span><br><span class="line">component_multiply = vector1 * vector2</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;分量乘法结果:&quot;</span>, component_multiply)</span><br></pre></td></tr></table></figure></li><li><p>什么是哈达玛积(Hadamard product)？</p><p>哈达玛积（Hadamard<br>product）是一种针对两个相同维度的矩阵或向量进行元素级别的乘法运算。也就是说，它将两个矩阵或向量的对应元素相乘，生成一个新的矩阵或向量，新矩阵或向量的每个元素都是原始矩阵或向量中对应位置的元素相乘的结果。</p></li><li><p>对于p-范数,p分别取值0、1、2和∞时，分别对应着那几种范数，这些范数在numpy中如何编程实现？</p><ol><li>当p=0时，表示零范数（L0范数），它表示向量中非零元素的数量。</li><li>当p=1时，表示一范数（L1范数），它表示向量中所有元素的绝对值之和。</li><li>当p=2时，表示二范数（L2范数），它表示向量中所有元素的平方和的平方根，也叫做欧几里得范数。</li><li>当p=∞时，表示无穷范数（L∞范数），它表示向量中绝对值最大的元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个示例向量</span></span><br><span class="line">v = np.array([<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, -<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算不同p-范数</span></span><br><span class="line">p0_norm = np.linalg.norm(v, <span class="built_in">ord</span>=<span class="number">0</span>)  <span class="comment"># 零范数</span></span><br><span class="line">p1_norm = np.linalg.norm(v, <span class="built_in">ord</span>=<span class="number">1</span>)  <span class="comment"># 一范数</span></span><br><span class="line">p2_norm = np.linalg.norm(v, <span class="built_in">ord</span>=<span class="number">2</span>)  <span class="comment"># 二范数</span></span><br><span class="line">pinf_norm = np.linalg.norm(v, <span class="built_in">ord</span>=np.inf)  <span class="comment"># 无穷范数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;L0范数:&quot;</span>, p0_norm)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;L1范数:&quot;</span>, p1_norm)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;L2范数:&quot;</span>, p2_norm)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;L∞范数:&quot;</span>, pinf_norm)</span><br></pre></td></tr></table></figure></li><li><p>如何编程计算全０、全１、单位二阶方阵的特征值与特征向量？</p><ol><li><p>计算全零矩阵的特征值和特征向量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全零矩阵</span></span><br><span class="line">zero_matrix = np.zeros((<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算特征值和特征向量</span></span><br><span class="line">eigenvalues, eigenvectors = np.linalg.eig(zero_matrix)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;全零矩阵的特征值：&quot;</span>, eigenvalues)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;全零矩阵的特征向量：\n&quot;</span>, eigenvectors)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>计算全一矩阵的特征值和特征向量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全一矩阵</span></span><br><span class="line">ones_matrix = np.ones((<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算特征值和特征向量</span></span><br><span class="line">eigenvalues, eigenvectors = np.linalg.eig(ones_matrix)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;全一矩阵的特征值：&quot;</span>, eigenvalues)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;全一矩阵的特征向量：\n&quot;</span>, eigenvectors)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>计算单位二阶方阵的特征值和特征向量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建单位二阶方阵</span></span><br><span class="line">identity_matrix = np.identity(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算特征值和特征向量</span></span><br><span class="line">eigenvalues, eigenvectors = np.linalg.eig(identity_matrix)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;单位二阶方阵的特征值：&quot;</span>, eigenvalues)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;单位二阶方阵的特征向量：\n&quot;</span>, eigenvectors)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>什么是相似矩阵？相似矩阵具有什么性质？</p><p>相似矩阵是指存在相似关系的矩阵，即存在可逆矩阵P，使得P^(-1)AP=B</p><p>相似矩阵具有以下性质：</p><ol><li>特征值相同：如果两个矩阵A和B是相似矩阵，它们具有相同的特征值。这意味着它们在某种意义上描述了相同的线性变换。</li><li>特征向量关系：如果A和B是相似矩阵，并且v是A的一个特征向量，那么P^(-1) * v是B的相应特征向量。这说明相似矩阵之间的特征向量之间存在线性关系。</li><li>形式上的变换：相似矩阵关系B = P^(-1) <em> A </em> P可以看作是对矩阵A进行了一种相似变换，将A变换为B的形式。P是这个变换的转换矩阵。</li></ol></li><li><p>什么是矩阵的秩？什么是满秩矩阵？</p><p>​ 矩阵的秩是矩阵中非零行的最大数量，或者说是矩阵的行向量组中线性无关的最大数量。它表示了矩阵中包含的信息量和维度的重要性。具体来说，矩阵的秩是指能够通过线性组合（加法和数乘）生成矩阵中所有行的最小行数。</p><p>​ 满秩矩阵是指矩阵的秩等于其行数或列数中的较小值的矩阵。换句话说，对于一个n×m的矩阵，如果其秩等于n（行数）或m（列数）中的较小值，则该矩阵被称为满秩矩阵</p></li><li><p>矩阵的逆具有什么性质？如何编程计算矩阵的逆？</p><p>矩阵的逆是指对于一个可逆矩阵（也称为非奇异矩阵），存在一个矩阵，使得两者相乘得到单位矩阵。矩阵的逆具有以下性质：</p><ol><li>如果矩阵A有逆矩阵A^(-1)，则A^(-1)的逆也是A，即(A^(-1))^(-1) = A。</li><li>如果两个矩阵A和B都有逆矩阵，它们的乘积AB也有逆矩阵，且逆矩阵为(B^(-1)) * (A^(-1))。</li><li>单位矩阵I的逆矩阵是它自己，即I^(-1) = I。</li><li>零矩阵没有逆矩阵，因为没有矩阵可以与零矩阵相乘得到单位矩阵。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个可逆矩阵</span></span><br><span class="line">matrix = np.array([[<span class="number">2</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算矩阵的逆</span></span><br><span class="line">inverse_matrix = np.linalg.inv(matrix)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原始矩阵:\n&quot;</span>, matrix)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;矩阵的逆:\n&quot;</span>, inverse_matrix)</span><br></pre></td></tr></table></figure></li><li><p>什么是向量的线性相关、线性无关？</p><p>线性相关是指一组向量中至少有一个向量可以通过其他向量的线性组合来表示，存在依赖关系；线性无关是指一组向量中不存在非零的线性组合能够得到零向量，它们相互独立。</p></li><li><p>什么是特征向量，具有什么性质？</p><p>特征向量是矩阵的一个非零向量，当该向量与矩阵相乘时，仅仅发生伸缩而不改变方向。特征向量通常与特征值一起出现，它是表示线性变换中的固有方向的向量。</p><p>特征向量的性质包括：</p><ol><li><strong>定义</strong>：对于一个方阵A，如果存在一个非零向量v和一个标量λ（特征值），使得以下等式成立：A <em> v = λ </em><br>v，那么v就是A的特征向量，λ是对应的特征值。</li><li><strong>长度</strong>：特征向量的长度可以是任意的，但通常被标准化为单位向量，以便更容易理解其方向。</li><li><strong>复数性质</strong>：特征值可以是实数或复数，特征向量也可以对应复数特征值。</li><li><strong>多个特征向量</strong>：一个矩阵可以有多个特征向量和对应的特征值。</li><li><strong>表示变换方向</strong>：特征向量表示了矩阵的线性变换中的固有方向，它们保持在变换后的方向不变或仅发生伸缩。</li><li><strong>应用</strong>：特征向量和特征值在许多领域中有广泛的应用，包括线性代数、物理学、工程学、数据分析等。它们用于矩阵对角化、特征值分解、主成分分析（PCA）等任务。</li></ol></li><li><p>什么是正交矩阵？正交矩阵具有什么性质？</p><p>正交矩阵（Orthogonal Matrix）是一个方阵，其行向量和列向量都是标准正交的（单位长度且互相正交）。具体来说，正交矩阵满足以下两个条件：</p><ol><li>正交矩阵的行向量是单位向量，也就是每个行向量的长度（范数）等于1。</li><li>正交矩阵的列向量也是单位向量，并且互相正交，也就是每一对不同的列向量的内积为0。</li></ol><p>正交矩阵的性质包括：</p><ol><li>正交矩阵的转置是它的逆矩阵。如果矩阵Q是正交矩阵，则Q^T <em> Q = Q </em> Q^T = I，其中I是单位矩阵。</li><li>正交矩阵的行向量和列向量都构成标准正交基。这意味着它们可以用作向量空间的基，并且能够保持向量的长度和角度不变。</li><li>正交矩阵的行列式的绝对值等于1。即，det(Q) = ±1。</li><li>正交矩阵表示的线性变换保持向量的长度和角度不变，是一种保持欧几里得空间中距离和角度不变的变换。</li><li>正交矩阵在旋转、反射、镜像等几何变换中具有重要应用，因为它们保持了空间的正交性质。</li></ol></li><li><p>什么是LU分解、特征分解、奇异值分解？这三者有什么差异？</p><ol><li><strong>LU分解</strong>：<ul><li>LU分解是一种将一个矩阵分解为两个矩阵的方法，一个是下三角矩阵（Lower Triangular Matrix，L），另一个是上三角矩阵（Upper<br>Triangular Matrix，U）。</li><li>LU分解通常用于解线性方程组，可以将一个大型线性方程组的求解问题拆分成两个步骤，首先通过LU分解将系数矩阵分解为L和U，然后通过前代和回代的方式求解方程组。</li><li>LU分解不一定适用于所有矩阵，只适用于非奇异（可逆）矩阵。</li></ul></li><li><strong>特征分解</strong>：<ul><li>特征分解是一种将一个方阵分解为一组特征向量和对应的特征值的方法。</li><li>特征分解通常用于矩阵对角化，将一个矩阵表示为特征向量矩阵和特征值矩阵的乘积。</li><li>特征分解仅适用于某些类型的矩阵，例如对称矩阵。</li></ul></li><li><strong>奇异值分解</strong>：<ul><li>奇异值分解是一种将一个任意矩阵分解为三个矩阵的方法，一个是正交矩阵（通常是U矩阵），一个是对角矩阵（包含奇异值的Σ矩阵），另一个是正交矩阵的转置（通常是V^T矩阵）。</li><li>奇异值分解是一种广泛适用于任意矩阵的分解方法，没有像LU分解和特征分解那样的限制。</li><li>奇异值分解在降维、矩阵压缩、数据压缩、图像处理、机器学习等领域中有广泛应用。</li></ul></li></ol><p>差异：</p><ul><li>LU分解是用于解线性方程组的方法，将矩阵分解为下三角和上三角矩阵。</li><li>特征分解是将矩阵对角化的方法，将矩阵分解为特征向量和特征值的矩阵。</li><li>奇异值分解是将任意矩阵分解为三个矩阵的方法，通常用于降维和数据分析。</li></ul></li><li><p>什么是正定矩阵？正定矩阵具有什么性质？<br>正定矩阵（Positive Definite Matrix）是一类特殊的对称矩阵，具有一些重要的性质。一个n×n的实对称矩阵A被称为正定矩阵，如果对于任意非零实向量x，都满足以下条件：</p><p>x^T <em> A </em> x &gt; 0</p><p>其中，x^T表示x的转置，A表示矩阵A。这意味着正定矩阵的所有特征值都是正数，并且任何非零向量经过A的作用后，其结果都是正数。正定矩阵的性质包括：</p><ol><li>所有的特征值都是正数。即，A的特征值λ满足λ &gt; 0。</li><li>矩阵A的行列式（det(A)）是正数。</li><li>矩阵A的主子矩阵（由A的任意一些行和列组成的子矩阵）也是正定矩阵。</li><li>正定矩阵是对称的，即A等于其转置A^T。</li><li>正定矩阵是非奇异的（可逆的），因为它的行列式不为零。</li><li>正定矩阵在优化、数值计算和线性代数中具有重要应用，例如在正定线性规划、最小二乘法、协方差矩阵、多元统计分析等领域。</li></ol></li><li><p>用于相似性度量的二元函数应满足那些约束条件？<br>用于相似性度量的二元函数通常被称为相似性度量函数或相似性度量指标。这些函数用于衡量两个对象之间的相似性或相异性。这些函数应满足以下一些常见的约束条件和性质：</p><ol><li><strong>非负性（Non-Negativity）</strong>：相似性度量函数的值应始终为非负数，即对于所有的输入x和y，d(x, y) &gt;= 0。</li><li><strong>自反性（Reflexivity）</strong>：函数应满足自反性，即对于所有的输入x，d(x, x) = 0。这表示一个对象与自身的相似性应该最大。</li><li><strong>对称性（Symmetry）</strong>：函数应满足对称性，即对于所有的输入x和y，d(x, y) = d(y, x)。这表示两个对象之间的相似性度量不应依赖于它们的顺序。</li><li><strong>三角不等式（Triangle Inequality）</strong>：函数应满足三角不等式，即对于所有的输入x、y和z，d(x, y) + d(y, z) &gt;= d(x, z)<br>。这表示通过中介对象y测量的距离不应该小于直接测量的距离。</li><li><strong>有界性（Boundedness）</strong>：一些相似性度量函数可能需要满足有界性，即存在一个上界，使得函数的值不会无限增长。这可以帮助确保度量的稳定性</li></ol></li><li><p>闵可夫斯基距离包含那些类型，他们之间的关系如何？如何编程实现？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107104243479.png" alt="image-20240107104243479"  /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minkowski_distance</span>(<span class="params">x, y, p=<span class="number">2</span></span>):</span><br><span class="line">    <span class="keyword">if</span> p == np.inf:</span><br><span class="line">        <span class="keyword">return</span> np.<span class="built_in">max</span>(np.<span class="built_in">abs</span>(x - y))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> np.power(np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(x - y) ** p), <span class="number">1</span>/p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">point1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">point2 = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">p1_distance = minkowski_distance(point1, point2, p=<span class="number">1</span>)  <span class="comment"># 曼哈顿距离</span></span><br><span class="line">p2_distance = minkowski_distance(point1, point2, p=<span class="number">2</span>)  <span class="comment"># 欧几里德距离</span></span><br><span class="line">p_inf_distance = minkowski_distance(point1, point2, p=np.inf)  <span class="comment"># 切比雪夫距离</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;曼哈顿距离:&quot;</span>, p1_distance)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;欧几里德距离:&quot;</span>, p2_distance)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;切比雪夫距离:&quot;</span>, p_inf_distance)</span><br></pre></td></tr></table></figure></li><li><p>什么是马氏距离？它与欧氏距离有什么关系？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107104452368.png" alt="image-20240107104452368"></p></li><li><p>什么是余弦距离和余弦相似度？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107104840688.png" alt="image-20240107104840688"></p></li><li><p>什么是汉明距离？</p><p>汉明距离是指两个等长字符串之间的汉明距离，即两个字符串在相同位置上不同字符的个数。汉明距离以理查德·卫斯里·汉明的名字命名，是一种用于比较两个二进制数据字符串的度量。在信息论中，汉明距离也用于表示两个等长字符串之间的相似度，即需要替换多少个字符才能将一个字符串变成另一个字符串。</p><p>计算汉明距离的方法是，对两个字符串进行异或运算，并统计结果为1的个数。如果两个字符相同，则异或结果为0；如果两个字符不同，则异或结果为1。因此，对两个字符串进行异或运算，可以得出每个位置上不同字符的个数，即汉明距离。</p><p>汉明距离也可以用于比较两个等长二进制数据块的差异程度。在这种情况下，汉明距离可以用来检测数据传输中的错误。在数据传输过程中，如果由于噪音或干扰导致数据发生错误，那么接收端可以通过计算收到的数据与发送端的数据之间的汉明距离来检测错误。如果汉明距离较小，说明数据传输中错误较少；如果汉明距离较大，说明数据传输中错误较多。</p><p>此外，汉明重量是字符串相对于同样长度的零字符串的汉明距离，即非零的元素个数。对于二进制字符串来说，1的个数即为汉明重量。</p><p>总之，汉明距离是一种用于比较两个字符串或数据块差异程度的度量，常用于数据传输差错控制编码和信息论等领域。</p></li><li><p>什么是皮尔森距离？它与余弦距离是什么关系？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107110044522.png" alt="image-20240107110044522"></p></li><li><p>什么是斯皮尔曼距离？什么是肯德尔距离？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107110135794.png" alt="image-20240107110135794"></p></li><li><p>什么是凸集分离定理？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107110236650.png" alt="image-20240107110236650"></p></li><li><p>函数的凹凸性与极值之间的关系是什么？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107110329504.png" alt="image-20240107110329504"></p></li><li><p>什么是激活函数，其作用是什么？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107110423525.png" alt="image-20240107110423525"></p></li><li><p>函数的连续与可导的关系是什么？函数可导的充要条件是什么?</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107110515862.png" alt="image-20240107110515862"></p></li><li><p>函数导数与凹凸性的关系如何？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107110605183.png" alt="image-20240107110605183"></p></li><li><p>方向导数、梯度、散度的定义是什么？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107110650782.png" alt="image-20240107110650782"></p></li><li><p>雅可比矩阵、Hessian矩阵的定义是什么？Hessan矩阵和Jacobi矩阵的关系如何？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107110759474.png" alt="image-20240107110759474"></p></li><li><p>什么是全概率？什么是贝叶斯公式？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107110841324.png" alt="image-20240107110841324"></p></li><li><p>如何编程实现两个数组的相关性？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> pearsonr, spearmanr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个示例数组</span></span><br><span class="line">array1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">array2 = np.array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算皮尔逊相关系数</span></span><br><span class="line">pearson_corr, _ = pearsonr(array1, array2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;皮尔逊相关系数:&quot;</span>, pearson_corr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算斯皮尔曼相关系数</span></span><br><span class="line">spearman_corr, _ = spearmanr(array1, array2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;斯皮尔曼相关系数:&quot;</span>, spearman_corr)</span><br></pre></td></tr></table></figure></li><li><p>如何编程实现两个数组的协方差矩阵？协方差矩阵具有什么性质？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个示例数组</span></span><br><span class="line">array1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">array2 = np.array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算协方差矩阵</span></span><br><span class="line">cov_matrix = np.cov(array1, array2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;协方差矩阵:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cov_matrix)</span><br></pre></td></tr></table></figure><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107111018095.png" alt="image-20240107111018095"></p></li><li><p>如何编程画出正态分布曲线，分析不同参数对曲线的影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义正态分布的均值和标准差</span></span><br><span class="line">mu_values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]  <span class="comment"># 不同均值</span></span><br><span class="line">sigma_values = [<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">1.5</span>]  <span class="comment"># 不同标准差</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个x轴的值范围</span></span><br><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制不同参数下的正态分布曲线</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> mu <span class="keyword">in</span> mu_values:</span><br><span class="line">    <span class="keyword">for</span> sigma <span class="keyword">in</span> sigma_values:</span><br><span class="line">        <span class="comment"># 计算概率密度函数（PDF）</span></span><br><span class="line">        pdf = norm.pdf(x, loc=mu, scale=sigma)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 绘制曲线</span></span><br><span class="line">        label = <span class="string">f&quot;μ=<span class="subst">&#123;mu&#125;</span>, σ=<span class="subst">&#123;sigma&#125;</span>&quot;</span></span><br><span class="line">        plt.plot(x, pdf, label=label)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;不同参数下的正态分布曲线&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;随机变量值&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;概率密度&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p>什么是参数估计？参数估计量应那些基本特性？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107111229225.png" alt="image-20240107111229225"></p></li><li><p>什么是无偏估计样本？样本统计量的典型代表有哪些？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107111305015.png" alt="image-20240107111305015"></p></li><li><p>自编码器有哪些部件组成？分别具有那些功能？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107111426129.png" alt="image-20240107111426129"></p></li><li><p>联合熵、条件熵、交叉熵和相对熵是如何定义的？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107111511582.png" alt="image-20240107111511582"></p></li><li><p>卷积与池化的定义和功能是什么？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107111557806.png" alt="image-20240107111557806"></p></li><li><p>什么是过拟合与欠拟合问题？如何避免过拟合与欠拟合？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107111647208.png" alt="image-20240107111647208"></p></li><li><p>什么是奥卡姆剃刀原则？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107111730503.png" alt="image-20240107111730503"></p></li><li><p>硬正则化和软正则化分别有那些方法？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107111828990.png" alt="image-20240107111828990"></p></li><li><p>数据归一化、标准化的左右是什么？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107111948379.png" alt="image-20240107111948379"></p><p>数据归一化和标准化的作用如下：</p><ol><li>数据归一化：将数据转换到特定的范围，如0-1之间，以便更好地进行数据处理和分析。归一化可以消除数据的规模和范围对分析的影响，使得不同量级的特征具有相同的尺度，从而避免某些特征在训练时占据主导地位。<br>2.<br>数据标准化：将数据按照一定的数学公式进行转换，使得数据的平均值为0，标准差为1，从而消除数据的量纲和单位对分析的影响。标准化可以使得不同量级的特征具有相同的尺度，避免某些特征在训练时占据主导地位。同时，标准化还可以使得数据更加符合正态分布，从而更好地进行机器学习模型的训练和预测。</li></ol></li><li><p>什么是期望风险、经验风险、置信风险和VC维？它们的相互关系如何？</p><p>期望风险、经验风险、置信风险和VC维都是机器学习和统计学中的概念，它们之间存在相互关联和差异。</p><ol><li>期望风险（Expected Risk）：是泛化风险的一种表示，它是在模型训练过程中预测错误的平均损失。期望风险的数学定义为：R(f) =<br>E[L(Y, f(X))] 其中，L(Y, f(X))表示损失函数，Y是真实值，f(X)是预测值，E表示期望。期望风险反映了模型对未知数据的预测能力。</li><li>经验风险（Empirical Risk）：又称为样本风险，是训练过程中样本损失的平均值。经验风险的数学定义为：R_emp(f) = 1/N Σ L(Y_i,<br>f(X_i)) 其中，N是样本数量，L(Y_i, f(X_i))表示第i个样本的损失，Σ表示求和。经验风险反映了模型对训练数据的拟合能力。</li><li>置信风险：是模型对未知数据的预测误差的估计误差。置信风险的数学定义为：R_conf(f) = E[R(f)] - R_emp(f) 其中，E[R(f)]<br>是期望风险的期望值。置信风险反映了模型预测的不确定性。</li><li>VC维（Vapnik-Chervonenkis Dimension）：是衡量模型复杂度和学习能力的指标。VC维的定义与具体模型有关，但一般来说，如果一个模型的VC维越高，则其表示能力越强，但过拟合的风险也越大。</li></ol><p>相互关系：</p><ul><li>期望风险、经验风险和置信风险都是衡量模型风险的指标，其中期望风险关注模型对未知数据的预测能力，经验风险关注模型对训练数据的拟合能力，置信风险关注模型预测的不确定性。</li><li>VC维是衡量模型复杂度和学习能力的指标，它与期望风险、经验风险和置信风险都有关系。一般来说，如果模型的VC维越高，则其表示能力越强，但过拟合的风险也越大，这可能会导致期望风险和经验风险的差异增大，从而增加置信风险。</li></ul><p>在实际应用中，需要根据具体问题和数据特性来选择合适的模型和算法，以平衡各种风险并获得最佳的预测效果。</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107112332136.png" alt="image-20240107112332136"></p><p>这些概念之间的关系可以总结如下：</p><ul><li>经验风险是在训练数据上测量的模型性能，期望风险是在整个数据分布上的期望性能，而置信风险是期望风险的一个上界估计，用于表示不确定性。</li><li>VC维反映了模型的复杂性，与模型的能力和泛化误差有关。较高的VC维可能导致较大的期望风险，特别是在样本量较小的情况下。</li></ul></li><li><p>函数最大化问题和函数最小化问题之间的关系？当前的最优化问题一般是哪一类问题？</p><p>​<br>函数最大化问题和函数最小化问题之间存在密切的关系，它们经常可以相互转化。具体来说，如果你有一个函数最大化的问题，你可以将其转化为一个函数最小化的问题，反之亦然。这是因为最大化问题的解通常可以通过将相应的函数取负值来转化为最小化问题，而最小化问题的解可以通过将相应的函数取相反数来转化为最大化问题。</p><p>​ 当前的最优化问题一般可以分为以下几类：</p><ol><li><strong>无约束最优化问题</strong>：在这类问题中，优化目标是最大化或最小化一个函数，没有约束条件。通常，这类问题可以通过计算函数的梯度或导数来寻找最优解。</li><li><strong>有约束最优化问题</strong>：这类问题中，除了优化目标函数外，还有一些约束条件，如等式约束和不等式约束。例如，线性规划问题就是一种有约束的最优化问题。</li><li><strong>整数最优化问题</strong>：在这类问题中，决策变量被限制为整数值。整数最优化问题常见于组合优化、离散优化和排程问题。</li><li><strong>凸优化问题</strong>：凸优化问题是一种特殊的最优化问题，其中优化目标函数和约束条件都是凸函数。凸优化问题具有良好的性质和可行解的存在保证，因此在实际中广泛应用。</li><li><strong>非凸优化问题</strong>：非凸优化问题中，优化目标函数和/或约束条件至少有一个是非凸函数。非凸问题通常更具挑战性，因为它们可能具有多个局部最优解。</li></ol></li><li><p>无约束优化与约束优化之间具有什么关系？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107112631192.png" alt="image-20240107112631192"></p></li><li><p>什么是梯度下降法、牛顿法、拟牛顿法和坐标下降法？</p><ol><li><strong>梯度下降法（Gradient Descent）</strong>：<ul><li>梯度下降法是一种迭代优化算法，用于最小化目标函数。它的核心思想是通过迭代更新参数，使目标函数的值逐渐减小。</li><li>梯度下降法的步骤包括计算目标函数的梯度（导数），然后以负梯度方向作为搜索方向，更新参数。学习率是控制步长的超参数，影响算法的收敛速度和稳定性。</li><li>梯度下降法通常适用于大规模数据集和高维参数空间，但可能需要精心选择学习率。</li></ul></li><li><strong>牛顿法（Newton’s Method）</strong>：<ul><li>牛顿法是一种迭代优化算法，也用于最小化目标函数。它不仅使用目标函数的梯度，还利用了二阶导数信息（Hessian矩阵）。</li><li>牛顿法通过解牛顿方程来找到更新参数的方向，通常可以更快地收敛到局部最小值。但需要计算和存储Hessian矩阵，因此在高维参数空间中的应用有时不太实际。</li></ul></li><li><strong>拟牛顿法（Quasi-Newton Methods）</strong>：<ul><li>拟牛顿法是一类优化算法，旨在克服牛顿法中计算和存储Hessian矩阵的问题。它们通过估计Hessian矩阵的逆来近似牛顿法的步骤。</li><li>BFGS和L-BFGS（Limited-memory BFGS）是拟牛顿法的代表，它们在实际应用中往往比纯牛顿法更具吸引力，尤其是在高维参数空间中。</li></ul></li><li><strong>坐标下降法（Coordinate Descent）</strong>：<ul><li>坐标下降法是一种迭代优化算法，用于最小化目标函数，它将参数的更新分解为坐标方向的更新。</li><li>在每个迭代步骤中，坐标下降法选择一个坐标方向，将其固定，然后沿该方向最小化目标函数。这个过程在不同的坐标方向上交替进行。</li><li>坐标下降法通常用于高维优化问题，其中每次迭代只需要考虑一个坐标维度，因此计算成本较低。</li></ul></li></ol></li><li><p>相对梯度法，牛顿法、拟牛顿法具有那些改进？</p><ol><li><strong>相对梯度法</strong>：<ul><li>相对梯度法是一种基于相对梯度信息的优化算法，它不需要计算目标函数的梯度，而是使用相对梯度信息来更新参数。</li><li>优点：相对梯度法通常比传统的梯度法更鲁棒，特别适用于目标函数不可导或不易计算梯度的情况。它可以处理非光滑和非凸的目标函数。</li><li>缺点：相对梯度法可能需要更多的迭代步骤来达到收敛，因此在某些情况下可能比梯度法收敛较慢。</li></ul></li><li><strong>牛顿法</strong>：<ul><li>牛顿法是一种使用目标函数的梯度和二阶导数信息来进行迭代优化的算法。它通常能够更快地收敛到局部最小值。</li><li>优点：牛顿法通常具有更快的收敛速度，特别适用于光滑的凸优化问题。它能够更准确地估计最优解的位置。</li><li>缺点：牛顿法需要计算和存储目标函数的二阶导数（Hessian矩阵），这可能在高维问题中变得昂贵。此外，它对于非凸问题的收敛性不稳定。</li></ul></li><li><strong>拟牛顿法</strong>：<ul><li>拟牛顿法是一类优化算法，旨在克服牛顿法中计算和存储Hessian矩阵的问题。它们通过估计Hessian矩阵的逆来近似牛顿法的步骤。</li><li>优点：拟牛顿法在光滑的非线性优化问题中表现良好，并且不需要显式计算Hessian矩阵。它们通常在高维问题中表现较好。</li><li>缺点：尽管拟牛顿法在某些情况下能够提供较快的收敛速度，但它们不如牛顿法那样具有全局收敛性。此外，拟牛顿法的性能通常受到初始点的选择影响。</li></ul></li></ol><hr><p>相对梯度法，牛顿法和拟牛顿法具有以下改进：</p><ol><li>收敛速度：牛顿法和拟牛顿法通常具有比梯度下降法更快的收敛速度，因为它们利用了更高阶的信息来逼近函数的最小值点。这使得在处理大规模优化问题时，牛顿法和拟牛顿法能够更快地找到最优解。</li><li>所需梯度：梯度下降法需要计算目标函数的梯度，而牛顿法和拟牛顿法则需要计算目标函数的Hessian矩阵。在某些情况下，计算Hessian矩阵可能比计算梯度更加复杂，但牛顿法和拟牛顿法可以利用近似方法来简化这一计算过程。</li><li>局部最优解：梯度下降法容易陷入局部最优解，而牛顿法和拟牛顿法则通常能够更好地远离局部最优解，从而更有可能找到全局最优解。</li><li>参数调整：牛顿法和拟牛顿法通常需要调整的参数较少，因为它们利用了更高阶的信息，具有更好的数值稳定性和鲁棒性。</li></ol><p>综上所述，相对梯度法，牛顿法和拟牛顿法在收敛速度、所需梯度、局部最优解和参数调整等方面具有改进。在处理大规模优化问题时，这些方法通常能够更快地找到最优解，并且具有更好的数值稳定性和鲁棒性。</p></li><li><p>如果编程实现梯度下降法进行模型训练？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">X = <span class="number">2</span> * np.random.rand(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line">y = <span class="number">4</span> + <span class="number">3</span> * X + np.random.randn(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型参数</span></span><br><span class="line">theta = np.random.randn(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义学习率和迭代次数</span></span><br><span class="line">learning_rate = <span class="number">0.1</span></span><br><span class="line">num_iterations = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降训练模型</span></span><br><span class="line"><span class="keyword">for</span> iteration <span class="keyword">in</span> <span class="built_in">range</span>(num_iterations):</span><br><span class="line">    <span class="comment"># 计算梯度</span></span><br><span class="line">    gradients = -<span class="number">2</span>/<span class="built_in">len</span>(X) * X.T.dot(y - X.dot(theta))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    theta = theta - learning_rate * gradients</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印训练后的参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练后的参数 theta:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(theta)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>如果编程实现批量梯度下降算法？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">X = <span class="number">2</span> * np.random.rand(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line">y = <span class="number">4</span> + <span class="number">3</span> * X + np.random.randn(<span class="number">100</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型参数</span></span><br><span class="line">theta = np.random.randn(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义学习率和迭代次数</span></span><br><span class="line">learning_rate = <span class="number">0.1</span></span><br><span class="line">num_iterations = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量梯度下降训练模型</span></span><br><span class="line">m = <span class="built_in">len</span>(X)  <span class="comment"># 训练样本数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> iteration <span class="keyword">in</span> <span class="built_in">range</span>(num_iterations):</span><br><span class="line">    <span class="comment"># 计算梯度</span></span><br><span class="line">    gradients = -<span class="number">2</span>/m * X.T.dot(y - X.dot(theta))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    theta = theta - learning_rate * gradients</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印训练后的参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练后的参数 theta:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(theta)</span><br></pre></td></tr></table></figure></li><li><p>查准率和查全率是如何定义的？它们的关系是怎样的？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107113500900.png" alt="image-20240107113500900"></p></li><li><p>什么是P-R曲线？如何根据P-R曲线判断模型性能优劣？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107113549809.png" alt="image-20240107113549809"></p></li><li><p>什么是ROC曲线？如何根据ROC曲线判断模型性能优劣？</p><p><img src="https://images.shallowrecall.top/images/2024/1/image-20240107113622263.png" alt="image-20240107113622263"></p></li><li><p>什么是混淆矩阵？混淆矩阵主要由哪些元素构成？</p><p>混淆矩阵（Confusion Matrix），也称为误差矩阵（Error Matrix）或分类表（Contingency Table），是用于评估二分类模型性能的重要工具。它主要由以下四个元素构成：</p><ol><li><p><strong>真正例（True Positives，TP）</strong>：表示模型正确预测为正类别的样本数量。这是实际正类别样本被正确分类的数量。</p></li><li><p><strong>假正例（False Positives，FP）</strong>：表示模型错误预测为正类别的样本数量。这是实际负类别样本被错误分类为正类别的数量。</p></li><li><p><strong>真负例（True Negatives，TN）</strong>：表示模型正确预测为负类别的样本数量。这是实际负类别样本被正确分类的数量。</p></li><li><p><strong>假负例（False Negatives，FN）</strong>：表示模型错误预测为负类别的样本数量。这是实际正类别样本被错误分类为负类别的数量。</p></li></ol><p>混淆矩阵通常以如下形式呈现：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">         |   实际正类别    |    实际负类别</span></span><br><span class="line"><span class="section">----------------------------------------</span></span><br><span class="line"><span class="section">预测为正 |   TP            |    FP</span></span><br><span class="line"><span class="section">----------------------------------------</span></span><br><span class="line">预测为负 |   FN            |    TN</span><br></pre></td></tr></table></figure><p>混淆矩阵的四个元素可以用于计算各种性能指标，包括查准率（Precision）、查全率（Recall）、F1分数（F1-Score）、准确率（Accuracy）、假正例率（False<br>Positive Rate，FPR）等，这些指标有助于全面评估模型的性能。</p><p>混淆矩阵是评估二分类模型性能的关键组成部分，它提供了详细的信息，帮助我们理解模型在不同类别上的表现，特别是在类别不平衡的情况下。通过分析混淆矩阵，可以确定模型的优势和劣势，优化模型的性能，以及根据任务需求进行适当的调整。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如何实现两个向量的数乘、内积、外积和分量乘法？&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    <category term="大学课程" scheme="https://www.shallowrecall.top/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="机器学习数学基础" scheme="https://www.shallowrecall.top/categories/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>响应状态码</title>
    <link href="https://www.shallowrecall.top/posts/505b9ee7.html"/>
    <id>https://www.shallowrecall.top/posts/505b9ee7.html</id>
    <published>2023-12-17T04:54:28.000Z</published>
    <updated>2024-12-01T10:47:28.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、状态码大类"><a href="#一、状态码大类" class="headerlink" title="一、状态码大类"></a>一、状态码大类</h2><div class="table-container"><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong>——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</td></tr><tr><td>2xx</td><td><strong>成功</strong>——表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong>——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong>——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong>——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table></div><h2 id="二、常见的响应状态码"><a href="#二、常见的响应状态码" class="headerlink" title="二、常见的响应状态码"></a>二、常见的响应状态码</h2><div class="table-container"><table><thead><tr><th>状态码</th><th>英文描述</th><th>解释</th></tr></thead><tbody><tr><td><code>200</code></td><td><strong><code>OK</code></strong></td><td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td></tr><tr><td>302</td><td><strong><code>Found</code></strong></td><td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td></tr><tr><td>304</td><td><strong><code>Not Modified</code></strong></td><td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td></tr><tr><td>400</td><td><strong><code>Bad Request</code></strong></td><td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td></tr><tr><td>403</td><td><strong><code>Forbidden</code></strong></td><td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td></tr><tr><td><code>404</code></td><td><strong><code>Not Found</code></strong></td><td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td></tr><tr><td>405</td><td><strong><code>Method Not Allowed</code></strong></td><td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td></tr><tr><td>428</td><td><strong><code>Precondition Required</code></strong></td><td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td></tr><tr><td>429</td><td><strong><code>Too Many Requests</code></strong></td><td>指示用户在给定时间内发送了<strong>太多请求</strong>（“限速”），配合 Retry-After(多长时间后可以请求)响应头一起使用</td></tr><tr><td>431</td><td><strong><code>Request Header Fields Too Large</code></strong></td><td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td></tr><tr><td><code>500</code></td><td><strong><code>Internal Server Error</code></strong></td><td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td></tr><tr><td>503</td><td><strong><code>Service Unavailable</code></strong></td><td><strong>服务器尚未准备好处理请求</strong>，服务器刚刚启动，还未初始化好</td></tr></tbody></table></div><p>状态码大全：<a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、状态码大类&quot;&gt;&lt;a href=&quot;#一、状态码大类&quot; class=&quot;headerlink&quot; title=&quot;一、状态码大类&quot;&gt;&lt;/a&gt;一、状态码大类&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;t</summary>
      
    
    
    
    
    <category term="技术" scheme="https://www.shallowrecall.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>词汇</title>
    <link href="https://www.shallowrecall.top/posts/85fc7b85.html"/>
    <id>https://www.shallowrecall.top/posts/85fc7b85.html</id>
    <published>2023-11-01T03:26:54.000Z</published>
    <updated>2024-12-01T10:47:28.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2023-11-1"><a href="#2023-11-1" class="headerlink" title="2023-11-1"></a>2023-11-1</h3><h4 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h4><ol><li>comment     n. 评论  v. 表达意见 </li><li>private              adj. 私人的，个人的     ==  personal</li><li>take out            v. 取出，除去; 拔掉; 把…带出去; 邀请（某人）外出</li><li>context              n. 上下文，情景，语境</li><li>ruin                    v. 毁掉，摧毁</li><li>candidate          n. 候选人; 应试者; 申请人; 被认定适合者</li><li>hired                   v. 聘用( hire的过去式和过去分词 ); 录用; 雇用; 租用</li><li>conversely          adv. 相反的</li><li>opt                       v. 选择 (for)</li><li>fit                          v. 适合</li><li><p>align                     v. 和……相符(with)，匹配  vt. 使成一线，使结盟; 排整齐 vi. 排列; 成一条线</p></li><li><p>sense                   n. 感觉，官能; 意识，观念; 理性; 识别力 vt. 感到; 理解，领会; 检测出</p></li><li>confidence          n. 信心; 信任; 秘密  adj. 骗得信任的; 欺诈的</li><li>proposal              n. 提议; 建议; 求婚; 〈美〉投标</li><li>propose               v. 提议，建议; 打算，计划; 推荐，提名; 求婚 vi. 做出计划，打算; 求婚</li><li>strengthen          vt. 加强，巩固; 勉励，激励; 增加…的艺术效果; （价格）上涨 vi. 变强; 变坚挺</li></ol><blockquote><p>“en” 是一个英文中的后缀，通常用于动词上，用以表示使动用法。当在动词后加上 “-en” 后缀时，通常会改变动词的词性或者增强其含义。这种形式在一些动词中使用较为常见，例如：</p><ol><li>Soften（软化）：make or become soft（使变软或变得柔软）。</li><li>Brighten（变亮）：make or become brighter（使变亮或变得明亮）。</li><li>Flatten（变平）：make or become flat（使变平或变得平坦）。</li><li>Darken（变暗）：make or become dark（使变暗或变得昏暗）。</li></ol><p>这些是一些常见的以 “-en” 结尾的动词示例，但并非所有以此后缀结尾的动词都遵循相同的规则，因此在学习和使用中应注意具体的词义和用法。</p></blockquote><ol><li>digital                  adj. 数字的; 数据的; 手指的; 指状的 n. 手指; （钢琴等的）琴键; 数字</li><li>inheritance        n. 继承; 遗传; 遗产</li><li>heritage               n. 遗产; 继承物; 传统; 文化遗产 </li><li>archaeologists    n. 考古学家</li><li>seek                      vt. 寻找，探寻; 追求，谋求; 往或朝…而去; [废语]考察 vi. 查找，查寻; 找一找</li><li>rise                        vi. 上升；攀升；提高；达到较高水平（或位置）；起床；起立；站起来；升起 n. （数量或水平的）增加，提高；加薪；工资增长；(重要性、优势、权力等的)增强</li><li>go to great length to do sth            竭尽全力做某</li><li>reputation                                          n.名声，名誉</li><li>the + adj                                              表示一类人 eg : the poor 穷人、the rich 富人</li><li>give sb sth/give sth to sb                  给某人某物</li><li>promotion                                           n.促进，增进; 提升，升级; （商品等的）推广; 发扬</li><li>limited-edition                                    adj. 限量版的</li><li>blind-box                                             n. 盲盒</li><li>family bucket                                      全家桶</li><li>induce                                                  vt. 引诱; 引起; [电]感应; 归纳</li><li>impulse purchase                               冲动消费，冲动购物</li><li>consumer                                             n. 消费者，顾客</li><li>cause                                                     n. 原因; 动机; 理由; 事业  vt. 成为…的原因; 导致; 引起; 使遭受</li><li>deal                                                       vt. [牌戏]分; 分配; 经营; 施予 n. （一笔）交易; 许多; 待遇; 发牌 vi. 论述; （有效地或成功地）处理; 惩处; 交易 adj. 冷杉木制的，松木制的</li><li>be expected to do sth                        有望做某事，应该做某事</li><li>value                                                      n. 价值，价格; 意义，涵义; 重要性; （邮票的）面值  vt. 评价; 重视，看重; 估价，给…定价</li><li>million                                                    n. 百万 adj. 百万的;无数的</li><li>equivalent                                              adj. 相等的，相当的，等效的; 等价的，等积的; [化学]当量的 n. 对等物; [化学]当量</li><li>equivalent to                                          相当于，折合</li><li>arund                                                       adv. 大约; 旋转; 到处，四处; 在周围 prep. 围绕; 在附近; 前后，左右; 在…周围</li><li>announce                                              vi. 宣布参加竞选; 当播音员 vt. 宣布; 述说; 声称; 预告</li><li>admire                                                   vt. 赞赏; 称赞; 欣赏; &lt;美口&gt;想要</li><li>discourage                                            vt. 使气馁; 使沮丧; 阻碍; 劝阻</li><li>spirit                                                       n. 精神，心灵; 情绪; 勇气; 精髓 v. 神秘地带走</li><li>team spirit                                             n. 合作精神，团队精神</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;2023-11-1&quot;&gt;&lt;a href=&quot;#2023-11-1&quot; class=&quot;headerlink&quot; title=&quot;2023-11-1&quot;&gt;&lt;/a&gt;2023-11-1&lt;/h3&gt;&lt;h4 id=&quot;词汇&quot;&gt;&lt;a href=&quot;#词汇&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="英语学习" scheme="https://www.shallowrecall.top/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
</feed>
